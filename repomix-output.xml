This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    dev-workflow.yml
docs/
  bugfixes/
    openbugs.md
  new features/
    simulation-improvement-4juli/
      implementation.md
      specs.md
    0-template.md
    ai-automatic-categorisation.md
    category-simulations-future.md
    category-simulations.md
    end-to-end-encryption.md
    mathapi-production-ready.md
    predictions-page.md
    production-kubernetes.md
    project-architecture.md
  best-practices.md
  ENDPOINT_MIGRATION.md
  simplemadeeasy.md
kube/
  config/
    dev/
      ai-config.yml
      api-config.yml
      mathapi-config.yml
      web-config.yml
  dev/
    api-deployment.yml.template
    api-service.yml
    mathapi-deployment.yml
    mathapi-deployment.yml.template
    mathapi-service.yml
    web-deployment.yml.template
    web-service.yml
  grafana/
    custom-values.yml
  prometheus/
    custom-values.yml
    persistent-volume-claim.yml
    persistent-volume.yml
    prometheus.yml
lib/
  utils.ts
packages/
  api/
    src/
      controllers/
        aiSuggestionsController.test.ts
        aiSuggestionsController.ts
        budgetController.ts
        scheduledTransactionController.test.ts
        scheduledTransactionController.ts
        simulation.controller.ts
        syncController.ts
        transactionController.test.ts
        transactionController.ts
        userController.ts
        utils.ts
      data/
        accounts/
          account.schema.ts
          account.server.ts
        budget/
          budget.schema.ts
          budget.server.ts
        category/
          category.schema.ts
          category.server.test.ts
          category.server.ts
        forecasting/
          es-forcasting.server.test.ts
          es-forcasting.server.ts
          test.json
        simulation/
          simulation.schema.ts
          simulation.server.test.ts
          simulation.server.ts
        sync/
          sync.server.ts
        transaction/
          transaction.schema.ts
          transaction.server.test.ts
          transaction.server.ts
          utils.test.ts
          utils.ts
        user/
          user.schema.ts
          user.server.ts
        utils/
          category-usage.reducer.ts
          category.history.reducer.test.ts
          category.history.reducer.ts
          month.summary.reducer.ts
        ynab/
          transaction.util.test.ts
          transaction.util.ts
          ynab-api.ts
          ynab.schema.ts
          ynab.server.ts
        ai.server.ts
        db.ts
        main.budget.server.test.ts
        main.budget.server.ts
      models/
        simulation.model.ts
        simulation.ts
      routes/
        budgetRoutes.ts
        scheduledTransactions.ts
        simulation.routes.ts
        syncRoutes.ts
        userRoutes.ts
      services/
        openai.service.ts
        payeeMappings.service.ts
      utils/
        validation.ts
      index.ts
      instrument.ts
      metrics.ts
    tests/
      test.mockdata.mocks.ts
    Dockerfile
    package.json
    tsconfig.json
    vitest.config.ts
  common-ts/
    src/
      amounts/
        amounts.test.ts
        index.ts
      budget/
        budget.utils.ts
        index.ts
      category/
        category.utils.ts
        index.ts
      components/
        AmountInput.tsx
        forms.tsx
      forecasting/
        index.ts
      logging/
        index.ts
      transaction/
        index.ts
        transaction.utils.ts
      user/
        index.ts
      index.ts
      main.budget.utils.ts
    package.json
    rollup.config.js
    tsconfig.json
    tsconfig.lib.json
    tsconfig.spec.json
    vitest.config.ts
  mathapi/
    app/
      simulations/
        no_salary_cost_simulation.json
        reduced-salary.json
      templates/
        balance_projection.html
      tests/
        unit/
          README.md
          test_prediction_api.py
        __init__.py
        conftest.py
        README.md
      accounts_api.py
      app.py
      auth.py
      budget_api.py
      categories_api.py
      db.py
      models.py
      prediction_api.py
      ynab_api.py
    .env.example
    .gitignore
    Dockerfile
    pytest.ini
    readme.md
    requirements.txt
    test_domiciliering.py
    testdata.json
  web/
    __tests__/
      app/
        api/
          budget.server.test.ts
        components/
          transactions-page/
            payee-tooltip.test.tsx
          budget-navigation.test.tsx
        utils/
          functional.test.ts
    app/
      api/
        auth/
          [...nextauth]/
            route.ts
          token/
            route.ts
        budget/
          budget.client.ts
        defauth/
          [auth0]/
            route.ts
        metrics/
          route.ts
        sentry-example-api/
          route.ts
        sync/
          route.ts
          sync.client.ts
        transaction/
          transaction.client.ts
        user/
          user.client.ts
        ynab/
          auth.ts
        accounts.client.ts
        accounts.server.ts
        ai-suggestions.server.ts
        categories.client.ts
        client.ts
        math.server.ts
        scheduledTransactions.client.ts
        utils.server.ts
      budgets/
        [budgetUuid]/
          predictions/
            actions.ts
            CategoryChangesForm.tsx
            constants.ts
            EditTransactionDialog.tsx
            FutureChangesSection.tsx
            FutureChangesTable.tsx
            InteractiveSimulations.tsx
            InteractiveSimulationsSection.tsx
            page.tsx
            prediction-data.server.ts
            PredictionChartSection.tsx
            SimulationForm.tsx
            SimulationList.tsx
          transactions/
            actions.ts
            page.tsx
          uncategorised/
            actions.ts
            page.tsx
            TransactionsDataSection.tsx
            TransactionsPageWithTabs.tsx
            UnapprovedStats.tsx
            UnapprovedTransactionsContent.tsx
            UnapprovedTransactionsList.tsx
            UncategorisedStats.tsx
            UncategorisedTransactionsContent.tsx
            UncategorisedTransactionsList.tsx
          page.tsx
      components/
        budget-page/
          category-card.tsx
          current-month.tsx
          hidden-progress-bars.tsx
          index.tsx
          month-summary-block.tsx
          month-total-overview.tsx
        charts/
          category-pie-chart.tsx
          mothly-spending-chart.tsx
          payee-activity-chart.tsx
          test-chart.tsx
          util.tsx
        login/
          index.tsx
          ynab.tsx
        transactions-page/
          category-editor.tsx
          category-select.tsx
          index.tsx
          payee-chart.tsx
          payee-tooltip.tsx
          payeeWithActivity-reducer.ts
          transaction-amount.tsx
          transaction-badge.tsx
          transaction-card.tsx
          transaction-content.tsx
          transaction-date-group.tsx
          transaction-filters.tsx
          transaction-list.tsx
          transaction-totals.tsx
          utils.tsx
        budget-navigation.tsx
        budget-sub-navigation.tsx
        Loading.tsx
        progress.tsx
        ynab-login-page.tsx
      hooks/
        use-category-update.ts
      lib/
        metrics.ts
      login/
        page.tsx
      sentry-example-page/
        page.tsx
      utils/
        functional.ts
        index.ts
      ynablogin/
        page.tsx
      _app.tsx
      global-error.tsx
      globals.css
      layout.tsx
      page.tsx
    components/
      charts/
        prediction-chart.tsx
      ui/
        button.tsx
        calendar.tsx
        dialog.tsx
        input.tsx
        label.tsx
        popover.tsx
        select.tsx
        sonner.tsx
        switch.tsx
    lib/
      utils.ts
    mongoplayground/
      playground-1.mongodb.js
      playground-2.mongodb.js
      playground-budget-mongodb.js
    public/
      next.svg
      vercel.svg
    .env.example
    .eslintrc.json
    .gitignore
    components.json
    Dockerfile
    instrumentation.ts
    next.config.js
    package.json
    postcss.config.js
    README.md
    sentry.client.config.ts
    sentry.edge.config.ts
    sentry.server.config.ts
    tailwind.config.ts
    tsconfig.json
    vitest.config.ts
    vitest.setup.ts
.gitignore
docker-commands.md
docker-compose.yml
grafana.md
kubectl-dev.md
package.json
prometheus-queries.md
readme.md
test-endpoint-migration.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="kube/config/dev/ai-config.yml">
apiVersion: v1
kind: ConfigMap
metadata:
  name: budget-ai-dev-config
  namespace: dev
data:
  NEXTAUTH_URL: https://budget-dev.vandenit.be
  AUTH0_BASE_URL: https://budget-dev.vandenit.be
  AUTH0_ISSUER_BASE_URL: "https://vandenit.eu.auth0.com"
  AUTH0_SCOPE: "openid profile"
  AUTH0_CALLBACK: api/defauth/callback
  AUTH0_AUDIENCE: "https://vandenit.eu.auth0.com/api/v2/"
  API_URL: "http://budget-api-svc.dev:4000"
</file>

<file path="kube/config/dev/api-config.yml">
apiVersion: v1
kind: ConfigMap
metadata:
  name: budget-api-dev-config
  namespace: dev
data:
  NEXTAUTH_URL: https://budget-dev.vandenit.be
  AUTH0_BASE_URL: https://budget-dev.vandenit.be
  AUTH0_ISSUER_BASE_URL: "https://vandenit.eu.auth0.com"
  AUTH0_SCOPE: "openid profile"
  AUTH0_CALLBACK: api/defauth/callback
  AUTH0_AUDIENCE: "https://vandenit.eu.auth0.com/api/v2/"
  API_URL: "http://budget-api-svc.dev:4000"
</file>

<file path="kube/dev/api-deployment.yml.template">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: budget-api-app
  namespace: dev
  labels:
    app: budget-api-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: budget-api-app
  template:
    metadata:
      labels:
        app: budget-api-app
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/path: "/metrics"
        prometheus.io/port: "4000"
    spec:
      containers:
        - name: budget-api-app
          image: filipvdb321/budget-api:${IMAGE_TAG}
          ports:
            - containerPort: 4000
              name: http
          envFrom:
            - secretRef:
                name: budget-api-dev-secrets
            - configMapRef:
                name: budget-api-dev-config
      imagePullSecrets:
        - name: regcred-dev
</file>

<file path="kube/dev/api-service.yml">
apiVersion: v1
kind: Service
metadata:
  name: budget-api-svc
  namespace: dev
  labels:
    app: budget-api-app
spec:
  ports:
    - port: 4000
      targetPort: 4000
      protocol: TCP
  selector:
    app: budget-api-app
</file>

<file path="kube/dev/web-deployment.yml.template">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: budget-web-app
  namespace: dev
  labels:
    app: budget-web-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: budget-web-app
  template:
    metadata:
      labels:
        app: budget-web-app
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/path: "/api/metrics"
        prometheus.io/port: "3000"
    spec:
      containers:
        - name: budget-web-app
          image: filipvdb321/budget-web:${IMAGE_TAG}
          ports:
            - containerPort: 3000
              name: http
          envFrom:
            - secretRef:
                name: budget-web-dev-secrets
            - configMapRef:
                name: budget-web-dev-config
      imagePullSecrets:
        - name: regcred-dev
</file>

<file path="kube/dev/web-service.yml">
apiVersion: v1
kind: Service
metadata:
  name: budget-web-svc
  namespace: dev
  labels:
    app: budget-web-app
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 3000
      protocol: TCP
  selector:
    app: budget-web-app
</file>

<file path="kube/grafana/custom-values.yml">
persistence:
  enabled: true
  storageClassName: "standard"
  accessModes:
    - ReadWriteOnce
  size: 2Gi
</file>

<file path="kube/prometheus/custom-values.yml">
server:
  persistentVolume:
    enabled: true
    existingClaim: prometheus-pvc
  additionalScrapeConfigs:
    - job_name: "budget-web-app"
      kubernetes_sd_configs:
        - role: pod
      relabel_configs:
        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
          action: keep
          regex: true
        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
          action: replace
          target_label: __metrics_path__
          regex: (.+)
        - source_labels:
            [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
          action: replace
          target_label: __address__
          regex: (.+):(?:\d+);(\d+)
          replacement: $1:$2

    - job_name: "budget-api-app"
      kubernetes_sd_configs:
        - role: pod
      relabel_configs:
        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
          action: keep
          regex: true
        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
          action: replace
          target_label: __metrics_path__
          regex: (.+)
        - source_labels:
            [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
          action: replace
          target_label: __address__
          regex: (.+):(?:\d+);(\d+)
          replacement: $1:$2
    - job_name: "budget-ai-app"
      kubernetes_sd_configs:
        - role: pod
      relabel_configs:
        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
          action: keep
          regex: true
        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
          action: replace
          target_label: __metrics_path__
          regex: (.+)
        - source_labels:
            [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
          action: replace
          target_label: __address__
          regex: (.+):(?:\d+);(\d+)
          replacement: $1:$2
</file>

<file path="kube/prometheus/persistent-volume-claim.yml">
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: prometheus-pvc
  namespace: monitoring
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
</file>

<file path="kube/prometheus/persistent-volume.yml">
apiVersion: v1
kind: PersistentVolume
metadata:
  name: prometheus-pv
spec:
  capacity:
    storage: 2Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/data/prometheus"
</file>

<file path="kube/prometheus/prometheus.yml">
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: "budget-web-app"
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
      - source_labels:
          [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
        action: replace
        target_label: __address__
        regex: (.+):(?:\d+);(\d+)
        replacement: $1:$2

  - job_name: "budget-api-app"
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
      - source_labels:
          [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
        action: replace
        target_label: __address__
        regex: (.+):(?:\d+);(\d+)
        replacement: $1:$2
</file>

<file path="packages/api/src/controllers/transactionController.test.ts">
import { describe, it, vi, expect, afterEach, beforeEach } from "vitest";
import { getFilteredTransactionsWithCategories } from "./transactionController";
import {
  mockCategories,
  mockTransactions,
} from "../../tests/test.mockdata.mocks";
import { Response } from "express";

const createMockResponse = () => {
  const res: Partial<Response> = {};
  res.json = vi.fn().mockReturnValue(res);
  res.status = vi.fn().mockReturnValue(res);
  return res as Response;
};

const res = createMockResponse();

const mocks = vi.hoisted(() => {
  return {
    getFilteredTransactions: vi.fn(),
    findCategories: vi.fn(),
    getUserByAuthId: vi.fn(),
    getBudgetBudget: vi.fn(),
  };
});

vi.mock("../data/user/user.server", () => ({
  getUserByAuthId: mocks.getUserByAuthId,
}));

vi.mock("../data/budget/budget.server", () => ({
  getBudget: mocks.getBudgetBudget,
}));

vi.mock("../data/main.budget.server", () => ({
  getFilteredTransactions: mocks.getFilteredTransactions,
}));
vi.mock("../data/category/category.server", () => ({
  findCategories: mocks.findCategories,
}));

const mockUser = {
  // Mocked user object
  authId: "test",
  name: "Test User",
  // Add other necessary user properties
};

const mockBudget = {
  // Mocked budget object
  id: "test",
  name: "Test Budget",
  // Add other necessary budget properties
};

const req: any = {
  auth: {
    payload: {
      sub: "test",
    },
  },
  params: {
    uuid: "test",
  },
  query: {
    month: "1",
    dayOfMonth: "1",
  },
};

describe("getFilteredTransactionsWithCategories", () => {
  mocks.getFilteredTransactions.mockResolvedValue(mockTransactions);
  mocks.findCategories.mockResolvedValue(mockCategories);
  mocks.getUserByAuthId.mockResolvedValue(mockUser);
  mocks.getBudgetBudget.mockResolvedValue(mockBudget);

  it("should return the transactions and filtered categories", async () => {
    // Act
    await getFilteredTransactionsWithCategories(req, res);
    //
    // Assert
    expect(res.json).toHaveBeenCalledWith({
      transactions: mockTransactions,
      // only categories present in the transactions should be returned
      // with amount of transaction
      categories: [
        {
          _id: "1",
          key: "mock category",
          activity: 300,
        },
      ],
    });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });
});
</file>

<file path="packages/api/src/controllers/transactionController.ts">
import { Request, Response } from "express";
import { Category, Transaction } from "common-ts";
import { getFilteredTransactions } from "../data/main.budget.server";
import { getUserFromReq } from "./utils";
import { getBudget } from "../data/budget/budget.server";
import { findCategories } from "../data/category/category.server";
import { categoryUsageReducer } from "../data/utils/category-usage.reducer";

const inTransactions = (transactions: Transaction[]) => (category: Category) =>
  transactions.some((t) => `${t.categoryId}` === `${category._id}`);

const noTransfersFilter = (t: Transaction) => t.categoryId !== undefined;

export const getFilteredTransactionsWithCategories = async (
  req: Request,
  res: Response
) => {
  // get user from database
  const user = await getUserFromReq(req);
  if (!user) {
    console.error("no user found");
    return res.status(401).send("Unauthorized");
  }
  const budgetUuid = req.params.uuid;
  // print all req.params
  //print all query
  const { month, dayOfMonth } = req.query;
  const budget = await getBudget(budgetUuid, user);
  if (!budget) {
    console.error(`budget ${budgetUuid} does not belong to user`);
    return res.status(401).send("Unauthorized");
  }
  const dbTransactions = await getFilteredTransactions(
    budget._id,
    month?.toString(),
    dayOfMonth?.toString()
  );
  const transactions = dbTransactions.filter(noTransfersFilter);
  const categoriesFromDb = (await findCategories(budget._id)).filter(
    inTransactions(transactions)
  );
  // todo populate categories from transactions to have real usage
  const categories = transactions.reduce(
    categoryUsageReducer(categoriesFromDb),
    []
  );

  res.json({ transactions, categories });
};
</file>

<file path="packages/api/src/data/accounts/account.schema.ts">
import mongoose, { model, Schema } from "mongoose";

export type LocalAccountType = {
  _id?: string;

  uuid: string;

  name: string;
  /**
   * The current balance of the account in milliunits format
   * @type {number}
   * @memberof Account
   */
  balance: number;
  /**
   * The current cleared balance of the account in milliunits format
   * @type {number}
   * @memberof Account
   */
  cleared_balance: number;
  /**
   * The current uncleared balance of the account in milliunits format
   * @type {number}
   * @memberof Account
   */
  uncleared_balance: number;

  budgetId: string;
};

const localAccountSchema = new Schema({
  uuid: { type: String, index: true, unique: true },
  name: String,
  balance: Number,
  cleared_balance: Number,
  uncleared_balance: Number,
  budgetId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "LocalBudget",
  },
});

export const LocalAccount =
  mongoose.models.LocalAccount || model("LocalAccount", localAccountSchema);
</file>

<file path="packages/api/src/data/budget/budget.schema.ts">
import mongoose from "mongoose";
const { Schema, model } = mongoose;

const localBudgetSchema = new Schema({
  users: [
    {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
  ],
  uuid: { type: String, index: true, unique: true },
  name: String,
});

export const LocalBudget =
  mongoose.models.LocalBudget || model("LocalBudget", localBudgetSchema);
</file>

<file path="packages/api/src/data/budget/budget.server.ts">
import { UserType } from "../user/user.server";
import { LocalBudget } from "./budget.schema";
import { Budget, NewBudget } from "common-ts";

export const findBudgets = async (userInput: UserType): Promise<Budget[]> => {
  const localBudgets = await LocalBudget.find({ users: userInput._id });
  return localBudgets.map((localBudget) => ({
    _id: localBudget._id,
    uuid: localBudget.uuid,
    name: localBudget.name,
  }));
};

const mapLocalBudget = (localBudget: any): Budget => ({
  _id: localBudget._id,
  uuid: localBudget.uuid,
  name: localBudget.name,
});

export const getBudgetWithoutUserCheck = async (
  uuid: string
): Promise<Budget | null> => {
  const localBudget = await LocalBudget.findOne({ uuid });
  if (!localBudget) {
    return null;
  }
  return mapLocalBudget(localBudget);
};

export const getBudget = async (
  uuid: string,
  user: UserType
): Promise<Budget | null> => {
  const localBudget = await LocalBudget.findOne({ uuid, users: user._id });
  if (!localBudget) {
    return null;
  }
  return mapLocalBudget(localBudget);
};

export const saveNewBudget = async (
  budget: NewBudget,
  user: UserType
): Promise<void> => {
  const localBudget = new LocalBudget({
    users: [user._id],
    uuid: budget.uuid,
    name: budget.name,
  });
  console.log("saving new budget: " + JSON.stringify(localBudget));
  await localBudget.save();
};

export const updateBudget = async (
  uuid: string,
  name: string,
  userInput: UserType
): Promise<void> => {
  // update name and add users to budget users array
  await LocalBudget.updateOne(
    { uuid },
    { name, $addToSet: { users: userInput._id } }
  );
};
</file>

<file path="packages/api/src/data/category/category.schema.ts">
import mongoose from "mongoose";
const { Schema, model } = mongoose;

export type LocalCategoryType = {
  _id?: string;
  name: string;
  uuid: string;
  balance: number;
  budgeted: number;
  activity: number;
  targetAmount: number;
  budgetId: mongoose.Schema.Types.ObjectId;
  typicalSpendingPattern: number;
  historicalAverage: number;
};

const localCategorySchema = new Schema({
  uuid: { type: String, index: true, unique: true },
  name: String,
  balance: Number,
  budgeted: Number,
  activity: Number,
  targetAmount: Number,
  historicalAverage: Number,
  typicalSpendingPattern: Number,
  budgetId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "LocalBudget",
  },
  target: {
    goal_type: {
      type: String,
      enum: ["TB", "TBD", "MF", "NEED", "DEBT"],
      default: null,
    }, // Type van doel
    goal_day: { type: Number, default: null }, // Dag offset voor de doel-vervaldatum
    goal_cadence: { type: Number, default: null }, // Cadans van het doel (0-14)
    goal_cadence_frequency: { type: Number, default: null }, // Frequentie modifier voor de cadans
    goal_creation_month: { type: String, default: null }, // Creatiemaand van het doel (bijv. "2024-01")
    goal_target: { type: Number, default: null }, // Doelbedrag in milliunits
    goal_target_month: { type: String, default: null }, // Doelmaand voor voltooiing van het doel
    goal_percentage_complete: { type: Number, default: null }, // Percentage voltooiing van het doel
    goal_months_to_budget: { type: Number, default: null }, // Aantal maanden over in de huidige doelperiode
    goal_under_funded: { type: Number, default: null }, // Bedrag dat nodig is voor deze maand om op schema te blijven
    goal_overall_funded: { type: Number, default: null }, // Totale hoeveelheid gefinancierd voor het doel
    goal_overall_left: { type: Number, default: null }, // Bedrag dat nog nodig is om het doel te bereiken
  },
});

const categoryHistorySchema = new Schema({
  categoryId: { type: mongoose.Schema.Types.ObjectId, ref: "LocalCategory" },
  activity: Number,
  month: { type: String, index: true },
  budgetId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "LocalBudget",
  },
});

// combination categoryId month is unique
categoryHistorySchema.index({ categoryId: 1, month: 1 }, { unique: true });

export const LocalCategory =
  mongoose.models.LocalCategory || model("LocalCategory", localCategorySchema);

export const LocalCategoryHistory =
  mongoose.models.CategoryHistory ||
  model("CategoryHistory", categoryHistorySchema);
</file>

<file path="packages/api/src/data/category/category.server.test.ts">
import { describe, it, expect, vi, afterEach } from "vitest";
import { saveSpendingData } from "./category.server";
import * as categoryServer from "./category.server";
import { LocalCategory, LocalCategoryHistory } from "./category.schema";
import { exec } from "child_process";

describe("categoryServer tests", () => {
  describe("saveSpendingData", () => {
    it("should update the category data for each category", async () => {
      const categoryData = [
        {
          categoryId: "1",
          historicalAverage: 100,
          typicalSpendingPattern: 50,
        },
        {
          categoryId: "2",
          historicalAverage: 200,
          typicalSpendingPattern: 60,
        },
      ];

      // Mock the LocalCategory.bulkWrite function
      const bulkWriteMock = vi.fn();
      vi.mocked(LocalCategory).bulkWrite = bulkWriteMock;

      // Call the saveSpendingData function
      await saveSpendingData(categoryData);

      // Expect the LocalCategory.bulkWrite function to be called with the correct operations
      expect(bulkWriteMock).toHaveBeenCalledWith([
        {
          updateOne: {
            filter: { _id: "1" },
            update: {
              $set: {
                historicalAverage: 100,
                typicalSpendingPattern: 50,
              },
            },
          },
        },
        {
          updateOne: {
            filter: { _id: "2" },
            update: {
              $set: {
                historicalAverage: 200,
                typicalSpendingPattern: 60,
              },
            },
          },
        },
      ]);
    });
  });

  describe("getCategoryHistoryForBudget", () => {
    it("should return the category history for the budget", async () => {
      // Mock the getCategoryHistory function
      const aggregateMock = vi.fn();
      vi.mocked(LocalCategory).aggregate = aggregateMock;

      // Call the getCategoryHistoryForBudget function
      await categoryServer.getCategoryHistoryForBudget("123");

      // Expect the getCategoryHistory function to be called with the correct arguments
      const budgetId = "123";
      const $expr = { $eq: ["$categoryId", "$$categoryId"] };
      expect(aggregateMock).toHaveBeenCalledWith([
        {
          $match: {
            budgetId,
          },
        },
        {
          $lookup: {
            from: "categoryhistories", // The collection name for CategoryHistory
            let: { categoryId: "$_id" },
            pipeline: [
              {
                $match: {
                  $expr,
                },
              },
            ],
            as: "categoryInfo",
          },
        },
        {
          $unwind: {
            path: "$categoryInfo",
            preserveNullAndEmptyArrays: true, // Set to true if you want categories without history as well
          },
        },
        {
          $project: {
            categoryName: "$name",
            categoryUuid: "$uuid",
            categoryId: "$_id",
            month: "$categoryInfo.month",
            activity: "$categoryInfo.activity",
          },
        },
      ]);
    });
  });

  describe("getCategoryHistoryForMonth", () => {
    it("should return the category history for the budget and month", async () => {
      // Mock the getCategoryHistory function
      const aggregateMock = vi.fn();
      vi.mocked(LocalCategory).aggregate = aggregateMock;

      const month = "2021-01";
      const budgetId = "123";
      // Call the getCategoryHistoryForBudget function
      await categoryServer.getCategoryHistoryForMonth(month, budgetId);

      // Expect the getCategoryHistory function to be called with the correct arguments
      const $expr = {
        $and: [
          { $eq: ["$categoryId", "$$categoryId"] },
          { $eq: ["$month", month] },
        ],
      };
      expect(aggregateMock).toHaveBeenCalledWith([
        {
          $match: {
            budgetId,
          },
        },
        {
          $lookup: {
            from: "categoryhistories", // The collection name for CategoryHistory
            let: { categoryId: "$_id" },
            pipeline: [
              {
                $match: {
                  $expr,
                },
              },
            ],
            as: "categoryInfo",
          },
        },
        {
          $unwind: {
            path: "$categoryInfo",
            preserveNullAndEmptyArrays: true, // Set to true if you want categories without history as well
          },
        },
        {
          $project: {
            categoryName: "$name",
            categoryUuid: "$uuid",
            categoryId: "$_id",
            month: "$categoryInfo.month",
            activity: "$categoryInfo.activity",
          },
        },
      ]);
    });
  });

  describe("clearCategoryHistoryForYear", () => {
    it("should delete category history for the specified year", async () => {
      const budgetId = "123";
      const yearString = "2022";
      const execMock = vi.fn();
      // Mock the LocalCategoryHistory.deleteMany function with vi
      const deleteManyMock = vi.fn();
      deleteManyMock.mockReturnValue({
        exec: execMock,
      });
      execMock.mockResolvedValue({
        result: true,
      });
      vi.mocked(LocalCategoryHistory).deleteMany = deleteManyMock;

      // Call the clearCategoryHistoryForYear function
      const result = await categoryServer.clearCategoryHistoryForYear(
        budgetId,
        yearString
      );

      // Expect the LocalCategoryHistory.deleteMany function to be called with the correct arguments
      expect(deleteManyMock).toHaveBeenCalledWith({
        budgetId,
        month: { $regex: `^2022-` },
      });
      expect(execMock).toHaveBeenCalledOnce();
    });
  });

  describe("populateCategoryHistoryFromTransactions", () => {
    it("should insert category histories for the specified year and budgetId", async () => {
      const budgetId = "123";
      const insertManyMock = vi.fn();
      const transactions: any[] = [
        {
          categoryId: "1",
          amount: 100,
          date: "2022-01-01",
        },
        {
          categoryId: "2",
          amount: 200,
          date: "2022-01-02",
        },
      ];
      const year = "2022";

      // Mock the LocalCategoryHistory.insertMany function
      vi.mocked(LocalCategoryHistory).insertMany = insertManyMock;

      insertManyMock.mockResolvedValueOnce([]);

      // Call the populateCategoryHistoryFromTransactions function
      await categoryServer.populateCategoryHistoryFromTransactions(
        budgetId,
        transactions,
        year
      );

      // Expect the LocalCategoryHistory.insertMany function to be called with the correct arguments
      expect(insertManyMock).toHaveBeenCalledWith([
        {
          categoryId: "1",
          activity: 100,
          month: "2022-01",
          budgetId: "123",
        },
        {
          categoryId: "2",
          activity: 200,
          month: "2022-01",
          budgetId: "123",
        },
      ]);
    });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });
});
</file>

<file path="packages/api/src/data/category/category.server.ts">
import {
  LocalCategory,
  LocalCategoryHistory,
  LocalCategoryType,
} from "./category.schema";
import { Category, CategoryData, Transaction } from "common-ts";
import connectDb from "../db";
import { CategoryHistoryReducer } from "../utils/category.history.reducer";

export type CategoryHistory = {
  categoryName: string;
  categoryUuid: string;
  categoryId: string;
  month: string;
  activity: number;
  budgetId: string;
};

export type CategoryHistoryForInsert = {
  categoryId: string;
  activity: number;
  month: string;
  budgetId: string;
};

export const findCategories = async (budgetId: string): Promise<Category[]> => {
  const localCategories = await LocalCategory.find({ budgetId });
  return localCategories.map(mapLocalCategory);
};

export const getCategory = async (uuid: string): Promise<Category | null> => {
  const localCategory = await LocalCategory.findOne({ uuid });
  if (!localCategory) {
    return null;
  }
  return mapLocalCategory(localCategory);
};

export const deleteCategory = async (uuid: string) => {
  connectDb();
  await LocalCategory.deleteOne({ uuid }).exec();
};

const mapLocalCategory = (localCategory: LocalCategoryType): Category => ({
  _id: `${localCategory._id}`,
  name: localCategory.name,
  uuid: localCategory.uuid,
  balance: localCategory.balance,
  budgeted: localCategory.budgeted,
  activity: localCategory.activity,
  targetAmount: localCategory.targetAmount,
  budgetId: `${localCategory.budgetId}`,
  historicalAverage: localCategory.historicalAverage,
  typicalSpendingPattern: localCategory.typicalSpendingPattern,
});

export const saveNewCategory = async (category: Category) => {
  connectDb();
  const localCategory = new LocalCategory({
    uuid: category.uuid,
    name: category.name,
    balance: category.balance,
    budgeted: category.budgeted,
    activity: category.activity,
    targetAmount: category.targetAmount,
    budgetId: category.budgetId,
    historicalAverage: category.historicalAverage,
    typicalSpendingPattern: category.typicalSpendingPattern,
  });
  await localCategory.save();
};

export const updateCategory = async (category: Category) => {
  connectDb();
  await LocalCategory.updateOne(
    { _id: category._id },
    {
      name: category.name,
      balance: category.balance,
      budgeted: category.budgeted,
      activity: category.activity,
      targetAmount: category.targetAmount,
      target: category.target,
    }
  ).exec();
};

export const getCategoryHistory = async (
  budgetId: string,
  $expr: any
): Promise<CategoryHistory[]> => {
  try {
    const result = await LocalCategory.aggregate([
      {
        $match: {
          budgetId,
        },
      },
      {
        $lookup: {
          from: "categoryhistories", // The collection name for CategoryHistory
          let: { categoryId: "$_id" },
          pipeline: [
            {
              $match: {
                $expr,
              },
            },
          ],
          as: "categoryInfo",
        },
      },
      {
        $unwind: {
          path: "$categoryInfo",
          preserveNullAndEmptyArrays: true, // Set to true if you want categories without history as well
        },
      },
      {
        $project: {
          categoryName: "$name",
          categoryUuid: "$uuid",
          categoryId: "$_id",
          month: "$categoryInfo.month",
          activity: "$categoryInfo.activity",
        },
      },
    ]);

    return result;
  } catch (error) {
    console.error(error);
    throw error;
  }
};

export const getCategoryHistoryForBudget = async (
  budgetId: string
): Promise<CategoryHistory[]> =>
  getCategoryHistory(budgetId, {
    $eq: ["$categoryId", "$$categoryId"],
  });

export const getCategoryHistoryForMonth = async (
  month: string,
  budgetId: string
): Promise<CategoryHistory[]> =>
  getCategoryHistory(budgetId, {
    $and: [
      { $eq: ["$categoryId", "$$categoryId"] },
      { $eq: ["$month", month] },
    ],
  });

export const saveSpendingData = async (categoryData: CategoryData[]) => {
  try {
    // bulk update category data
    // for each category save spending data
    const operations = categoryData.map((data) => {
      return {
        updateOne: {
          filter: { _id: data.categoryId },
          update: {
            $set: {
              historicalAverage: data.historicalAverage,
              typicalSpendingPattern: data.typicalSpendingPattern,
            },
          },
        },
      };
    });
    if (operations.length > 0) {
      console.log(`bulk updating ${operations.length} categories`);

      await LocalCategory.bulkWrite(operations);
    }
  } catch (error) {
    console.log("Error saving spending data", error);
    throw new Error("Error saving spending data");
  }
};

export const clearCategoryHistoryForYear = async (
  budgetId: string,
  yearString: string
) => {
  console.log(
    `deleting category history for ${yearString} and budgetId ${budgetId}`
  );
  await LocalCategoryHistory.deleteMany({
    budgetId,
    month: { $regex: `^${yearString}-` },
  }).exec();
};

export const populateCategoryHistoryFromTransactions = async (
  budgetId: string,
  transactions: Transaction[],
  year: string
) => {
  const categoryHistoryForInsert: CategoryHistoryForInsert[] = transactions
    .filter((transaction) => transaction.categoryId)
    .reduce(CategoryHistoryReducer(budgetId), []);
  console.log(
    `inserting ${categoryHistoryForInsert.length} category histories for ${year}
    and budgetId ${budgetId}`
  );
  await LocalCategoryHistory.insertMany(categoryHistoryForInsert);
};
</file>

<file path="packages/api/src/data/forecasting/es-forcasting.server.test.ts">
import { Category } from "common-ts";
import { forecastSpendingWithES } from "./es-forcasting.server";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { findTransactions } from "../transaction/transaction.server";
import {
  clearCategoryHistoryForYear,
  saveSpendingData,
  populateCategoryHistoryFromTransactions,
} from "../category/category.server";
import { updateTransactionsSpendingPattern } from "./es-forcasting.server";
import { buffer } from "stream/consumers";

const mocks = vi.hoisted(() => {
  return {
    findTransactions: vi.fn(),
  };
});
vi.mock("../transaction/transaction.server", () => ({
  findTransactions: mocks.findTransactions,
}));

describe("es-forcasting.server", () => {
  afterEach(() => {
    // restoring date after each test run
    vi.useRealTimers();
    vi.clearAllMocks();
  });
  describe("forecastSpendingWithES", () => {
    beforeEach(() => {
      // tell vitest we use mocked time
      vi.useFakeTimers();
    });

    it("should calculate the forecasted spending correctly at the beginning of the month", () => {
      // mock date with vi
      const date = new Date("2021-01-01T00:00:00Z");
      vi.setSystemTime(date);

      // Arrange
      const categories: any[] = [
        {
          _id: "1",
          name: "Category 1",
          balance: 1000,
          activity: -500000,
          budgeted: 200000,
          historicalAverage: 800000,
          typicalSpendingPattern: 0.6,
        },
        {
          id: "2",
          name: "Category 2",
          balance: 2000,
          activity: -1000000,
          budgeted: 200000,
          historicalAverage: 1200000,
          typicalSpendingPattern: 0.8,
        },
      ];
      const alpha = 0.5;

      // Act
      const result = forecastSpendingWithES(categories, alpha);

      // Assert
      expect(result.totalSpentSoFar).toBe(1500);
      expect(result.predictedSpendingEndOfMonth).toBe(737050.0000000001);
      expect(result.predictedRemainingPerDay).toBe(24518.333333333336);
      expect(result.actualRemainingPerDay).toBe(100);
      expect(result.predictedRemainingAmount).toBe(735550.0000000001);
      expect(result.remainingDays).toBe(30);
      expect(result.available).toBe(3000);
      expect(result.extraAmountNeeded).toBe(732550.0000000001);
    });
  });

  describe("updateTransactionsSpendingPattern", () => {
    vi.mock("../category/category.server", () => ({
      saveSpendingData: vi.fn().mockResolvedValue({ result: true }),
      clearCategoryHistoryForYear: vi.fn().mockResolvedValue({ result: true }),
      populateCategoryHistoryFromTransactions: vi.fn().mockResolvedValue({
        result: true,
      }),
    }));

    describe("with transactions with categories", () => {
      const mockedTransactions = [
        {
          categoryId: "1",
          amount: 1000000,
          date: "2021-01-01",
        },
        {
          categoryId: "1",
          amount: 2000000,
          date: "2021-02-01",
        },
        {
          categoryId: "2",
          amount: 3000000,
          date: "2021-01-31",
        },
        {
          categoryId: "", // empty should be filtered out
          amount: 3000000,
          date: "2021-01-31",
        },
      ];

      beforeEach(() => {
        mocks.findTransactions.mockResolvedValue(mockedTransactions);
      });

      it("should calculate the typical spending pattern for multiple months and save the spending data", async () => {
        // Arrange
        const budgetId = "123";
        const expectedCategoryData = [
          {
            categoryId: "1",
            historicalAverage: 1500000,
            typicalSpendingPattern: 0.034562211981566816,
          },
          {
            categoryId: "2",
            historicalAverage: 3000000,
            typicalSpendingPattern: 1,
          },
        ];

        // Act
        await updateTransactionsSpendingPattern(budgetId, "2021");

        // Assert
        expect(findTransactions).toHaveBeenCalledWith(budgetId, "2021");
        expect(saveSpendingData).toHaveBeenCalledWith(expectedCategoryData);
        expect(clearCategoryHistoryForYear).toHaveBeenCalledWith(
          budgetId,
          "2021"
        );
        expect(populateCategoryHistoryFromTransactions).toHaveBeenCalledWith(
          budgetId,
          mockedTransactions,
          "2021"
        );
      });
    });

    describe("with transactions with no categoryId", () => {
      beforeEach(() => {
        const mockedTransactions = [
          {
            categoryId: "", // empty should be filtered out
            amount: 3000000,
            date: "2021-01-31",
          },
        ];
        mocks.findTransactions.mockResolvedValue(mockedTransactions);
      });

      it("should not do anything if no valid categories are found", async () => {
        // Arrange
        const budgetId = "123";

        // Act
        await updateTransactionsSpendingPattern(budgetId, "2021");

        // Assert
        expect(findTransactions).toHaveBeenCalledWith(budgetId, "2021");
        expect(saveSpendingData).not.toHaveBeenCalled();
        expect(clearCategoryHistoryForYear).not.toHaveBeenCalled();
        expect(populateCategoryHistoryFromTransactions).not.toHaveBeenCalled();
      });
    });
  });
});
</file>

<file path="packages/api/src/data/forecasting/es-forcasting.server.ts">
import {
  MonthlyForcast,
  Category,
  absoluteD1000Number,
  Transaction,
} from "common-ts";
import { findTransactions } from "../transaction/transaction.server";
import { uniq } from "ramda";
import {
  clearCategoryHistoryForYear,
  populateCategoryHistoryFromTransactions,
  saveSpendingData,
} from "../category/category.server";

type SpendingPattern = {
  typicalSpendingPattern: number;
  historicalAverage: number;
};

const spent = (category: Category) => absoluteD1000Number(category.activity);

const categoryClosedWhenAbove90HistoricalAverageFilter = (
  category: Category
) => {
  return spent(category) < 0.9 * category.historicalAverage;
};

export const updateTransactionsSpendingPattern = async (
  budgetId: string,
  yearString: string // eg "2021"
) => {
  console.log(
    `updating spending pattern for ${budgetId} for year ${yearString}`
  );
  const transactions = await findTransactions(budgetId, yearString);
  const uniqCategories = uniq(
    transactions.map((transaction) => transaction.categoryId)
  ).filter((categoryId) => categoryId);
  if (!uniqCategories.length) {
    console.log("no valid categories found");
    return;
  }
  const categoryData = uniqCategories.map((categoryId) => {
    const categoryTransactions = transactions.filter(
      (transaction) => transaction.categoryId === categoryId
    );
    const categorySpendingPattern =
      calculateTypicalSpendingPatternForMultipleMonths(categoryTransactions);
    return {
      categoryId: categoryId || "",
      historicalAverage: categorySpendingPattern.historicalAverage,
      typicalSpendingPattern: categorySpendingPattern.typicalSpendingPattern,
    };
  });
  await saveSpendingData(categoryData);
  await clearCategoryHistoryForYear(budgetId, yearString);
  await populateCategoryHistoryFromTransactions(
    budgetId,
    transactions,
    yearString
  );
};

const calculateTypicalSpendingPatternForMultipleMonths = (
  transactions: Transaction[]
): SpendingPattern => {
  let totalWeightedSum = 0;
  let totalSpending = 0;
  transactions.forEach((transaction) => {
    const transactionDate = new Date(transaction.date);
    const daysInThatMonth = new Date(
      transactionDate.getFullYear(),
      transactionDate.getMonth() + 1,
      0
    ).getDate();
    const dayOfTransaction = transactionDate.getDate();
    const normalizedDateValue = dayOfTransaction / daysInThatMonth;
    totalWeightedSum += Math.abs(transaction.amount) * normalizedDateValue;

    totalSpending += Math.abs(transaction.amount);
  });
  const averageSpending = totalSpending / transactions.length;
  return {
    typicalSpendingPattern: totalWeightedSum / totalSpending,
    historicalAverage: averageSpending,
  };
};

export function forecastSpendingWithES(
  categories: Category[],
  alpha = 0.5 // Smoothing factor for Exponential Smoothing, typically between 0 and 1
): MonthlyForcast {
  const categoriesWithBudget = categories.filter(
    (category) => category.budgeted > 0
  );
  const filteredCategories = categoriesWithBudget.filter(
    categoryClosedWhenAbove90HistoricalAverageFilter
  );
  const currentDate = new Date();
  const daysInMonth = new Date(
    currentDate.getFullYear(),
    currentDate.getMonth() + 1,
    0
  ).getDate();
  const daysPassed = currentDate.getDate();

  const totalSpentSoFar = categoriesWithBudget.reduce(
    (acc, category) => acc + spent(category),
    0
  );
  const totalAvailableSoFar = categoriesWithBudget.reduce(
    (acc, category) => acc + category.balance,
    0
  );
  const totalSpentSoFarNonClosed = filteredCategories.reduce(
    (acc, category) => acc + spent(category),
    0
  );
  // console.log("days in month:" + daysInMonth);

  // Use historicalAverage from CategoryData for historical trend
  /* const historicalTrend = filteredCategories.reduce((acc, category) => {
    acc +=
      (category.historicalAverage / daysInMonth) *
      category.typicalSpendingPattern;
    return acc;
  }, 0);*/
  // console.log("historicalTrend", historicalTrend);
  // Categorical Weighting for Current Month
  /* const weightedCurrentMonthTrend = filteredCategories.reduce(
    (acc, category) => {
      acc += (spent(category) / daysPassed) * category.typicalSpendingPattern;
      return acc;
    },
    0
  );*/
  const categoryTrends = filteredCategories.map((category) => {
    return {
      category,
      weightedCurrentMonthTrend:
        (spent(category) / daysPassed) * category.typicalSpendingPattern,
      historicalTrend:
        (category.historicalAverage / daysInMonth) *
        category.typicalSpendingPattern,
    };
  });
  const weightedCurrentMonthTrend = categoryTrends.reduce(
    (acc, categoryTrend) => {
      acc += categoryTrend.weightedCurrentMonthTrend;
      return acc;
    },
    0
  );
  const historicalTrend = categoryTrends.reduce((acc, categoryTrend) => {
    acc += categoryTrend.historicalTrend;
    return acc;
  }, 0);
  // ("weightedCurrentMonthTrend", weightedCurrentMonthTrend);
  // Exponential Smoothing Forecast
  const forecastedSpending =
    alpha * weightedCurrentMonthTrend + (1 - alpha) * historicalTrend;

  const predictedSpendingEndOfMonth =
    totalSpentSoFar -
    totalSpentSoFarNonClosed +
    forecastedSpending * daysInMonth;
  const predictedRemainingPerDay =
    (predictedSpendingEndOfMonth - totalSpentSoFar) /
    (daysInMonth - daysPassed);
  const predictedRemainingAmount =
    predictedSpendingEndOfMonth - totalSpentSoFar;
  console.log("days left:" + (daysInMonth - daysPassed));
  console.log("totalAvailableSoFar:" + totalAvailableSoFar);
  return {
    totalSpentSoFar,
    predictedSpendingEndOfMonth,
    predictedRemainingPerDay,
    actualRemainingPerDay: totalAvailableSoFar / (daysInMonth - daysPassed),
    predictedRemainingAmount,
    remainingDays: daysInMonth - daysPassed,
    available: totalAvailableSoFar,
    extraAmountNeeded: predictedRemainingAmount - totalAvailableSoFar,
  };
}
// You can then use this function with the necessary data and choose a suitable alpha value
</file>

<file path="packages/api/src/data/forecasting/test.json">
[
    {
        "updateOne": {
            "filter": {
                "uuid": "156b97e6-8431-47b2-a580-76f74e391eb9"
            },
            "update": {
                "$set": {
                    "historicalAverage": 23.92542105263156,
                    "typicalSpendingPattern": 0.5243779286003765
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "cbe3bf80-852a-416d-be8c-06e8e0e9b07c"
            },
            "update": {
                "$set": {
                    "historicalAverage": 23.715324675324677,
                    "typicalSpendingPattern": 0.4588719614600775
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "5120694c-c766-4f8c-a44f-d3df2a520db1"
            },
            "update": {
                "$set": {
                    "historicalAverage": 187.83714285714288,
                    "typicalSpendingPattern": 0.6724120400420726
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "3a9df08d-5aeb-4748-bcf2-e6c7e587dae8"
            },
            "update": {
                "$set": {
                    "historicalAverage": 1105.7455555555555,
                    "typicalSpendingPattern": 0.48071922842783893
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "b297ccc0-f42b-4b31-ab8e-617630db46eb"
            },
            "update": {
                "$set": {
                    "historicalAverage": 9.792770270270264,
                    "typicalSpendingPattern": 0.4090536723806671
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "fc1b648c-39fa-4381-81dc-73920c65b62e"
            },
            "update": {
                "$set": {
                    "historicalAverage": 160.8042105263158,
                    "typicalSpendingPattern": 0.5538982697247574
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "c565f795-5bb7-4e59-92c1-3da68c03083d"
            },
            "update": {
                "$set": {
                    "historicalAverage": 25.3821568627451,
                    "typicalSpendingPattern": 0.47040945426050434
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "90bc0222-8d30-46e8-87b9-7ce2218dfbf9"
            },
            "update": {
                "$set": {
                    "historicalAverage": 31.349166666666672,
                    "typicalSpendingPattern": 0.27584033691508547
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "dbbb9c8f-cc3e-44d2-98a5-53abc31d4d05"
            },
            "update": {
                "$set": {
                    "historicalAverage": 648.1388095238096,
                    "typicalSpendingPattern": 0.20388876206610404
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "851ef288-8c1a-4e91-9f7b-34ed47977c6b"
            },
            "update": {
                "$set": {
                    "historicalAverage": 82.16090909090909,
                    "typicalSpendingPattern": 0.4636126376715172
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "cf90320f-4ec5-4096-a402-630861f6b7dc"
            },
            "update": {
                "$set": {
                    "historicalAverage": 635.265,
                    "typicalSpendingPattern": 0.5576847660475956
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "4dcc21a6-898e-4cf7-bce4-3bc9453fff03"
            },
            "update": {
                "$set": {
                    "historicalAverage": 49.25,
                    "typicalSpendingPattern": 0.6941214999181268
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "5bdee18c-395e-424e-83f7-680747283739"
            },
            "update": {
                "$set": {
                    "historicalAverage": 219.31416666666667,
                    "typicalSpendingPattern": 0.35496976409316167
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "a2202a72-81b6-40ee-ad41-f8d7e05f3bf8"
            },
            "update": {
                "$set": {
                    "historicalAverage": 7.966666666666667,
                    "typicalSpendingPattern": 0.4402343840901791
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "2d997461-a2dd-4baf-aef4-b6270c31957f"
            },
            "update": {
                "$set": {
                    "historicalAverage": 272.708125,
                    "typicalSpendingPattern": 0.7115032605122159
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "dbf713de-e41b-4d9e-adfd-b1f50fc63e6e"
            },
            "update": {
                "$set": {
                    "historicalAverage": 158,
                    "typicalSpendingPattern": 0.4838709677419355
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "6e1ea634-a696-4d18-b966-b63140e74242"
            },
            "update": {
                "$set": {
                    "historicalAverage": 40,
                    "typicalSpendingPattern": 0.2258064516129032
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "08a7525f-5ff2-4a50-9da7-5b3e1f8efad6"
            },
            "update": {
                "$set": {
                    "historicalAverage": 900,
                    "typicalSpendingPattern": 0.5115560499320232
                }
            }
        }
    },
    {
        "updateOne": {
            "filter": {
                "uuid": "5d19aa0a-cda0-42e0-a48b-404d43db863c"
            },
            "update": {
                "$set": {
                    "historicalAverage": 158.96428571428572,
                    "typicalSpendingPattern": 0.55420773824682
                }
            }
        }
    }
]
</file>

<file path="packages/api/src/data/sync/sync.server.ts">
import {
  UserType,
  findNonSyncedUsers,
  updateSyncDate,
} from "../user/user.server";
import { syncYnabUser } from "../ynab/ynab.server";

export const syncBudgetData = async (): Promise<number> => {
  const users = await findNonSyncedUsers();
  users.forEach(syncUser);
  console.log(`syncing data for ${users.length} users`);
  return users.length;
};

export const syncUser = async (user: UserType) => {
  try {
    if (user.ynab?.connection) {
      await syncYnabUser(user);
    }
    await updateSyncDate(user, new Date());
  } catch (exception) {
    console.warn("error syncing user with id:" + user.authId, exception);
  }
};
</file>

<file path="packages/api/src/data/transaction/utils.test.ts">
import { describe, expect, it } from "vitest";
import { extractPayeeName } from "./utils";

describe("extractPayeeName", () => {
  it("should extract everything before the first 'Betaling met' or a digit", () => {
    // Arrange
    const payeeName = "Some payee name Betaling met 123";

    // Act
    const result = extractPayeeName(payeeName);

    // Assert
    expect(result).toBe("Some payee name");
  });

  it("should extract everything before the first digit", () => {
    // Arrange
    const payeeName =
      "PARKING ALBERTINE 1112 BE1000 BRUXELLES Betaling met KBC-Debetkaart via Bancontact 18-07-2024 om 16.35 uur 6703 42XX XXXX X301 0 VAN DEN BROECK FILIP";

    // Act
    const result = extractPayeeName(payeeName);

    // Assert
    expect(result).toBe("PARKING ALBERTINE");
  });

  it("should extract correctly when it starts with a number", () => {
    // Arrange
    const payeeName = "8286 COGO ANTWERPEN Betaling met 123";
    // Act
    const result = extractPayeeName(payeeName);

    // Assert
    expect(result).toBe("COGO ANTWERPEN");
  });

  it("should return the original payeeName if there is no match", () => {
    // Arrange
    const payeeName = "Some payee name without any match";

    // Act
    const result = extractPayeeName(payeeName);

    // Assert
    expect(result).toBe(payeeName);
  });

  it("should return empty string if match is undefined", () => {
    // Arrange
    const payeeName = "Some payee name without any match";

    // Act and Assert
    expect(extractPayeeName(undefined)).toBe("");
    expect(extractPayeeName(null)).toBe("");
  });
});
</file>

<file path="packages/api/src/data/transaction/utils.ts">
export const extractPayeeName = (
  payeeName: string | undefined | null
): string => {
  if (!payeeName) {
    return "";
  }
  // Regex to remove leading digits and extract name before "Betaling met" or digits
  const match = payeeName.match(/^\d*\s*(.*?)(?=\s*Betaling met|\d|$)/i);

  // Return the extracted name or the entire cleaned string if no special cases found
  return match ? match[1].trim() : payeeName.trim();
};
</file>

<file path="packages/api/src/data/user/user.schema.ts">
import mongoose from "mongoose";
const { Schema, model } = mongoose;

const userSchema = new Schema({
  authId: { type: String, index: true },
  name: String,
  ynab: {
    connection: {
      accessToken: String,
      refreshToken: String,
    },
  },
  createdAt: Date,
  updatedAt: Date,
  settings: {
    preferredBudgetUuid: String,
  },
  syncDate: Date,
});

const User = mongoose.models.User || model("User", userSchema);
export default User;
</file>

<file path="packages/api/src/data/user/user.server.ts">
import User from "./user.schema";
import connectDb from "../db";
import mongoose from "mongoose";

const MAX_SYNC_USERS = 100;
const SYNC_INTERVAL_MINUTES = 0;

type YnabConnection = {
  accessToken: string;
  refreshToken: string;
};

type YnabUserData = {
  connection: YnabConnection;
};

export type UserType = {
  _id: mongoose.Schema.Types.ObjectId;
  authId: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
  syncDate?: Date;
  ynab?: YnabUserData;
  settings: {
    preferredBudgetUuid: string;
  };
};

export const createOrUpdateUser = async ({
  authId,
  name,
}: {
  authId: string;
  name: string;
}) => {
  console.log("createOrUpdateUser with id:" + authId + " and name:" + name);
  await connectDb();
  const user = await getUserByAuthId(authId);
  if (user) {
    user.updatedAt = new Date();
    user.name = name;
    return user;
  }
  const newUser = new User({
    authId,
    createdAt: new Date(),
    updatedAt: new Date(),
  });
  await newUser.save();
  return newUser;
};

export const updateUserServerKnowledge = async ({
  user,
  budgetUuid,
  systemType,
  type,
  knowledge,
}: {
  user: UserType;
  budgetUuid: string;
  systemType: "ynab";
  type: "transactions" | "categories";
  knowledge: number;
}) => {
  await connectDb();
  const key = `${systemType}.serverKnowledge.${budgetUuid}.${type}`;
  console.log("update knownloedge:" + `${key}` + ",with: " + knowledge);
  await User.updateOne({ _id: user._id }, { [key]: knowledge });
};

export const connectUserWithYnab = async (
  connection: YnabConnection,
  user: UserType
) => {
  await connectDb();
  console.log(`connecting user with ynab: ${JSON.stringify(user.authId)}`);
  const authId = user?.authId;
  if (!authId) {
    throw new Error("User not set");
  }
  if (!connection.accessToken || !connection.refreshToken) {
    throw new Error("Connection data not set");
  }
  await User.updateOne(
    { authId },
    { ynab: { connection }, updatedAt: new Date() }
  );
};

export const getUserByAuthId = async (
  authId: string
): Promise<UserType | null | undefined> => {
  await connectDb();
  return User.findOne({ authId });
};

export const savePreferredBudget = async (
  budgetUuid: string,
  authId: string
) => {
  await connectDb();
  console.log(`saving preferred budget ${budgetUuid} for ${authId}`);
  if (!authId) {
    return;
  }
  const user = await getUserByAuthId(authId);
  if (!user) {
    throw new Error("User not found");
  }
  await User.updateOne(
    { authId },
    { "settings.preferredBudgetUuid": budgetUuid }
  );
};

export const getLoggedInUserPreferredBudgetId = async (authId: string) => {
  const user = await getLoggedInUser(authId);
  if (!user) {
    return;
  }
  return user?.settings?.preferredBudgetUuid || "";
};

export const getLoggedInUser = async (authId: string) => {
  await connectDb();
  const user = await getUserByAuthId(authId);
  if (!user) {
    return;
  }
  return user;
};

const xMinutesAgo = () => {
  const date = new Date();
  date.setMinutes(date.getMinutes() - SYNC_INTERVAL_MINUTES);
  return date;
};

export const findNonSyncedUsers = async (): Promise<UserType[]> => {
  connectDb();
  // find last MAX_SYNC_USERS users with no sync date or sync date older than 5 minutes
  return User.find({
    $or: [
      { syncDate: { $exists: false } },
      { syncDate: { $lt: xMinutesAgo() } },
    ],
  })
    .sort({ updatedAt: -1 })
    .limit(MAX_SYNC_USERS);
};

export const updateSyncDate = async (user: UserType, date: Date) => {
  connectDb();
  User.updateOne({ _id: user._id }, { syncDate: date }).exec();
};

export const clearYnabConnection = async (user: UserType) => {
  connectDb();
  await User.updateOne({ _id: user._id }, { ynab: undefined });
};
</file>

<file path="packages/api/src/data/utils/category-usage.reducer.ts">
import { Category, Transaction } from "common-ts";

export const categoryUsageReducer =
  (categoriesFromDb: Category[]) =>
  (categories: Category[], transaction: Transaction) => {
    const categoryFromDb = categoriesFromDb.find(
      (category: Category) => `${category._id}` === `${transaction.categoryId}`
    );
    if (!categoryFromDb) {
      return categories;
    }
    const categoryUsage = categories.find(
      (usage: Category) => `${usage._id}` === `${transaction.categoryId}`
    );
    if (categoryUsage) {
      categoryUsage.activity += transaction.amount;
    } else {
      categories.push({
        ...categoryFromDb,
        activity: transaction.amount,
      });
    }
    return categories;
  };
</file>

<file path="packages/api/src/data/utils/category.history.reducer.test.ts">
import { Transaction } from "common-ts";
import { CategoryHistoryForInsert } from "../category/category.server";
import { CategoryHistoryReducer } from "./category.history.reducer";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";

describe("CategoryHistoryReducer", () => {
  const budgetId = "1";
  const historyReducer = CategoryHistoryReducer(budgetId);

  it("should update existing category history if it exists", () => {
    // Arrange
    const categoryHistories: Array<CategoryHistoryForInsert> = [
      {
        categoryId: "1",
        month: "2021-01",
        activity: -500,
        budgetId,
      },
      {
        categoryId: "2",
        month: "2021-01",
        activity: -300,
        budgetId,
      },
    ];
    const transaction: any = {
      categoryId: "1",
      date: "2021-01-15",
      amount: -200,
    };

    // Act
    const result = historyReducer(categoryHistories, transaction);

    // Assert
    expect(result).toEqual([
      {
        categoryId: "1",
        month: "2021-01",
        activity: -700,
        budgetId,
      },
      {
        categoryId: "2",
        month: "2021-01",
        activity: -300,
        budgetId,
      },
    ]);
  });

  it("should add new category history if it doesn't exist", () => {
    // Arrange
    const categoryHistories: Array<CategoryHistoryForInsert> = [
      {
        categoryId: "1",
        month: "2021-01",
        activity: -500,
        budgetId,
      },
    ];
    const transaction: any = {
      categoryId: "2",
      date: "2021-01-15",
      amount: -200,
    };

    // Act
    const result = historyReducer(categoryHistories, transaction);

    // Assert
    expect(result).toEqual([
      {
        categoryId: "1",
        month: "2021-01",
        activity: -500,
        budgetId,
      },
      {
        categoryId: "2",
        month: "2021-01",
        activity: -200,
        budgetId,
      },
    ]);
  });
});
</file>

<file path="packages/api/src/data/utils/category.history.reducer.ts">
import { Transaction } from "common-ts";
import { CategoryHistoryForInsert } from "../category/category.server";

export const CategoryHistoryReducer =
  (budgetId: string) =>
  (
    categoryHistories: Array<CategoryHistoryForInsert>,
    transaction: Transaction
  ) => {
    const categoryId = `${transaction.categoryId}` || "";
    const month = transaction.date.substring(0, 7);
    const startDateOfMonth = new Date(`${month}-01`);
    const categoryHistory = categoryHistories.find(
      (categoryHistory: CategoryHistoryForInsert) =>
        `${categoryHistory.categoryId}` === categoryId &&
        categoryHistory.month === month
    );
    if (categoryHistory) {
      categoryHistory.activity += transaction.amount;
    } else {
      categoryHistories.push({
        categoryId,
        month,
        budgetId,
        activity: transaction.amount,
      });
    }
    return categoryHistories;
  };
</file>

<file path="packages/api/src/data/utils/month.summary.reducer.ts">
import { MonthSummary, Transaction } from "common-ts";
import { CategoryHistory } from "../category/category.server";

export const monthSummaryFromCategoryHistoryReducer = (
  monthSummaries: Array<MonthSummary>,
  categoryHistory: CategoryHistory
) => {
  const month = categoryHistory.month;
  const currentMonth = new Date().toISOString().substring(0, 7);
  const monthSummary = monthSummaries.find(
    (summary: MonthSummary) => summary.month === month
  );
  if (monthSummary) {
    monthSummary.categoryUsages.push({
      name: categoryHistory.categoryName,
      uuid: categoryHistory.categoryUuid,
      amount: categoryHistory.activity,
    });
  } else {
    monthSummaries.push({
      month,
      isCurrentMonth: month === currentMonth,
      categoryUsages: [
        {
          name: categoryHistory.categoryName,
          uuid: categoryHistory.categoryUuid,
          amount: categoryHistory.activity,
        },
      ],
    });
  }
  return monthSummaries;
};
</file>

<file path="packages/api/src/data/ynab/transaction.util.test.ts">
import { TransactionDetail } from "ynab";
import { extractYearsFromTransactions } from "./transaction.util";
import { describe, expect, it } from "vitest";

describe("extractYearsFromTransactions", () => {
  it("should return a sorted array of unique years extracted from transactions", () => {
    const transactions = [
      { date: "2023-06-20", amount: 150 },
      { date: "2021-01-01", amount: 100 },
      { date: "2021-02-15", amount: -50 },
      { date: "2022-03-10", amount: 200 },
      { date: "2022-04-05", amount: -75 },
    ];

    const result = extractYearsFromTransactions(transactions as any);

    expect(result).toEqual(["2021", "2022", "2023"]);
  });

  it("should return an empty array if no transactions are provided", () => {
    const transactions: TransactionDetail[] = [];

    const result = extractYearsFromTransactions(transactions);

    expect(result).toEqual([]);
  });

  it("should handle transactions with invalid date format", () => {
    const transactions = [
      { date: "2021-01-01", amount: 100 },
      { date: "2021-02-15", amount: -50 },
      { date: "2022-03", amount: 200 }, // Invalid date format
      { date: "2022-04-05", amount: -75 },
    ];

    const result = extractYearsFromTransactions(transactions as any);

    expect(result).toEqual(["2021", "2022"]);
  });
});
</file>

<file path="packages/api/src/data/ynab/transaction.util.ts">
import { uniq } from "ramda";
import { TransactionDetail } from "ynab";

/**
 *
 * @param transactions
 * @returns a sorted array of unique years extracted from transactions
 */
export const extractYearsFromTransactions = (
  transactions: TransactionDetail[]
): string[] =>
  uniq(
    transactions.map((transaction) => transaction.date.substring(0, 4))
  ).sort();
</file>

<file path="packages/api/src/data/ynab/ynab.schema.ts">
import mongoose from "mongoose";
const { Schema, model } = mongoose;

const ynabBudgetSchema = new Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
  },
  budgetId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Budget",
  },
  serverKnowledge: {
    transactions: Number,
    categories: Number,
    accounts: Number,
  },
});

const YnabBudget =
  mongoose.models.YnabBudget || model("YnabBudget", ynabBudgetSchema);
export default YnabBudget;
</file>

<file path="packages/api/src/data/ai.server.ts">
import OpenAI from "openai";
import { MonthSummary } from "common-ts";

export type AIFinancialAnalysis = {
  response: string;
};

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const filterLastXMonths = (monthSummary: Array<MonthSummary>, x = 4) => {
  return monthSummary.slice(-x);
};

const stripTransactionsOnAllLevels = (monthSummary: Array<MonthSummary>) => {
  return monthSummary.map((month) => {
    return {
      month: month.month,
      isCurrentMonth: month.isCurrentMonth,
      categoryUsage: month.categoryUsages.map((categoryUsage) => {
        return {
          category: categoryUsage.name,
          categoryId: categoryUsage.uuid,
          amount: categoryUsage.amount,
        };
      }),
    };
  });
};

export async function getAIAnalysis(
  monthSummary: Array<MonthSummary>
): Promise<AIFinancialAnalysis> {
  const response = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      { role: "system", content: "You are a financial adviser" },
      {
        role: "system",
        content: "The amounts are in euros and need to be diveded by 1000",
      },
      {
        role: "user",
        content: `This is the financial data of the last months ${JSON.stringify(
          stripTransactionsOnAllLevels(filterLastXMonths(monthSummary))
        )}`,
      },
      {
        role: "user",
        content: "What ",
      },
    ],
  });
  return {
    response: response.choices[0].message.content || "",
  };
}
</file>

<file path="packages/api/src/data/db.ts">
import mongoose from "mongoose";

async function connectDb() {
  if (mongoose.connection.readyState >= 1) {
    return;
  }
  console.log("connectDb");
  return mongoose.connect(process.env.MONGODB_URI || "");
}

export default connectDb;
</file>

<file path="packages/api/src/data/main.budget.server.test.ts">
import { describe, it, expect, vi, afterEach } from "vitest";
import { getBudgetOverviewForUser } from "./main.budget.server";
import { MonthSummary } from "common-ts";

const mocks = vi.hoisted(() => {
  return {
    findCategories: vi.fn(),
    getCategoryHistory: vi.fn(),
    forecastSpendingWithES: vi.fn(),
  };
});

const categoryHistoryMockData = [
  {
    categoryUuid: "1",
    categoryName: "Category 1",
    activity: -500,
    month: "2021-01",
  },
  {
    categoryUuid: "2",
    categoryName: "Category 2",
    activity: -1000,
    month: "2021-01",
  },
  {
    categoryUuid: "1",
    categoryName: "Category 1",
    activity: -1000,
    month: "2021-02",
  },
  {
    categoryUuid: "2",
    categoryName: "Category 2",
    activity: -2000,
    month: "2021-02",
  },
];

const categoryData = [
  {
    _id: "1",
    name: "Category 1",
    balance: 1000,
    activity: -500,
    budgeted: 200,
  },
  {
    _id: "2",
    name: "Category 2",
    balance: 2000,
    activity: -1000,
    budgeted: 300,
  },
];

const esData = {
  totalSpentSoFar: 100,
  predictedSpendingEndOfMonth: 150,
  predictedRemainingPerDay: 50,
  actualRemainingPerDay: 50,
  predictedRemainingAmount: 100,
  remainingDays: 2,
  available: 200,
  extraAmountNeeded: 100,
};

describe("main budget server tests", () => {
  afterEach(() => {
    vi.restoreAllMocks();
    vi.useRealTimers();
  });
  // todo cleanup and use constants instead of duplicated values
  describe("getBudgetOverviewForUser", () => {
    it("should return the budget overview for the user", async () => {
      // end of month so month percentage should be 100
      const date = new Date("2021-01-31T00:00:00Z");
      vi.setSystemTime(date);

      // Arrange
      const budgetId = "1";
      const monthPercentage = 100;
      const monthSummaries: MonthSummary[] = [
        {
          month: "2021-02",
          isCurrentMonth: false,
          categoryUsages: [
            {
              uuid: "1",
              name: "Category 1",
              amount: -1000,
            },
            {
              uuid: "2",
              name: "Category 2",
              amount: -2000,
            },
          ],
        },
        {
          month: "2021-01",
          isCurrentMonth: true,
          categoryUsages: [
            {
              uuid: "1",
              name: "Category 1",
              amount: -500,
            },
            {
              uuid: "2",
              name: "Category 2",
              amount: -1000,
            },
          ],
        },
      ];
      const monthTotal = {
        totalSpent: -1500,
        totalBudgeted: 500,
        totalBalance: 3000,
      };

      vi.mock("./forecasting/es-forcasting.server", () => ({
        forecastSpendingWithES: mocks.forecastSpendingWithES,
      }));
      vi.mock("./category/category.server", () => ({
        getCategoryHistoryForBudget: mocks.getCategoryHistory,
        findCategories: mocks.findCategories,
      }));
      mocks.findCategories.mockResolvedValue(categoryData);
      mocks.forecastSpendingWithES.mockReturnValue(esData);
      mocks.getCategoryHistory.mockResolvedValue(categoryHistoryMockData);

      // Act
      const result = await getBudgetOverviewForUser(budgetId);

      // Assert
      expect(result.monthPercentage).toBe(monthPercentage);
      expect(result.monthSummaries).toStrictEqual(monthSummaries);
      expect(result.categories).toBe(categoryData);
      expect(result.monthTotal).toStrictEqual(monthTotal);
      expect(result.forecast).toBe(esData);
    });
  });
});
</file>

<file path="packages/api/src/data/main.budget.server.ts">
import moment from "moment";
import { findTransactions } from "./transaction/transaction.server";
import { monthSummaryFromCategoryHistoryReducer } from "./utils/month.summary.reducer";
import {
  Transaction,
  withoutInflowCategoryFilter,
  Category,
  MonthSummary,
  MonthTotal,
  BudgetOverview,
} from "common-ts";
import {
  findCategories,
  getCategoryHistoryForBudget,
} from "./category/category.server";
import { forecastSpendingWithES } from "./forecasting/es-forcasting.server";
import { cp } from "fs";

export const getBudgetOverviewForUser = async (
  budgetId: string
): Promise<BudgetOverview> => {
  const monthPercentage = calculateCurrentMontPercentage();
  const monthSummaries = await getMonthSummaries(budgetId);
  const categories = await findCategories(budgetId);
  const monthTotal = calculateTotals(categories);
  const forecast = forecastSpendingWithES(categories);

  return {
    monthPercentage,
    monthSummaries,
    categories,
    monthTotal,
    forecast,
  };
};

export const calculateCurrentMontPercentage = () => {
  const now = moment();
  const daysInMonth = now.daysInMonth();
  const currentDay = now.date();
  return (currentDay / daysInMonth) * 100;
};

export const calculateTotals = (categories: Array<Category>): MonthTotal => {
  return categories.filter(withoutInflowCategoryFilter).reduce(
    (acc: MonthTotal, category: Category) => {
      if (category.activity < 0) {
        acc.totalSpent += category.activity;
      }
      acc.totalBudgeted += category.budgeted;
      acc.totalBalance += category.balance;
      return acc;
    },
    {
      totalSpent: 0,
      totalBudgeted: 0,
      totalBalance: 0,
    }
  );
};

export const getFilteredTransactions = async (
  budgetId: string,
  month: string | null | undefined,
  dayOfMonth: string | null | undefined
): Promise<Array<Transaction>> => {
  console.log("getFilteredTransactionsInternal", budgetId, month, dayOfMonth);
  const transactions = await findTransactions(budgetId, month || "");
  const filteredTransactions = transactions.filter((transaction) => {
    const transactionDayOfMonth = transaction.date.substring(8, 10);
    return !dayOfMonth || Number(transactionDayOfMonth) === Number(dayOfMonth);
  });
  return filteredTransactions;
};

export async function getMonthSummaries(
  budgetId: string
): Promise<Array<MonthSummary>> {
  const categoryHistoryRecords = await getCategoryHistoryForBudget(budgetId);

  return categoryHistoryRecords
    .reduce(monthSummaryFromCategoryHistoryReducer, [])
    .sort((a, b) => {
      return a.month > b.month ? -1 : 1;
    });
}
</file>

<file path="packages/api/src/routes/syncRoutes.ts">
import { Router } from "express";
import { handleSyncBudgetData } from "../controllers/syncController";
import { handleRequest } from "../controllers/utils";

const router = Router();

router.post("/", handleRequest(handleSyncBudgetData));

export default router;
</file>

<file path="packages/api/src/routes/userRoutes.ts">
import { Router } from "express";
import {
  handleConnectUserWithYnab,
  handleCreateOrUpdateUser,
  handleGetLoggedInUser,
  handleSavePreferredBudget,
} from "../controllers/userController";
import { handleRequest } from "../controllers/utils";

const router = Router();

router.get("/logged-in", handleRequest(handleGetLoggedInUser));
router.put("/", handleRequest(handleCreateOrUpdateUser));
router.put("/connect-ynab", handleRequest(handleConnectUserWithYnab));

// users/preferred-budget
router.put("/preferred-budget", handleRequest(handleSavePreferredBudget));

export default router;
</file>

<file path="packages/api/src/instrument.ts">
// Import with `import * as Sentry from "@sentry/node"` if you are using ESM
const Sentry = require("@sentry/node");
const { nodeProfilingIntegration } = require("@sentry/profiling-node");

Sentry.init({
  dsn: "https://5a527830c3bb2077adf47e8b218fdc4c@o4508281706577920.ingest.de.sentry.io/4508281811566672",
  integrations: [nodeProfilingIntegration()],
  // Tracing
  tracesSampleRate: 1.0, //  Capture 100% of the transactions
});
// Manually call startProfiler and stopProfiler
// to profile the code in between
Sentry.profiler.startProfiler();
// this code will be profiled

// Calls to stopProfiling are optional - if you don't stop the profiler, it will keep profiling
// your application until the process exits or stopProfiling is called.
Sentry.profiler.stopProfiler();
</file>

<file path="packages/api/src/metrics.ts">
import client from "prom-client";

// Create a Registry which registers the metrics
const register = new client.Registry();

// Add a default metrics collection to the registry
client.collectDefaultMetrics({ register });

// Export the registry
export default register;
</file>

<file path="packages/api/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ES6",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,

    "paths": {
      "common-ts": ["../../common-ts/dist"]
    },

    "sourceMap": true,
    "inlineSources": true,

    // Set `sourceRoot` to  "/" to strip the build path prefix
    // from generated source code references.
    // This improves issue grouping in Sentry.
    "sourceRoot": "/"
  },
  "include": ["src"],
  "exclude": ["**/*.spec.ts", "**/*.test.ts", "**/*.mocks.ts", "node_modules"]
}
</file>

<file path="packages/api/vitest.config.ts">
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    // ...
  },
});
</file>

<file path="packages/common-ts/src/amounts/amounts.test.ts">
import { describe, expect, it } from "vitest";
import { formatBasicAmount } from ".";

describe("formatBasicAmount", () => {
  const UNEXPECTED = "?.??";
  it("should format amount", () => {
    expect(formatBasicAmount(100)).toEqual("100.00");
  });

  it("should format amount with absolute", () => {
    expect(formatBasicAmount(-100, true)).toEqual("100.00");
  });

  it("should format amount with 0", () => {
    expect(formatBasicAmount(0)).toEqual("0.00");
  });

  it("should format undefined amount with ?.??", () => {
    expect(formatBasicAmount(undefined)).toEqual(UNEXPECTED);
  });

  it("should format null amount with ?.??", () => {
    expect(formatBasicAmount(null)).toEqual(UNEXPECTED);
  });
});
</file>

<file path="packages/common-ts/src/amounts/index.ts">
import { isNil } from "ramda";

import { MonthTotal } from "../budget";
import { Category } from "../category/category.utils";

export const formatBasicAmount = (
  amount: number | null | undefined,
  absolute: boolean = false
) => {
  if (isNil(amount)) {
    return "?.??";
  }
  const number = absolute ? Math.abs(amount) : amount;
  return number.toFixed(2) + "";
};
export const formatAmount = (amount: number, absolute: boolean = false) =>
  formatBasicAmount(amount / 1000, absolute);

export const numberD1000 = (amount: number) => {
  return amount / 1000;
};

export const absoluteD1000Number = (amount: number) => {
  return Math.abs(numberD1000(amount));
};

export const percentageSpent = (category: Category) => {
  const absAmount = absoluteD1000Number(category.activity);
  const absBudget = absoluteD1000Number(category.budgeted);
  if (absBudget === 0) {
    return 100;
  }
  return calculatePercentage(absAmount, absBudget);
};

export const calculatePercentage = (amount: number, total: number) =>
  (amount / total) * 100;

export const formatPercentage = (percentage: number) =>
  percentage.toFixed(2) + "%";

export const totalPercentageSpent = (total: MonthTotal) => {
  const absAmount = absoluteD1000Number(total.totalSpent);
  const absBudget = absoluteD1000Number(total.totalBudgeted);
  if (absBudget === 0) {
    return 100;
  }
  return calculatePercentage(absAmount, absBudget);
};
</file>

<file path="packages/common-ts/src/budget/budget.utils.ts">
export type Budget = {
  _id: string;
  uuid: string;
  name: string;
};

export type NewBudget = {
  uuid: string;
  name: string;
};
</file>

<file path="packages/common-ts/src/budget/index.ts">
export * from "./budget.utils";
export * from "../main.budget.utils";
</file>

<file path="packages/common-ts/src/category/category.utils.ts">
import { Transaction } from "../transaction/transaction.utils";

export type CategoryTarget = {
  /**
   * The type of goal, if the category has a goal (TB='Target Category Balance', TBD='Target Category Balance by Date', MF='Monthly Funding', NEED='Plan Your Spending')
   */
  goal_type?: "TB" | "TBD" | "MF" | "NEED" | "DEBT" | null;

  /**
   * A day offset modifier for the goal's due date.
   * When goal_cadence is 2 (Weekly), this value specifies which day of the week the goal is due (0 = Sunday, 6 = Saturday).
   * Otherwise, this value specifies which day of the month the goal is due (1 = 1st, 31 = 31st, null = Last day of Month).
   */
  goal_day?: number | null;

  /**
   * The goal cadence. Value in range 0-14.
   */
  goal_cadence?: number | null;

  /**
   * The goal cadence frequency.
   */
  goal_cadence_frequency?: number | null;

  /**
   * The month a goal was created, formatted as 'YYYY-MM'.
   */
  goal_creation_month?: string | null;

  /**
   * The goal target amount in milliunits.
   */
  goal_target?: number | null;

  /**
   * The original target month for the goal to be completed.
   */
  goal_target_month?: string | null;

  /**
   * The percentage completion of the goal.
   */
  goal_percentage_complete?: number | null;

  /**
   * The number of months, including the current month, left in the current goal period.
   */
  goal_months_to_budget?: number | null;

  /**
   * The amount of funding still needed in the current month to stay on track towards completing the goal within the current goal period.
   */
  goal_under_funded?: number | null;

  /**
   * The total amount funded towards the goal within the current goal period.
   */
  goal_overall_funded?: number | null;

  /**
   * The amount of funding still needed to complete the goal within the current goal period.
   */
  goal_overall_left?: number | null;
};

export type Category = {
  _id?: string;
  name: string;
  uuid: string;
  balance: number;
  budgeted: number;
  activity: number;
  targetAmount: number;
  budgetId: string;
  typicalSpendingPattern: number;
  historicalAverage: number;
  target?: CategoryTarget | null;
};

export const emptyCategory: Category = {
  _id: "",
  name: "",
  uuid: "",
  balance: 0,
  budgeted: 0,
  activity: 0,
  targetAmount: 0,
  budgetId: "",
  typicalSpendingPattern: 0,
  historicalAverage: 0,
};

export type CategoryUsage = {
  name: string;
  uuid: string | undefined | null;
  amount: number;
};

export const isInflowCategory = (category: Category) => {
  return category.name.startsWith("Inflow");
};

export const categorySorter = (a: Category, b: Category): number =>
  a.name.localeCompare(b.name);

export const withoutInflowCategoryFilter = (category: Category) =>
  !isInflowCategory(category);
</file>

<file path="packages/common-ts/src/category/index.ts">
export * from "./category.utils";
</file>

<file path="packages/common-ts/src/forecasting/index.ts">
export type CategoryData = {
  categoryId: string;
  typicalSpendingPattern: number; // A weight from 0 (start of month) to 1 (end of month)
  historicalAverage: number;
};

export type TransactionData = {
  date: Date;
  amount: number;
  categoryId: string;
  categoryName: string;
};

export type MonthlySpending = {
  month: Date;
  amount: number;
};

export type MonthlyForcast = {
  totalSpentSoFar: number;
  predictedSpendingEndOfMonth: number;
  predictedRemainingPerDay: number;
  actualRemainingPerDay: number;
  predictedRemainingAmount: number;
  remainingDays: number;
  available: number;
  extraAmountNeeded: number;
};
</file>

<file path="packages/common-ts/src/logging/index.ts">
let isConsoleLogOverridden = false;

export const overrideConsoleLog = (): void => {
  if (isConsoleLogOverridden) {
    return;
  }
  const originalLog = console.log;

  console.log = (...args: any[]): void => {
    const timestamp = new Date().toISOString();
    originalLog.apply(console, [timestamp, ...args]);
  };
  isConsoleLogOverridden = true;
};
</file>

<file path="packages/common-ts/src/transaction/index.ts">
export * from "./transaction.utils";
</file>

<file path="packages/common-ts/src/user/index.ts">
export type UserView = {
  authId: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
  settings: {
    preferredBudgetUuid: string;
  };
  ynab: {
    isConnected: boolean;
    isTokenExpired: boolean;
  };
};
</file>

<file path="packages/common-ts/src/main.budget.utils.ts">
import { Category, CategoryUsage } from "./category";
import { MonthlyForcast } from "./forecasting";
import { Transaction } from "./transaction/transaction.utils";

export type MonthTotal = {
  totalSpent: number;
  totalBudgeted: number;
  totalBalance: number;
};

export type MonthSummary = {
  month: string;
  isCurrentMonth: boolean;
  categoryUsages: Array<CategoryUsage>;
};

export type YnabConnection = {
  accessToken: string;
  refreshToken: string;
};

export type YnabUserData = {
  connection: YnabConnection;
};

/** budget overview containing:
 *  monthPercentage,
    monthSummaries,
    categories,
    monthTotal,
    forecast
    */
export type BudgetOverview = {
  monthPercentage: number;
  monthSummaries: Array<MonthSummary>;
  categories: Array<Category>;
  monthTotal: MonthTotal;
  forecast: MonthlyForcast;
};
</file>

<file path="packages/common-ts/rollup.config.js">
import typescript from 'rollup-plugin-typescript2';

export default {
    input: ["src/index.ts"],
    output: [
        {
            dir: "dist",
            entryFileNames: "[name].js",
            format: "cjs",
            exports: "named"
        }
    ],
    plugins: [
        typescript(),
    ],
    external: ["react"]
};
</file>

<file path="packages/common-ts/tsconfig.json">
{
  "compilerOptions": {
    "jsx": "react",
    "allowJs": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "outDir": "./dist",
    "declaration": true,
    "rootDir": "./src"
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.lib.json"
    },
    {
      "path": "./tsconfig.spec.json"
    }
  ]
}
</file>

<file path="packages/common-ts/tsconfig.lib.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "types": ["node"]
  },
  "exclude": ["**/*.spec.ts", "**/*.test.ts", "**/*.mocks.ts", "node_modules"],
  "include": ["**/*.js", "**/*.jsx", "**/*.ts", "**/*.tsx"]
}
</file>

<file path="packages/common-ts/tsconfig.spec.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "module": "commonjs",
    "types": [
      "jest",
      "node"
    ]
  },
  "include": [
    "**/*.spec.ts",
    "**/*.spec.tsx",
    "**/*.spec.js",
    "**/*.spec.jsx",
    "**/*.d.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="packages/common-ts/vitest.config.ts">
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    // ...
  },
});
</file>

<file path="packages/mathapi/app/templates/balance_projection.html">
<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  </head>
  <body>
    <div id="balance-chart"></div>
    <script>
      // Pass the JSON data directly
      var data = {{ plot_data | safe }};

      // Render the Plotly chart
      Plotly.newPlot('balance-chart', data);
    </script>
  </body>
</html>
</file>

<file path="packages/web/__tests__/app/api/budget.server.test.ts">
import { describe, expect, it } from "vitest";

describe("budget server tests", () => {
  it("should have a dummy test", () => {
    expect(1).toEqual(1);
  });
});
</file>

<file path="packages/web/__tests__/app/utils/functional.test.ts">
import { expect, test } from "vitest";
import { pipeP, composeP } from "../../../app/utils/functional";

test("pipeP executes async functions in sequence", async () => {
  const addOne = (x: number) => Promise.resolve(x + 1);
  const double = (x: number) => Promise.resolve(x * 2);
  const square = (x: number) => Promise.resolve(x * x);

  const result = await pipeP(addOne, double, square)(1);

  expect(result).toBe(16);
});

test("composeP executes async functions in reverse sequence", async () => {
  const addOne = (x: number) => Promise.resolve(x + 1);
  const double = (x: number) => Promise.resolve(x * 2);
  const square = (x: number) => Promise.resolve(x * x);

  const result = await composeP(addOne, double, square)(1);

  expect(result).toBe(3);
});
</file>

<file path="packages/web/app/api/auth/[...nextauth]/route.ts">
import NextAuth from "next-auth";
import { ynabAuthOptions } from "../../ynab/auth";

const handler = NextAuth(ynabAuthOptions);

export { handler as GET, handler as POST };
</file>

<file path="packages/web/app/api/budget/budget.client.ts">
import { getSession } from "@auth0/nextjs-auth0";
import { Budget, BudgetOverview } from "common-ts";
import { cache } from "react";
import { apiGet } from "../client";

export const findBudgetsInternal = async (): Promise<Budget[]> =>
  apiGet("budgets");

const getBudgetInternal = async (uuid: string): Promise<Budget> =>
  apiGet(`budgets/${uuid}`);

export const getBudget = cache(getBudgetInternal);

export const findBudgets = cache(findBudgetsInternal);

export const getBudgetOverviewForUser = async (
  uuid: string
): Promise<BudgetOverview> => {
  return apiGet(`budgets/${uuid}/overview`);
};
</file>

<file path="packages/web/app/api/defauth/[auth0]/route.ts">
import {
  handleAuth,
  handleCallback,
  Session,
  AfterCallbackAppRoute,
} from "@auth0/nextjs-auth0";
import { createOrUpdateUser } from "../../user/user.client";
import { NextRequest } from "next/server";

const afterCallback: AfterCallbackAppRoute = async (
  req: NextRequest,
  session: Session
) => {
  if (session.user) {
    await createOrUpdateUser({
      authId: session.user.sub,
      name: session.user.name,
      accessToken: session.accessToken,
    });
  }
  return session;
};

export const GET = handleAuth({
  callback: handleCallback(() => {
    return {
      afterCallback,
    };
  }),
});
</file>

<file path="packages/web/app/api/metrics/route.ts">
import { NextRequest, NextResponse } from "next/server";
import register from "../../lib/metrics";

export async function GET(req: NextRequest) {
  const metrics = await register.metrics();
  return new NextResponse(metrics, {
    headers: {
      "Content-Type": register.contentType,
    },
  });
}
</file>

<file path="packages/web/app/api/sentry-example-api/route.ts">
import { NextResponse } from "next/server";

export const dynamic = "force-dynamic";

// A faulty API route to test Sentry's error monitoring
export function GET() {
  throw new Error("Sentry Example API Route Error");
  return NextResponse.json({ data: "Testing Sentry Error..." });
}
</file>

<file path="packages/web/app/api/sync/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { syncBudgetData } from "./sync.client";

const containsSecret = (request: NextRequest) => {
  const secret = process.env.SYNC_SECRET;
  const requestSecret = request.headers.get("x-sync-secret");
  return secret === requestSecret;
};
export async function POST(request: NextRequest) {
  if (!containsSecret(request)) {
    return NextResponse.json(
      {
        message: "Unauthorized",
      },
      {
        status: 401,
      }
    );
  }
  const nbrOfSyncedUsers = await syncBudgetData();
  return NextResponse.json({
    status: 201,
    body: {
      nbrOfSyncedUsers,
    },
  });
}
</file>

<file path="packages/web/app/api/sync/sync.client.ts">
import "server-only";
export const syncBudgetData = async (): Promise<number> => {
  const apiBaseUrl = process.env.API_URL || "http://localhost:4000";
  const apiUrl = `${apiBaseUrl}/sync`;
  const headers: any = {
    "x-sync-secret": process.env.SYNC_SECRET,
    "Content-Type": "application/json",
  };
  const response = await fetch(apiUrl, {
    method: "POST",
    headers,
  });
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const data = await response.json();
  return data.nbrOfSyncedUsers;
};
</file>

<file path="packages/web/app/api/user/user.client.ts">
import { YnabConnection } from "common-ts";
import { apiFetch, apiPut, apiGet } from "../client";
import { UserView } from "common-ts";
import { cache } from "react";
import { get } from "http";

export const connectUserWithYnab = async (data: YnabConnection) => {
  console.log(`connecting user with ynab in client: ${JSON.stringify(data)}`);
  await apiPut("users/connect-ynab", data);
};

export const createOrUpdateUser = async ({
  authId,
  name,
  accessToken,
}: {
  authId: string;
  name: string;
  accessToken?: string;
}) => {
  console.log(
    "createOrUpdateUser with id:" + authId + " and name:" + name + ", token?"
  );
  return await apiPut("users", { authId, name }, accessToken);
};

const getLoggedInUserInternal = async (): Promise<UserView> => {
  return await apiGet("users/logged-in");
};

const getLoggedInUser = cache(getLoggedInUserInternal);

export const getLoggedInUserPreferredBudgetId = async (): Promise<string> => {
  const user = await getLoggedInUser();
  return user.settings.preferredBudgetUuid;
};

export const isYnabTokenExpired = async (): Promise<boolean> => {
  const user = await getLoggedInUser();
  return !user.ynab.isConnected || user.ynab.isTokenExpired;
};

export const savePreferredBudget = async (budgetUuid: string) => {
  console.log(`saving preferred budget ${budgetUuid}`);
  return await apiPut("users/preferred-budget", { budgetUuid });
};
</file>

<file path="packages/web/app/components/budget-page/category-card.tsx">
"use client";
import Link from "next/link";
import Progress from "../progress";
import {
  Category,
  calculatePercentage,
  formatAmount,
  formatPercentage,
  MonthTotal,
  percentageSpent,
  isInflowCategory
} from "common-ts";
import { percentageToStatusClass } from "../../utils";

interface StatusIndicatorProps {
  category: Category;
  budgetUuid: string;
  currentMonthLbl: string;
  monthTotal: MonthTotal;
}

import { useState } from "react";
import { FaAngleDown, FaAngleUp } from "react-icons/fa";

const CategoryCard: React.FC<StatusIndicatorProps> = ({
  category,
  budgetUuid,
  currentMonthLbl,
  monthTotal,
}) => {
  const [isCollapsed, setIsCollapsed] = useState(true);
  const percentage = percentageSpent(category);
  const statusClass = percentageToStatusClass(percentage);

  const handleToggleCollapse = () => {
    setIsCollapsed(!isCollapsed);
  };

  return (
    <div className="w-full sm:w-1/2 md:w-1/3 mb-5">
      <div className="card mx-2 bg-base-100 shadow-xl">
        <div className="card-body">
          <div className="flex items-center justify-between">
            <h2 className="card-title">
              <Link
                className="link"
                href={`/budgets/${budgetUuid}/transactions?month=${currentMonthLbl}&categoryUuid=${category.uuid}`}
              >
                {category.name}
              </Link>{" "}
            </h2>
            <PercentageBadget category={category} />
            <button
              className="btn btn-ghost btn-sm"
              onClick={handleToggleCollapse}
            >
              {isCollapsed ? <FaAngleDown /> : <FaAngleUp />}
            </button>
          </div>
          {!isCollapsed && (
            <>
              {!isInflowCategory(category) && (
                <ExpenseCategoryCard
                  category={category}
                  monthTotal={monthTotal}
                />
              )}
              {isInflowCategory(category) && (
                <InflowCategoryCard category={category} />
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
};

const ExpenseCategoryCard = ({
  category,
  monthTotal,
}: {
  category: Category;
  monthTotal: MonthTotal;
}) => {
  const budget = formatAmount(category.budgeted);
  const spent = formatAmount(category.activity, true);
  const percentage = percentageSpent(category);
  const statusClass = percentageToStatusClass(percentage);
  return (
    <>
      <table className="table w-full">
        <tbody>
          <tr>
            <td>Available</td>
            <td>{formatAmount(category.balance)}</td>
            <td>
              <Progress
                percentage={calculatePercentage(
                  category.balance,
                  monthTotal.totalBalance
                )}
              />
            </td>
          </tr>
          <tr>
            <td>Budgeted</td>
            <td>{budget}</td>
            <td>
              <Progress
                percentage={calculatePercentage(
                  category.budgeted,
                  monthTotal.totalBudgeted
                )}
              />
            </td>
          </tr>
          <tr>
            <td>Spent</td>
            <td>{spent}</td>
            <td>
              <Progress
                percentage={calculatePercentage(
                  category.activity,
                  monthTotal.totalSpent
                )}
              />
            </td>
          </tr>
        </tbody>
      </table>
      <progress
        className={`progress progress-${statusClass} w-56`}
        value={percentage}
        max="100"
      ></progress>
    </>
  );
};

const PercentageBadget = ({ category }: { category: Category }) => {
  const percentage = percentageSpent(category);
  const statusClass = percentageToStatusClass(percentage);
  return (
    <span className={`mx-3 badge badge-${statusClass} badge-outline`}>
      {formatPercentage(percentage)}
    </span>
  );
}

const InflowCategoryCard = ({ category }: { category: Category }) => (
  <>
    <table className="table w-full">
      <tbody>
        <tr>
          <td>Activity</td>
          <td>{formatAmount(category.activity)}</td>
          <td></td>
        </tr>
      </tbody>
    </table>
  </>
);
export default CategoryCard;
</file>

<file path="packages/web/app/components/budget-page/hidden-progress-bars.tsx">
// todo: this is needed to dynamically have colors for
// the progress bars. Check how this can be avoided
const HiddenProgressBars = () => (
  <>
    <progress
      className="progress progress-info hidden"
      value="0"
      max="100"
    ></progress>
    <progress
      className="progress progress-warning hidden"
      value="0"
      max="100"
    ></progress>
    <progress
      className="progress progress-error hidden"
      value="0"
      max="100"
    ></progress>
  </>
);

export default HiddenProgressBars;
</file>

<file path="packages/web/app/components/budget-page/month-summary-block.tsx">
import Link from "next/link";
import CategoryCard from "./category-card";
import { get } from "http";
import {
  MonthSummary, formatAmount, Category,
  CategoryUsage,
  emptyCategory,
  isInflowCategory,
} from "common-ts";
type Props = {
  budgetUuid: string;
  month: MonthSummary;
  categories: Category[];
};

const sortByCategoryAmount = (a: CategoryUsage, b: CategoryUsage) => {
  return a.amount - b.amount;
};

const MonthSummaryBlock = ({ month, categories, budgetUuid }: Props) => {
  const getCategory = (categoryName: string): Category => {
    return (
      categories.find((category) => category.name === categoryName) ||
      emptyCategory
    );
  };

  const getPercentageOverTarget = (category: CategoryUsage) => {
    const targetAmount = getCategory(category.name).targetAmount;
    if (targetAmount === 0) {
      // no target set return 125 to show as error
      return 125;
    }
    // return absolute percentage over target
    return Math.abs(
      Math.round(
        (category.amount / getCategory(category.name).targetAmount) * 100
      )
    );
  };

  const getStatusClassByOverTargetSeverity = (category: CategoryUsage) => {
    if (isInflowCategory(getCategory(category.name))) {
      return "info";
    }
    const percentage = getPercentageOverTarget(category);
    if (percentage < 105) {
      return "success";
    }
    if (percentage < 120) {
      return "warning";
    }
    return "error";
  };

  return (
    <div key={month.month} className="card bg-base-100 shadow-xl m-2">
      <div className="card-body">
        <Link
          className="link"
          href={`/budgets/${budgetUuid}/transactions?month=${month.month}`}
        >
          <h2 className="card-title">{month.month}</h2>
        </Link>

        <table className="table">
          <thead>
            <tr>
              <th>Category</th>
              <th>Amount/Target</th>
            </tr>
          </thead>
          <tbody>
            {month.categoryUsages
              .sort(sortByCategoryAmount)
              .map((categoryUsage) => (
                <tr key={categoryUsage.name}>
                  <td>
                    <Link
                      className="link"
                      href={`/budgets/${budgetUuid}/transactions?month=${month.month}&categoryUuid=${categoryUsage.uuid}`}
                    >
                      <p>{categoryUsage.name}</p>
                    </Link>
                  </td>
                  <td>
                    <p
                      className={`badge badge-${getStatusClassByOverTargetSeverity(
                        categoryUsage
                      )} badge-outline`}
                    >
                      {formatAmount(categoryUsage.amount, true)}
                      &nbsp;/&nbsp;
                      {formatAmount(
                        getCategory(categoryUsage.name).targetAmount
                      )}
                    </p>
                  </td>
                </tr>
              ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default MonthSummaryBlock;
</file>

<file path="packages/web/app/components/charts/test-chart.tsx">
"use client";
import React, { MouseEvent, useRef } from "react";
import type { InteractionItem } from "chart.js";
import {
  Chart as ChartJS,
  LinearScale,
  CategoryScale,
  BarElement,
  PointElement,
  LineElement,
  Legend,
  Tooltip,
} from "chart.js";
import {
  Chart,
  getDatasetAtEvent,
  getElementAtEvent,
  getElementsAtEvent,
} from "react-chartjs-2";

ChartJS.register(
  LinearScale,
  CategoryScale,
  BarElement,
  PointElement,
  LineElement,
  Legend,
  Tooltip
);

export const options = {
  scales: {
    y: {
      beginAtZero: true,
    },
  },
};

const labels = ["January", "February", "March", "April", "May", "June", "July"];

const randomNumber = (min: number, max: number) => {
  return Math.floor(Math.random() * (max - min + 1) + min);
};
export const data = {
  labels,
  datasets: [
    {
      type: "line" as const,
      label: "Dataset 1",
      borderColor: "rgb(255, 99, 132)",
      borderWidth: 2,
      fill: false,
      data: labels.map(() => randomNumber(-1000, 1000)),
    },
    {
      type: "bar" as const,
      label: "Dataset 2",
      backgroundColor: "rgb(75, 192, 192)",
      data: labels.map(() => randomNumber(-1000, 1000)),
      borderColor: "white",
      borderWidth: 2,
    },
    {
      type: "bar" as const,
      label: "Dataset 3",
      backgroundColor: "rgb(53, 162, 235)",
      data: labels.map(() => randomNumber(-1000, 1000)),
    },
  ],
};

export const TestChart = () => {
  const printDatasetAtEvent = (dataset: InteractionItem[]) => {
    if (!dataset.length) return;

    const datasetIndex = dataset[0].datasetIndex;

    console.log(data.datasets[datasetIndex].label);
  };

  const printElementAtEvent = (element: InteractionItem[]) => {
    if (!element.length) return;

    const { datasetIndex, index } = element[0];

    console.log(data.labels[index], data.datasets[datasetIndex].data[index]);
  };

  const printElementsAtEvent = (elements: InteractionItem[]) => {
    if (!elements.length) return;

    console.log(elements.length);
  };

  const chartRef = useRef<ChartJS>(null);

  const onClick = (event: MouseEvent<HTMLCanvasElement>) => {
    const { current: chart } = chartRef;

    if (!chart) {
      return;
    }

    printDatasetAtEvent(getDatasetAtEvent(chart, event));
    printElementAtEvent(getElementAtEvent(chart, event));
    printElementsAtEvent(getElementsAtEvent(chart, event));
  };

  return (
    <Chart
      ref={chartRef}
      type="bar"
      onClick={onClick}
      options={options}
      data={data}
    />
  );
};
</file>

<file path="packages/web/app/components/charts/util.tsx">
import { compose } from "ramda";
import { Transaction, numberD1000 } from "common-ts";


export const nameToColorIndex = (name: string): number => {
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  // Ensure the hash is positive
  hash = Math.abs(hash);
  return hash % colorPalette.length;
};

export const nameToUniqueColor = (name: string): string => {
  const color = colorPalette[nameToColorIndex(name)];
  return color;
};

const colorPalette: string[] = [
  "rgb(255, 102, 51)",
  "rgb(255, 179, 153)",
  "rgb(255, 51, 255)",
  "rgb(255, 255, 153)",
  "rgb(0, 179, 230)",
  "rgb(230, 179, 51)",
  "rgb(51, 102, 230)",
  "rgb(153, 153, 102)",
  "rgb(153, 255, 153)",
  "rgb(179, 77, 77)",
  "rgb(128, 179, 0)",
  "rgb(128, 153, 0)",
  "rgb(230, 179, 179)",
  "rgb(102, 128, 179)",
  "rgb(102, 153, 26)",
  "rgb(255, 153, 230)",
  "rgb(204, 255, 26)",
  "rgb(255, 26, 102)",
  "rgb(230, 51, 26)",
  "rgb(51, 255, 204)",
  "rgb(102, 153, 77)",
  "rgb(179, 102, 204)",
  "rgb(77, 128, 0)",
  "rgb(179, 51, 0)",
  "rgb(204, 128, 204)",
  "rgb(102, 102, 77)",
  "rgb(153, 26, 255)",
  "rgb(230, 102, 255)",
  "rgb(77, 179, 255)",
  "rgb(26, 179, 153)",
  "rgb(230, 102, 179)",
  "rgb(51, 153, 26)",
  "rgb(204, 153, 153)",
  "rgb(179, 179, 26)",
  "rgb(0, 230, 128)",
  "rgb(77, 128, 102)",
  "rgb(128, 153, 128)",
  "rgb(230, 255, 128)",
  "rgb(26, 255, 51)",
  "rgb(153, 153, 51)",
  "rgb(255, 51, 128)",
  "rgb(204, 204, 0)",
  "rgb(102, 230, 77)",
  "rgb(77, 128, 204)",
  "rgb(153, 0, 179)",
  "rgb(230, 77, 102)",
  "rgb(77, 179, 128)",
  "rgb(255, 77, 77)",
  "rgb(153, 230, 230)",
  "rgb(102, 102, 255)",
];

export type MonthlySpendingData = {
  dayOfMonth: string;
  spent: number;
};

const daysOfMonthAsStrings = () => {
  const days = [];
  for (let i = 1; i <= 31; i++) {
    days.push(i.toString());
  }
  return days;
};

export const getMonthlySpendingData = (
  transactions: Transaction[]
): MonthlySpendingData[] =>
  compose(
    ifAllNegativeShowPositive,
    transactionsToMonthlySpendingData
  )(transactions);

const transactionsToMonthlySpendingData = (
  transactions: Transaction[]
): MonthlySpendingData[] => {
  const groupedByDay = transactions.reduce((acc, transaction) => {
    const dayOfMonth = new Date(transaction.date).getDate();
    if (!acc[dayOfMonth]) {
      acc[dayOfMonth] = [];
    }
    acc[dayOfMonth].push(transaction);
    return acc;
  }, {} as { [key: number]: Transaction[] });

  return daysOfMonthAsStrings().map((dayOfMonth) => {
    const transactions = groupedByDay[parseInt(dayOfMonth)];
    if (!transactions) {
      return {
        dayOfMonth,
        spent: 0,
      };
    }
    const spent = transactions.reduce(
      (acc, transaction) => acc + numberD1000(transaction.amount),
      0
    );
    return {
      dayOfMonth,
      spent,
    };
  });
};

const ifAllNegativeShowPositive = (
  spendingData: MonthlySpendingData[]
): MonthlySpendingData[] => {
  const allNegative = spendingData.every((data) => data.spent <= 0);
  if (allNegative) {
    return spendingData.map((data) => ({
      ...data,
      spent: Math.abs(data.spent),
    }));
  }
  return spendingData;
};

export const isOnMobileDevice = () =>
  // based on user agent string
  // https://stackoverflow.com/a/8876069/10247962
  navigator
    ? /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    )
    : false;

export const valueToPercentageOfTotal = (
  value: string,
  total: number
): number => {
  const numValue = parseFloat(value);
  return Math.round((numValue / total) * 100);
};


export const chartFormatter = (totalAmount: number, minPercentageToDisplay: number) => (value: string, context: any) => {
  const percentage = valueToPercentageOfTotal(value, totalAmount);
  if (percentage < minPercentageToDisplay) {
    return "";
  }
  return (
    `${context.chart.data.labels[context.dataIndex]
    } ${valueToPercentageOfTotal(value, totalAmount)}%` || value
  );
  // This will display the label of each pie slice inside the slice
};
</file>

<file path="packages/web/app/components/login/index.tsx">
"use client";

import { signIn } from "next-auth/react";

export function SignOut() {
  return (
    <div className="mb-4 flex rounded-md border border-gray-800 bg-black px-4 py-3 text-sm font-semibold text-neutral-200 transition-all hover:text-white">
      <a href="/api/defauth/logout">Logout</a>
    </div>
  );
}

export function SignIn() {
  return (
    <div className="mb-4 flex rounded-md border border-gray-800 bg-black px-4 py-3 text-sm font-semibold text-neutral-200 transition-all hover:text-white">
      <a href="/api/defauth/login">Login</a>
    </div>
  );
}

export const YnabSignIn = () => (
  <button
    className="mb-4 flex rounded-md border border-gray-800 bg-black px-4 py-3 text-sm font-semibold text-neutral-200 transition-all hover:text-white"
    onClick={() => signIn("ynab", { callbackUrl: "/" })}
  >
    <div className="ml-3">Connect to Ynab</div>
  </button>
);
</file>

<file path="packages/web/app/components/login/ynab.tsx">
"use client";
import { signIn } from "next-auth/react";

export function ConnectToYnab() {
  return (
    <button
      className="mb-4 flex rounded-md border border-gray-800 bg-black px-4 py-3 text-sm font-semibold text-neutral-200 transition-all hover:text-white"
      onClick={() => signIn("ynab", { callbackUrl: "/" })}
    >
      <div className="ml-3">Sign in with Ynab</div>
    </button>
  );
}
</file>

<file path="packages/web/app/components/transactions-page/category-select.tsx">
"use client";
import Link from "next/link";
import { ChangeEvent, ChangeEventHandler } from "react";
import { useSearchParams, usePathname, useRouter } from "next/navigation";
import { Category, formatAmount } from "common-ts";

function CategorySelect({
  categoryUuid,
  categories,
  onChange,
}: {
  categoryUuid: string | undefined;
  categories: Category[];
  //category onChange
  onChange: (value: string) => void;
}) {
  const searchParams = useSearchParams();
  const pathname = usePathname();
  const { replace } = useRouter();

  const navigateToCategory = (event: ChangeEvent<HTMLSelectElement>) => {
    const newCategoryUuid = event.target.value;
    const params = new URLSearchParams(searchParams);
    if (newCategoryUuid) {
      params.set("categoryUuid", newCategoryUuid);
    } else {
      params.delete("categoryUuid");
    }
    replace(`${pathname}?${params.toString()}`);
    onChange(newCategoryUuid);
  };

  return (
    <select
      className="select select-bordered w-full max-w-xs"
      value={categoryUuid}
      onChange={navigateToCategory}
    >
      {" "}
      <option value={""}>Select category</option>
      {categories.map((category) => (
        <option key={category.uuid} value={category.uuid}>
          {category.name} {formatAmount(category.activity)}
        </option>
      ))}
    </select>
  );
}

export default CategorySelect;
</file>

<file path="packages/web/app/components/transactions-page/index.tsx">
import Link from "next/link";
import { Suspense, useState } from "react";
import Loading from "../Loading";
import { getFilteredTransactionsWithCategories } from "../../api/transaction/transaction.client";
import TransactionContent from "./transaction-content";

export default function TransactionsPage({
  budgetUuid,
  categoryUuid,
  month,
  dayOfMonth,
}: {
  budgetUuid: string;
  categoryUuid: string | undefined;
  month: string | undefined;
  dayOfMonth: string | undefined;
}) {
  return (
    <>
      <Suspense fallback={<Loading />}>
        <TransactionsInfo
          budgetUuid={budgetUuid}
          categoryUuid={categoryUuid}
          month={month}
          dayOfMonth={dayOfMonth}
        />
      </Suspense>
    </>
  );
}

async function TransactionsInfo({
  budgetUuid,
  categoryUuid,
  month,
  dayOfMonth,
}: {
  budgetUuid: string;
  categoryUuid?: string;
  month?: string;
  dayOfMonth?: string;
}) {
  const { transactions, categories } = await getFilteredTransactionsWithCategories(
    budgetUuid,
    month,
    dayOfMonth
  );
  return (
    <TransactionContent
      budgetUuid={budgetUuid}
      categoryUuid={categoryUuid}
      month={month}
      categories={categories}
      transactions={transactions}
    />
  );
}
</file>

<file path="packages/web/app/components/transactions-page/payeeWithActivity-reducer.ts">
import { PayeeWithActivity, Transaction } from "common-ts";

export const payeeWithActivityReducer = (
  payeesWithActivity: Array<PayeeWithActivity>,
  transaction: Transaction
) => {
  // only include costs (activity < 0)
  if (transaction.amount >= 0) {
    return payeesWithActivity;
  }
  const payeeName = transaction.cleanPayeeName;
  const payeeWithActivity = payeesWithActivity.find(
    (payeeWithActivity: PayeeWithActivity) =>
      payeeWithActivity.payeeName === payeeName
  );
  if (payeeWithActivity) {
    payeeWithActivity.activity += transaction.amount;
  } else {
    payeesWithActivity.push({
      payeeName,
      activity: transaction.amount,
    });
  }
  return payeesWithActivity;
};
</file>

<file path="packages/web/app/components/Loading.tsx">
const Loading = () => (
  <span className="loading loading-spinner loading-lg"></span>
);

export default Loading;
</file>

<file path="packages/web/app/components/progress.tsx">
import { percentageToStatusClass } from "../utils";

type Props = {
  percentage: number;
  width?: number;
};

const Progress = ({ percentage, width }: Props) => (
  <progress
    className={`progress progress-${percentageToStatusClass(percentage)} w-10`}
    value={percentage}
    max="100"
  ></progress>
);

export default Progress;
</file>

<file path="packages/web/app/components/ynab-login-page.tsx">
import { YnabSignIn } from "./login";

const YnabLoginPage = () => (
  <div className="flex min-h-full flex-col items-center justify-center">
    <h1 className="mb-12"></h1>
    <div className="items center mx-auto flex w-full max-w-md justify-center px-8">
      <YnabSignIn />
    </div>
  </div>
);

export default YnabLoginPage;
</file>

<file path="packages/web/app/lib/metrics.ts">
import client from "prom-client";

// Create a Registry which registers the metrics
const register = new client.Registry();

// Add a default metrics collection to the registry
client.collectDefaultMetrics({ register });

// Export the registry
export default register;
</file>

<file path="packages/web/app/login/page.tsx">
import { redirect } from "next/navigation";
import { SignIn, SignOut } from "../components/login";
import { getSession } from "@auth0/nextjs-auth0";

async function LoginPage() {
  const session = await getSession();
  const isLoggedIn: boolean = !!session?.user;
  if (isLoggedIn) {
    redirect("/");
  }
  return (
    <div className="flex min-h-full flex-col items-center justify-center">
      <h1 className="mb-12"></h1>
      <div className="items center mx-auto flex w-full max-w-md justify-center px-8">
        <SignIn />
      </div>
    </div>
  );
}

export default LoginPage;
</file>

<file path="packages/web/app/sentry-example-page/page.tsx">
"use client";

import Head from "next/head";
import * as Sentry from "@sentry/nextjs";

export default function Page() {
  return (
    <div>
      <Head>
        <title>Sentry Onboarding</title>
        <meta name="description" content="Test Sentry for your Next.js app!" />
      </Head>

      <main
        style={{
          minHeight: "100vh",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
        }}
      >
        <h1 style={{ fontSize: "4rem", margin: "14px 0" }}>
          <svg
            style={{
              height: "1em",
            }}
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 200 44"
          >
            <path
              fill="currentColor"
              d="M124.32,28.28,109.56,9.22h-3.68V34.77h3.73V15.19l15.18,19.58h3.26V9.22h-3.73ZM87.15,23.54h13.23V20.22H87.14V12.53h14.93V9.21H83.34V34.77h18.92V31.45H87.14ZM71.59,20.3h0C66.44,19.06,65,18.08,65,15.7c0-2.14,1.89-3.59,4.71-3.59a12.06,12.06,0,0,1,7.07,2.55l2-2.83a14.1,14.1,0,0,0-9-3c-5.06,0-8.59,3-8.59,7.27,0,4.6,3,6.19,8.46,7.52C74.51,24.74,76,25.78,76,28.11s-2,3.77-5.09,3.77a12.34,12.34,0,0,1-8.3-3.26l-2.25,2.69a15.94,15.94,0,0,0,10.42,3.85c5.48,0,9-2.95,9-7.51C79.75,23.79,77.47,21.72,71.59,20.3ZM195.7,9.22l-7.69,12-7.64-12h-4.46L186,24.67V34.78h3.84V24.55L200,9.22Zm-64.63,3.46h8.37v22.1h3.84V12.68h8.37V9.22H131.08ZM169.41,24.8c3.86-1.07,6-3.77,6-7.63,0-4.91-3.59-8-9.38-8H154.67V34.76h3.8V25.58h6.45l6.48,9.2h4.44l-7-9.82Zm-10.95-2.5V12.6h7.17c3.74,0,5.88,1.77,5.88,4.84s-2.29,4.86-5.84,4.86Z M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z"
            ></path>
          </svg>
        </h1>

        <p>Get started by sending us a sample error:</p>
        <button
          type="button"
          style={{
            padding: "12px",
            cursor: "pointer",
            backgroundColor: "#AD6CAA",
            borderRadius: "4px",
            border: "none",
            color: "white",
            fontSize: "14px",
            margin: "18px",
          }}
          onClick={async () => {
            await Sentry.startSpan({
              name: 'Example Frontend Span',
              op: 'test'
            }, async () => {
              const res = await fetch("/api/sentry-example-api");
              if (!res.ok) {
                throw new Error("Sentry Example Frontend Error");
              }
            });
          }}
        >
          Throw error!
        </button>

        <p>
          Next, look for the error on the{" "}
          <a href="https://vanden-it.sentry.io/issues/?project=4508281708281936">Issues Page</a>.
        </p>
        <p style={{ marginTop: "24px" }}>
          For more information, see{" "}
          <a href="https://docs.sentry.io/platforms/javascript/guides/nextjs/">
            https://docs.sentry.io/platforms/javascript/guides/nextjs/
          </a>
        </p>
      </main>
    </div>
  );
}
</file>

<file path="packages/web/app/utils/index.ts">
export const percentageToStatusClass = (percentage: number) => {
  let statusClass = "info";
  if (percentage > 85) {
    statusClass = "error";
  } else if (percentage > 50) {
    statusClass = "warning";
  }
  return statusClass;
};
</file>

<file path="packages/web/app/ynablogin/page.tsx">
import { YnabSignIn } from "../components/login";
import YnabLoginPage from "../components/ynab-login-page";

const YnabLogin = () => <YnabLoginPage />;

export default YnabLogin;
</file>

<file path="packages/web/app/_app.tsx">
import { AppProps } from "next/app";
import { useEffect } from "react";
import { overrideConsoleLog } from "common-ts";

const MyApp = ({ Component, pageProps }: AppProps) => {


  return <Component {...pageProps} />;
};

export default MyApp;
</file>

<file path="packages/web/app/global-error.tsx">
"use client";

import * as Sentry from "@sentry/nextjs";
import NextError from "next/error";
import { useEffect } from "react";

export default function GlobalError({ error }: { error: Error & { digest?: string } }) {
  useEffect(() => {
    Sentry.captureException(error);
  }, [error]);

  return (
    <html>
      <body>
        {/* `NextError` is the default Next.js error page component. Its type
        definition requires a `statusCode` prop. However, since the App Router
        does not expose status codes for errors, we simply pass 0 to render a
        generic error message. */}
        <NextError statusCode={0} />
      </body>
    </html>
  );
}
</file>

<file path="packages/web/mongoplayground/playground-1.mongodb.js">
/* global use, db */
// MongoDB Playground
// To disable this template go to Settings | MongoDB | Use Default Template For Playground.
// Make sure you are connected to enable completions and to be able to run a playground.
// Use Ctrl+Space inside a snippet or a string literal to trigger completions.
// The result of the last command run in a playground is shown on the results panel.
// By default the first 20 documents will be returned with a cursor.
// Use 'console.log()' to print to the debug output.
// For more documentation on playgrounds please refer to
// https://www.mongodb.com/docs/mongodb-vscode/playgrounds/

// Select the database to use.
use("mongodbVSCodePlaygroundDB");

// Insert a few documents into the sales collection.
db.getCollection("sales").insertMany([
  {
    item: "abc",
    price: 10,
    quantity: 2,
    date: new Date("2014-03-01T08:00:00Z"),
  },
  {
    item: "jkl",
    price: 20,
    quantity: 1,
    date: new Date("2014-03-01T09:00:00Z"),
  },
  {
    item: "xyz",
    price: 5,
    quantity: 10,
    date: new Date("2014-03-15T09:00:00Z"),
  },
  {
    item: "xyz",
    price: 5,
    quantity: 20,
    date: new Date("2014-04-04T11:21:39.736Z"),
  },
  {
    item: "abc",
    price: 10,
    quantity: 10,
    date: new Date("2014-04-04T21:23:13.331Z"),
  },
  {
    item: "def",
    price: 7.5,
    quantity: 5,
    date: new Date("2015-06-04T05:08:13Z"),
  },
  {
    item: "def",
    price: 7.5,
    quantity: 10,
    date: new Date("2015-09-10T08:43:00Z"),
  },
  {
    item: "abc",
    price: 10,
    quantity: 5,
    date: new Date("2016-02-06T20:20:13Z"),
  },
]);

// Run a find command to view items sold on April 4th, 2014.
const salesOnApril4th = db
  .getCollection("sales")
  .find({
    date: { $gte: new Date("2014-04-04"), $lt: new Date("2014-04-05") },
  })
  .count();

// Print a message to the output window.
console.log(`${salesOnApril4th} sales occurred in 2014.`);

// Here we run an aggregation and open a cursor to the results.
// Use '.toArray()' to exhaust the cursor to return the whole result set.
// You can use '.hasNext()/.next()' to iterate through the cursor page by page.
db.getCollection("sales").aggregate([
  // Find all of the sales that occurred in 2014.
  {
    $match: {
      date: { $gte: new Date("2014-01-01"), $lt: new Date("2015-01-01") },
    },
  },
  // Group the total sales for each product.
  {
    $group: {
      _id: "$item",
      totalSaleAmount: { $sum: { $multiply: ["$price", "$quantity"] } },
    },
  },
]);
</file>

<file path="packages/web/mongoplayground/playground-2.mongodb.js">
/* global use, db */
use("budgetDG");

db.getCollection("users").find();
db.getCollection("users").drop();
db.getCollection("localbudgets").findOne({ _id: ObjectId('660fcee01a3ec002591955e1') });
db.getCollection("localbudgets").find();
db.getCollection("localcategories").find({ budgetId: ObjectId('660fcee01a3ec002591955e1') });
db.getCollection("localcategories").remove({});

db.getCollection("localbudgets").remove({});

db.getCollection("localbudgets").drop({});

db.getCollection("users").remove({});

db.getCollection("localtransactions").find({ date: { $exists: true } });
db.getCollection("localtransactions").count({
  budgetId: "7812a588-8c0d-40fe-b6d9-6da6d7025056",
});

const month = "2024-01";
const budgetId = "658590a320511d33897ae7b7";

const dateFilter = { $regex: `^${month}` };
db.getCollection("localtransactions").find({
  budgetId,
  date: dateFilter,
});

db.getCollection("localtransactions").find({
  budgetId: "1b443ebf-ea07-4ab7-8fd5-9330bf80608c",
  date: { $regex: "^2024-01" },
});
db.getCollection("localtransactions").find({
  budgetId: "b84f2a66-8d15-42ba-ae09-9163e01125b9",
  date: { $exists: true },
});

db.getCollection("usertransactions").remove({});
db.getCollection("usertransactions").find({
  budgetId: "b84f2a66-8d15-42ba-ae09-9163e01125b9",
});

//db.getCollection("usertransactions").drop({});
db.getCollection("usertransactions").remove({});
db.getCollection("localtransactions").remove({});

db.getCollection("localtransactions").find({
  id: "73879cc3-a21c-4c5f-b31d-6e7f4acbe22d",
});
db.getCollection("localtransactions").remove({
  id: "ec7454c7-25fd-42e7-9988-0ee26b1de254",
});

db.getCollection("user").find();
</file>

<file path="packages/web/mongoplayground/playground-budget-mongodb.js">
/* global use, db */
use("budgetDG");

db.getCollection("user").insertMany({
  name: "John Doe",
  email: "",
});
</file>

<file path="packages/web/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="packages/web/public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="packages/web/.eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="packages/web/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.env

# Sentry Config File
.env.sentry-build-plugin
</file>

<file path="packages/web/instrumentation.ts">
import * as Sentry from '@sentry/nextjs';

export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    await import('./sentry.server.config');
  }

  if (process.env.NEXT_RUNTIME === 'edge') {
    await import('./sentry.edge.config');
  }
}

export const onRequestError = Sentry.captureRequestError;
</file>

<file path="packages/web/README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="packages/web/sentry.client.config.ts">
// This file configures the initialization of Sentry on the client.
// The config you add here will be used whenever a users loads a page in their browser.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://682a51c90cd9df33e624ed57c031a661@o4508281706577920.ingest.de.sentry.io/4508281708281936",

  // Add optional integrations for additional features
  integrations: [
    Sentry.replayIntegration(),
    Sentry.browserTracingIntegration(),
  ],

  // Define how likely traces are sampled. Adjust this value in production, or use tracesSampler for greater control.
  tracesSampleRate: 1,

  // Define how likely Replay events are sampled.
  // This sets the sample rate to be 10%. You may want this to be 100% while
  // in development and sample at a lower rate in production
  replaysSessionSampleRate: 0.1,

  // Define how likely Replay events are sampled when an error occurs.
  replaysOnErrorSampleRate: 1.0,

  // Setting this option to true will print useful information to the console while you're setting up Sentry.
  debug: false,
});
</file>

<file path="packages/web/sentry.edge.config.ts">
// This file configures the initialization of Sentry for edge features (middleware, edge routes, and so on).
// The config you add here will be used whenever one of the edge features is loaded.
// Note that this config is unrelated to the Vercel Edge Runtime and is also required when running locally.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://682a51c90cd9df33e624ed57c031a661@o4508281706577920.ingest.de.sentry.io/4508281708281936",

  // Define how likely traces are sampled. Adjust this value in production, or use tracesSampler for greater control.
  tracesSampleRate: 1,

  // Setting this option to true will print useful information to the console while you're setting up Sentry.
  debug: false,
});
</file>

<file path="packages/web/sentry.server.config.ts">
// This file configures the initialization of Sentry on the server.
// The config you add here will be used whenever the server handles a request.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://682a51c90cd9df33e624ed57c031a661@o4508281706577920.ingest.de.sentry.io/4508281708281936",

  // Define how likely traces are sampled. Adjust this value in production, or use tracesSampler for greater control.
  tracesSampleRate: 1,

  // Setting this option to true will print useful information to the console while you're setting up Sentry.
  debug: false,
});
</file>

<file path="docker-commands.md">
# removea all

docker-compose down --rmi all

## build and run specific app

docker-compose build ai
docker-compose up ai
</file>

<file path="grafana.md">
kubectl port-forward -n monitoring deploy/grafana 3000

1. Get your 'admin' user password by running:

   kubectl get secret --namespace monitoring grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo

2. The Grafana server can be accessed via port 80 on the following DNS name from within your cluster:

   grafana.monitoring.svc.cluster.local

   Get the Grafana URL to visit by running these commands in the same shell:
   export POD_NAME=$(kubectl get pods --namespace monitoring -l "app.kubernetes.io/name=grafana,app.kubernetes.io/instance=grafana" -o jsonpath="{.items[0].metadata.name}")
   kubectl --namespace monitoring port-forward $POD_NAME 3000

3. Login with the password from step 1 and the username: admin
   #################################################################################

###### WARNING: Persistence is disabled!!! You will lose your data when

###### the Grafana pod is terminated.

#################################################################################
</file>

<file path="prometheus-queries.md">
### Step 2: Query Memory Usage in Prometheus

Now that your deployments are labeled, you can use these labels in your PromQL queries to filter for metrics related to your budget apps.

**Example Query for Memory Usage**:
To query the memory usage for only your budget apps, you can filter by the `app` label. Assuming `process_resident_memory_bytes` is the metric name for memory usage, the query would look like this:

```promql
process_resident_memory_bytes{app=~"budget-.*"}
```

This query uses a regular expression to match any value of the `app` label that starts with `budget-`.

### Step 3: Access Prometheus UI and Execute Query

1. **Access Prometheus UI**:
   If Prometheus is not exposed via a LoadBalancer or Ingress, use port forwarding to access the Prometheus UI locally.

   ```bash
   kubectl port-forward -n monitoring deployment/prometheus-server 9090:9090
   ```

   Open your browser and navigate to `http://localhost:9090`.

2. **Navigate to the "Graph" Tab**:
   Click on the "Graph" tab at the top.

3. **Enter the Query**:
   Enter the query `process_resident_memory_bytes{app=~"budget-.*"}` in the "Expression" input box.

4. **Execute the Query**:
   Click the "Execute" button to run the query. The results will be displayed below the input box.

5. **Visualize the Data**:
   Switch between the "Table" and "Graph" views to see the data in different formats.

### Example PromQL Queries

Here are a few additional PromQL queries you might find useful:

- **Total Resident Memory Usage for All Budget Apps**:

  ```promql
  sum(process_resident_memory_bytes{app=~"budget-.*"})
  ```

- **Resident Memory Usage for Budget Web App**:

  ```promql
  process_resident_memory_bytes{app="budget-web-app"}
  ```

- **Resident Memory Usage for Budget API App**:
  ```promql
  process_resident_memory_bytes{app="budget-api-app"}
  ```

### Summary

1. **Label Your Deployments**: Ensure your budget applications are properly labeled.
2. **Use PromQL Queries**: Use the labels in your PromQL queries to filter for metrics related to your budget apps.
3. **Access Prometheus UI**: Use port forwarding if necessary to access the Prometheus UI and execute your queries.
4. **Visualize Data**: Use the "Graph" and "Table" views in Prometheus to visualize your data.

By following these steps, you can query and monitor memory usage specifically for your budget applications using Prometheus.
</file>

<file path="docs/new features/simulation-improvement-4juli/implementation.md">
# Scheduled Transaction Creation Feature Implementation

## Overview

This implementation adds the ability to create scheduled transactions directly from the prediction homepage, as specified in `specs.md`. Users can now add new scheduled transactions through a dialog interface that reuses existing components.

## Features Implemented

### 1. Backend API Endpoints

#### New Endpoint: `POST /budgets/{uuid}/scheduled-transactions`
- **Purpose**: Create a new scheduled transaction
- **Security**: Full user authentication and budget ownership validation
- **Input Validation**: 
  - Required fields: amount, categoryId, date, accountId
  - Data type validation for all fields
  - Date format validation (YYYY-MM-DD)
  - String sanitization (trimming whitespace)
- **Error Handling**: Comprehensive error messages for validation failures

#### New Endpoint: `GET /budgets/{uuid}/accounts`
- **Purpose**: Get accounts for account selection in create dialog
- **Security**: Full user authentication and budget ownership validation

### 2. Frontend Components

#### Enhanced EditTransactionDialog
- **Dual Mode Support**: Now supports both 'edit' and 'create' modes
- **Account Selection**: Dropdown for selecting account when creating transactions
- **Form Fields**: 
  - Amount (required)
  - Category (required, dropdown)
  - Date (required, date picker)
  - Account (required for create mode, dropdown)
  - Payee (optional, text input)
  - Memo (optional, text input)
- **Validation**: Client-side validation with error messages
- **Auto-loading**: Automatically loads accounts when dialog opens in create mode

#### Enhanced FutureChangesTable
- **Add Button**: New "Add Transaction" button with plus icon
- **Dialog Integration**: Separate dialog instances for edit and create modes
- **State Management**: Proper state handling for both edit and create operations

### 3. API Client Functions

#### New Functions
- `createScheduledTransaction()`: Client-side API call for creating transactions
- `getAccounts()`: Client-side API call for fetching accounts

#### Enhanced Types
- `ScheduledTransactionCreate`: Type definition for create payload
- `Account`: Type definition for account data

### 4. Security Implementation

#### Input Validation
- **Type Checking**: Validates data types for all inputs
- **Format Validation**: Date format validation with regex
- **Sanitization**: Trims whitespace from string inputs
- **Required Field Validation**: Ensures all required fields are present

#### Authentication & Authorization
- **JWT Authentication**: All endpoints require valid JWT tokens
- **Budget Ownership**: Validates user owns the budget before operations
- **User Validation**: Ensures user exists and is authenticated

#### Error Handling
- **Descriptive Errors**: Clear error messages for different failure scenarios
- **Security**: No sensitive information leaked in error messages
- **Logging**: Proper error logging for debugging

### 5. Testing

#### Unit Tests
- **Controller Tests**: Comprehensive tests for the create endpoint
- **Test Coverage**: 
  - Successful creation scenarios
  - Authentication failures
  - Validation failures
  - Input sanitization
  - Error handling
- **Mocking**: Proper mocking of dependencies
- **Security Testing**: Tests for unauthorized access scenarios

## Files Modified/Created

### Backend
- `packages/api/src/routes/scheduledTransactions.ts` - Added POST route
- `packages/api/src/routes/budgetRoutes.ts` - Added accounts endpoint
- `packages/api/src/controllers/scheduledTransactionController.ts` - Added create function
- `packages/api/src/controllers/budgetController.ts` - Added getAccountsForBudget function
- `packages/api/src/data/ynab/ynab.server.ts` - Added create and getAccounts functions
- `packages/api/src/data/ynab/ynab-api.ts` - Added createScheduledTransaction function
- `packages/api/src/controllers/scheduledTransactionController.test.ts` - New test file

### Frontend
- `packages/web/app/api/scheduledTransactions.client.ts` - Added create function and types
- `packages/web/app/api/accounts.client.ts` - New file for accounts API
- `packages/web/app/budgets/[budgetUuid]/predictions/EditTransactionDialog.tsx` - Enhanced for create mode
- `packages/web/app/budgets/[budgetUuid]/predictions/FutureChangesTable.tsx` - Added create button and dialog

### Documentation
- `docs/new features/simulation-improvement-4juli/implementation.md` - This file

## Code Quality

### Reusability
- **Component Reuse**: EditTransactionDialog reused for both edit and create
- **API Pattern Consistency**: Follows existing API patterns and conventions
- **Type Safety**: Full TypeScript support with proper type definitions

### Maintainability
- **Clear Separation**: Clean separation between edit and create logic
- **Consistent Naming**: Follows existing naming conventions
- **Documentation**: Comprehensive comments and documentation

### Performance
- **Lazy Loading**: Accounts loaded only when create dialog opens
- **Efficient State Management**: Minimal re-renders and state updates
- **Optimized API Calls**: Only necessary API calls made

## Security Considerations

### Input Validation
- All user inputs are validated on both client and server side
- SQL injection prevention through proper data handling
- XSS prevention through input sanitization

### Authentication
- JWT token validation on all endpoints
- User session validation
- Budget ownership verification

### Authorization
- Users can only create transactions in budgets they own
- Proper error handling without information leakage

## Future Enhancements

### Potential Improvements
1. **Account Caching**: Cache accounts to reduce API calls
2. **Form Validation**: Enhanced client-side validation
3. **Success Notifications**: Toast notifications for successful operations
4. **Bulk Creation**: Support for creating multiple transactions
5. **Templates**: Save and reuse transaction templates

### Integration Points
- **Real-time Updates**: Integration with WebSocket for real-time updates
- **Audit Logging**: Track transaction creation for audit purposes
- **Analytics**: Track usage patterns for UX improvements

## Testing Strategy

### Unit Tests
-  Controller validation tests
-  Authentication/authorization tests
-  Input sanitization tests
-  Error handling tests

### Integration Tests (Recommended)
- API endpoint integration tests
- Frontend component integration tests
- End-to-end user flow tests

### Manual Testing Checklist
- [ ] Create transaction with all fields
- [ ] Create transaction with only required fields
- [ ] Validate error handling for invalid inputs
- [ ] Test account selection functionality
- [ ] Verify security restrictions work correctly

## Deployment Notes

### Prerequisites
- Node.js API must be running
- YNAB API access configured
- Database connection established
- Authentication service configured

### Configuration
- No additional configuration required
- Uses existing YNAB API configuration
- Leverages existing authentication setup

### Monitoring
- Monitor API response times for create endpoint
- Track error rates for validation failures
- Monitor user adoption of the feature
</file>

<file path="docs/new features/simulation-improvement-4juli/specs.md">
# Simulation improvement for 4th of juli 2025

# add scheduled transactions

- make sure you can add scheduled transactions in the same way as for the edit. see screenshot:![ edit-add-transaction.png](edit-add-transaction.png)
- reuse code
- add unit tests for api
- be able to add it from prediction homepage
</file>

<file path="docs/new features/0-template.md">
# [Feature Name]

For development guidelines, refer to [Best Practices](../best-practices.md)

## Current status
- Technical situation (what exists now?)
- Business impact (what problems does this cause?)
- Metrics (if available)
- User experience issues
- Performance/security concerns

## Wanted status
- Technical requirements
- Business goals
- Success metrics (how do we measure improvement?)
- User experience improvements
- Expected outcomes

## Implementation Steps

### 1. [First Major Step]
- [ ] Task 1
- [ ] Task 2
```[language]
// Example code or configuration if applicable
```

### 2. [Second Major Step]
- [ ] Task 1
- [ ] Task 2

## Technical Decisions
- What technology choices are made?
- Why these choices?
- What alternatives were considered?

### Example Implementation (if applicable)
```[language]
// Example code showing how to implement
```

## First Milestone
1. First achievable goal
2. Second achievable goal
3. What constitutes MVP?

## Impact
- What improves?
- What might break?
- Performance implications?
- Security implications?

## Dependencies
- What needs to be in place?
- Which other features are required?
- External dependencies?
- Team knowledge requirements?
</file>

<file path="docs/new features/ai-automatic-categorisation.md">
# AI Automatic Categorization

For development guidelines, refer to [Best Practices](../best-practices.md)

## Current status
- Google Cloud API calls web API with secret, which then calls the private API to update budgets

## Wanted status
- The private API calls the math-api for each budget:
POST http://127.0.0.1:5000/uncategorised-transactions/apply-categories?budget_id=1b443ebf-ea07-4ab7-8fd5-9330bf80608c
This ensures categories are kept up to date automatically

## Todo
- [ ] Ensure math-api is accessible from private API in Kubernetes (but not exposed publicly)
- [ ] Implement asynchronous API calls for each budget during sync process
</file>

<file path="docs/new features/predictions-page.md">
# Predictions Page

## Current Status
- Balance prediction graph only visible on budget overview page
- Graph is relatively small and shares space with other components
- Future changes (salary, fixed costs etc.) are not clearly visible
- Limited interaction possibilities with the graph

## Wanted Status
- Dedicated predictions page for each budget
- Large, interactive graph utilizing full width
- Table view of future changes (similar to transactions page):
  - Date
  - Description
  - Amount
  - Type (income/expense)
  - Balance impact
- Ability to select different time periods
- Option to filter specific categories

## Implementation Steps
1. Create new route: `/budgets/[budget_id]/predictions`
2. Create predictions page component:
   ```tsx
   // Layout structure
   <div>
     <PredictionGraph />
     <FutureChangesTable changes={predictionData.changes} />
   </div>
   ```
3. Adapt graph component:
   - Use full width
   - Add zoom/pan controls
   - Improve tooltips
4. Create table component for future changes:
   - Reuse transactions table styling
   - Date-based sorting
   - Filtering options
   - Group changes by date
   - Show running balance
5. Add navigation from budget overview

## Technical Decisions
- Reuse existing transactions table styling for consistency
- Adjust Chart.js configuration for larger display
- Share TypeScript types between components
- Apply responsive design principles
- **Reuse existing `/balance-prediction/data` endpoint** which already provides all necessary data:
  ```typescript
  type PredictionData = {
    [simulationName: string]: {
      [date: string]: {
        balance: number;
        balance_diff: number;
        changes: Array<{
          amount: number;
          category: string;
          reason: string;
          is_simulation?: boolean;
          memo?: string;
        }>;
      };
    };
  };
  ```

## First Milestone
1. [ ] Route and basic page structure
2. [ ] Large graph implementation
3. [ ] Basic table for future changes
4. [ ] Navigation from budget overview

## Impact
- Better visualization of financial predictions
- More insight into future changes
- Improved user experience
- Reuse of existing components

## Dependencies
- Existing transactions page components
- Math API predictions endpoint
- Budget routes and authentication
- Chart.js library

## UX Navigation Flow
1. From Budget Overview:
   - Add "View Details" button next to the prediction chart title
   - Add "Predictions" tab in the main navigation menu
   - Add "" icon button in the chart corner for quick access

2. Interactive Elements:
   ```tsx
   // In MonthTotalOverview component
   <div className="flex justify-between items-center mb-4">
     <h2>Balance Prediction</h2>
     <Link 
       href={`/budgets/${budgetUuid}/predictions`}
       className="btn btn-primary btn-sm"
     >
       View Details
     </Link>
   </div>
   ```

3. Visual Feedback:
   - Highlight the prediction section on hover
   - Add tooltip: "Click for detailed predictions"
   - Smooth transition animation when switching views

4. Mobile Considerations:
   - Full-width tap target for better accessibility
   - Bottom navigation bar option for quick access
   - Swipe gestures for chart interaction

## Development Practices
- Test responsive design on various screen sizes
- Check accessibility for graph and table
- Performance optimization for large datasets
- Unit tests for new components
</file>

<file path="docs/new features/production-kubernetes.md">
# Production Kubernetes Configuration

For development guidelines, refer to [Best Practices](../best-practices.md)

## Current status
- Single replica deployments
- Basic health checks
- No pod disruption budgets
- Simple rolling updates
- Potential downtime during deployments
- Services can be temporarily unavailable during startup

## Wanted status
- Zero-downtime deployments
- High availability for all services
- Proper resource management
- Graceful service handling
- Automatic recovery from failures
- Production-grade monitoring

## Implementation Steps

### 1. High Availability Setup
- [ ] Configure multiple replicas for each service
```yaml
spec:
  replicas: 3  # Minimum for production
```
- [ ] Implement pod disruption budgets
```yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: budget-api-pdb
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: budget-api-app
```
- [ ] Configure pod anti-affinity for spreading across nodes
```yaml
spec:
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app
              operator: In
              values:
              - budget-api-app
          topologyKey: kubernetes.io/hostname
```

### 2. Resource Management
- [ ] Define resource requests and limits
```yaml
resources:
  requests:
    cpu: 100m
    memory: 256Mi
  limits:
    cpu: 500m
    memory: 512Mi
```
- [ ] Implement horizontal pod autoscaling
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: budget-api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: budget-api-app
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 80
```

### 3. Improved Health Checks
- [ ] Enhanced readiness probes
```yaml
readinessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5
  failureThreshold: 3
  successThreshold: 1
```
- [ ] Enhanced liveness probes
```yaml
livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 15
  periodSeconds: 10
  failureThreshold: 3
  timeoutSeconds: 5
```

### 4. Rolling Update Strategy
- [ ] Configure rolling update strategy
```yaml
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0
```
- [ ] Add preStop hooks for graceful shutdown
```yaml
lifecycle:
  preStop:
    exec:
      command: ["/bin/sh", "-c", "sleep 10"]
```

### 5. Network Policies
- [ ] Implement network policies for service isolation
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-network-policy
spec:
  podSelector:
    matchLabels:
      app: budget-api-app
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: budget-web-app
    ports:
    - protocol: TCP
      port: 4000
```

## First Milestone
1. Implement multiple replicas
2. Add pod disruption budgets
3. Configure proper resource limits
4. Enhance health checks
5. Test rolling updates

## Impact
- Zero-downtime deployments
- Better resource utilization
- Improved reliability
- Automatic scaling
- Better isolation between services

## Dependencies
- Kubernetes cluster with multiple nodes
- Resource monitoring setup
- Network policy support
- Horizontal Pod Autoscaling controller
</file>

<file path="docs/ENDPOINT_MIGRATION.md">
# Endpoint Migration: Python to Node.js

This document describes the migration of simple MongoDB CRUD endpoints from the Python mathapi to the Node.js API, completed in June 2025.

##  Migration Goals

- **Consolidate simple operations**: Move MongoDB-only operations to Node.js
- **Keep AI/ML in Python**: Maintain complex AI processing in Python where it belongs
- **Improve performance**: Reduce network calls between services
- **Better type safety**: Leverage TypeScript for data operations
- **Clear separation of concerns**: Node.js for CRUD, Python for AI/ML

##  Migrated Endpoints

###  Successfully Migrated to Node.js API

| Old Python Endpoint                                              | New Node.js Endpoint                             | Frontend Usage                                  | Description                                      |
| ---------------------------------------------------------------- | ------------------------------------------------ | ----------------------------------------------- | ------------------------------------------------ |
| `GET /uncategorised-transactions?budget_id=X`                    | `GET /budgets/{uuid}/uncategorized-transactions` |  **Active** - Categorization page             | Get transactions without categories via YNAB API |
| `GET /unapproved-transactions?budget_id=X`                       | `GET /budgets/{uuid}/unapproved-transactions`    |  **Active** - Categorization page             | Get transactions needing approval via YNAB API   |
| `GET /uncategorised-transactions/suggestions-cached?budget_id=X` | `GET /budgets/{uuid}/ai-suggestions/cached`      |  **Not used** - Replaced by combined endpoint | Get cached AI suggestions from transaction level |

###  Remaining Active Python API Endpoints

| Endpoint                                                | Usage                             | Reason                            |
| ------------------------------------------------------- | --------------------------------- | --------------------------------- |
| `GET /balance-prediction/data`                          | Budget overview, predictions page | Complex NumPy/pandas calculations |
| `GET /sheduled-transactions`                            | Budget overview                   | YNAB API wrapper                  |
| `GET /uncategorised-transactions/suggest-categories`    | Categorization page               | OpenAI API integration            |
| `POST /uncategorised-transactions/suggestions-async`    | Categorization page               | AI processing with OpenAI         |
| `POST /uncategorised-transactions/suggest-single`       | Categorization page               | Real-time AI suggestions          |
| `POST /uncategorised-transactions/apply-single`         | Categorization, transactions page | YNAB API + learning logic         |
| `POST /uncategorised-transactions/apply-categories`     | Categorization page               | YNAB API + AI integration         |
| `POST /uncategorised-transactions/apply-all-categories` | Categorization page               | Complex business logic            |
| `POST /transactions/approve-single`                     | Categorization page               | YNAB API transaction approval     |
| `POST /transactions/approve-all`                        | Categorization page               | Mass transaction approval         |

##  Removed Endpoints (15 total)

### Payee Mappings (5 endpoints) -  Not used by frontend

- `GET /payee-mappings/{budget_id}`
- `POST /payee-mappings/{budget_id}`
- `DELETE /payee-mappings/{budget_id}/{payee_name}`
- `GET /payee-mappings/{budget_id}/search`
- `GET /payee-mappings/{budget_id}/stats`

### Batch/Smart Processing (7 endpoints) -  Experimental features, not used

- `GET /uncategorised-transactions/suggest-categories-batch`
- `POST /uncategorised-transactions/apply-categories-batch`
- `POST /uncategorised-transactions/start-batch-job`
- `GET /batch-jobs/{batch_id}/status`
- `POST /batch-jobs/{batch_id}/apply-results`
- `GET /uncategorised-transactions/suggest-categories-smart`
- `POST /uncategorised-transactions/apply-categories-smart`

### Country Config (3 endpoints) -  Only used in tests, not production

- `GET /config/countries`
- `GET /config/countries/{country_code}`
- `POST /config/detect-country`

##  Implementation Details

### Node.js API Structure

```
packages/api/src/
 controllers/aiSuggestionsController.ts    # New controller for migrated endpoints
 data/transaction/transaction.server.ts    # Extended with AI cache functions
 data/ynab/ynab-api.ts                    # YNAB API integration
 routes/budgetRoutes.ts                    # Updated with new routes
```

### Frontend API Client

```
packages/web/app/api/
 ai-suggestions.server.ts                  # New client for Node.js endpoints
 math.server.ts                           # Re-exports migrated endpoints
```

### Database Schema Changes

AI suggestions now cached at transaction level using Python-compatible fields:

```typescript
// LocalTransaction schema additions
ai_suggested_category: String,     // Category name suggested by AI
ai_suggestion_date: Date,          // When suggestion was made
ai_suggestion_confidence: Number,  // AI confidence score
_cache_only: Boolean              // Mark cache-only documents
```

##  Migration Architecture

### Before Migration

```
Frontend  Python API (25 endpoints)
         
    MongoDB + YNAB API + OpenAI
```

### After Migration

```
Frontend  Node.js API (CRUD) + Python API (AI/ML)
                             
    MongoDB + YNAB         OpenAI + Complex Logic
```

##  Performance Impact

### Async Loading Flow

```
Time: 0ms      Frontend request
Time: 200ms    Node.js: YNAB API + cached suggestions 
Time: 300ms    21 uncategorized transactions visible
Time: 500ms    User can request AI suggestions
Time: 3000ms   Python API: OpenAI + cache storage 
```

**Benefits:**

- **Fast initial load**: 200ms vs 3s+ previously
- **Progressive enhancement**: AI suggestions load asynchronously
- **Shared cache**: Both services use same MongoDB fields
- **Better UX**: Users see data immediately, AI enhances later

##  Testing

### Integration Test Results

- **Node.js endpoints**: 4/4 passed (401 = auth required, expected)
- **Python endpoints**: 3/4 passed (404 for test transaction is normal)
- **Frontend**: All pages function correctly
- **Cache**: AI suggestions stored and retrieved properly

### Manual Verification

```bash
# Test Node.js endpoints
curl "http://localhost:4000/budgets/test-budget/uncategorized-transactions" \
  -H "Authorization: Bearer YOUR_TOKEN"

# Test Python endpoints still work
curl "http://localhost:5000/balance-prediction/data?budget_id=test-budget"
```

##  Migration Results

### Before Migration

- **25 endpoints** in Python API
- **Complex mixing** of CRUD and AI operations
- **Multiple network calls** for simple operations
- **Slower initial page loads**

### After Migration

- **10 active endpoints** in Python API (focused on AI/ML)
- **3 new endpoints** in Node.js API (focused on CRUD)
- **17 unused endpoints** removed (15 Python + 2 Node.js utility)
- **Clear separation** of concerns
- **Improved performance** and user experience

##  Frontend Usage Patterns

### Budget Overview Page

- Node.js: `GET /budgets/{uuid}/overview`
- Python: `GET /balance-prediction/data`

### Categorization Page (Most Complex)

- **Node.js**: `GET /budgets/{uuid}/uncategorized-transactions` (fast initial load)
- **Node.js**: `GET /budgets/{uuid}/unapproved-transactions` (fast initial load)
- **Python**: All AI processing endpoints (async enhancement)

### Transactions Page

- Node.js: `GET /budgets/{uuid}/transactions`
- Python: `POST /uncategorised-transactions/apply-single` (via actions)

### Predictions Page

- Node.js: Simulation management endpoints
- Python: `GET /balance-prediction/data`

##  Success Criteria Met

- [x] All migrated endpoints work in Node.js API
- [x] Frontend functions correctly with transparent migration
- [x] Python API endpoints still work for AI operations
- [x] No broken imports or missing functions
- [x] Integration tests pass
- [x] Performance improved significantly
- [x] Clear separation of concerns achieved

##  Code Cleanup

### File-based Payee Mappings Removal

As part of the migration, all file-based payee mapping code was removed to ensure compatibility with multi-pod deployments:

**Removed files:**

- `packages/mathapi/app/payee_mappings.py` (file-based manager)
- `packages/mathapi/app/user_mappings/` (entire directory with JSON files)
- `packages/mathapi/app/tests/scenarios/test_payee_mappings.py`
- `packages/mathapi/app/tests/scenarios/test_realistic_payee_scenarios.py`

**Fixed regression:**

- Updated `apply_single_category` to use `MongoPayeeMappingsManager` instead of file-based manager
- Ensures payee learning works correctly in production environment

**Removed unused utility endpoints:**

- `GET /budgets/{uuid}/ai-suggestions/stats` (not used by frontend)
- `DELETE /budgets/{uuid}/ai-suggestions/cache` (not used by frontend)
- Associated controller functions and client code

**Rationale:**
File-based storage doesn't work with multiple pods/containers as each pod would have its own local files. MongoDB-based storage ensures consistency across all instances. Unused endpoints were removed to keep the codebase clean and focused.

##  Future Considerations

1. **Monitor performance** of new Node.js endpoints
2. **Consider migrating** `GET /sheduled-transactions` if beneficial
3. **Add caching** to frequently accessed YNAB data
4. **Optimize** database queries for better performance
5. **Implement rate limiting** for AI endpoints

---

**Migration completed**: June 2025
**Status**:  Production ready
**Impact**: Improved performance, better architecture, enhanced user experience
</file>

<file path="docs/simplemadeeasy.md">
Simple Made Easy: A Study Guide
I. Summary and Key Concepts
Rich Hickey's "Simple Made Easy" argues for a fundamental distinction between "simple" and "easy" in software development, asserting that true simplicity (un-braided, un-interleaved) is a prerequisite for reliability and long-term maintainability, whereas "easy" (familiar, near at hand) often leads to hidden complexity. The talk delves into the etymology of these words to highlight their precise meanings and then applies them to software constructs and design principles. Hickey advocates for a focus on objective simplicity, even if it initially feels less "easy," as it ultimately leads to more robust, understandable, and adaptable systems over time.

Key Concepts:

Simple vs. Easy: The core distinction, with "simple" meaning "one fold/braid" (objective, structural) and "easy" meaning "near" (subjective, based on familiarity or proximity).
Complexity (Complecting): The act of braiding or intertwining disparate concepts or concerns, leading to systems that are difficult to understand, reason about, or change.
Composing vs. Complecting: The ideal of placing independent, simple components together (composing) versus intertwining them (complecting).
Artifact vs. Construct: Distinguishing between the inherent qualities of a programming language feature or tool (construct) and the actual running software and its long-term implications (artifact). Hickey argues that we should assess constructs based on the simplicity of the artifacts they produce.
Incidental Complexity: Complexity introduced by the choice of tools or constructs, rather than being inherent to the problem domain. Hickey equates it to "your fault."
Benefits of Simplicity: Ease of understanding, ease of change, easier debugging, increased flexibility, and independence of decisions.
Limits of Understanding: Human cognitive limitations mean we can only hold a small number of intertwined concepts in our minds at once, making complex systems inherently difficult to grasp.
Reasoning about Programs: The necessity of informal reasoning about program behavior, which is hindered by complexity, contrasting with the often-misguided reliance on "guard rail programming" (e.g., extensive testing) that doesn't fundamentally address complexity.
Policy of Abstraction (Who, What, When, Where, Why): A design approach to abstract for simplicity by disentangling concerns based on these categories.
Declarative vs. Imperative: Favoring declarative approaches (describing what rather than how) to reduce complexity.
The Choice of Simplicity: Simplicity is not an accidental outcome but a deliberate choice requiring constant vigilance and a shift in developer sensibilities away from mere "ease of use."
II. Quiz
Answer the following questions in 2-3 sentences each.

Explain the etymological difference between "simple" and "complex" as discussed in the talk.
How does Rich Hickey define "easy," and what are the three aspects of "nearness" he identifies?
Why does Hickey assert that "simple" is an objective notion while "easy" is relative?
What is "complecting" in the context of software development, and why is it considered detrimental?
Hickey argues that developers are often "infatuated" with two notions of "easy." Describe these two notions and their negative impact.
Explain the distinction between a "construct" and an "artifact" in software. Why does Hickey emphasize assessing constructs based on their artifacts?
What is "incidental complexity," and whose "fault" is it according to Hickey?
How does state in a program contribute to complexity, and what does Hickey suggest as a better alternative?
According to Hickey, what is the role of tests and refactoring in dealing with complexity, and why are they ultimately insufficient on their own?
What is "polymorphism ala carte," and why does Hickey consider it a highly desirable, yet often esoteric, tool for achieving simplicity?
III. Quiz Answer Key
"Simple" derives from "sim" and "plex," meaning "one fold" or "one braid," implying a lack of intertwining. "Complex" means "braided together" or "folded together," indicating multiple interwoven parts. This etymology highlights the structural and objective nature of simplicity.
"Easy" is defined as "to lie near" or "to be nearby." The three aspects of nearness are physical proximity (easy to obtain), familiarity (near to our understanding/skillset), and near to our capabilities (within our current abilities).
Simplicity is objective because one can visually or structurally inspect software to determine if its parts are braided together or if there are interconnections. Ease, however, is relative because what is easy for one person (due to familiarity or skill) may be hard for another.
"Complecting" means to interleave, entwine, or braid concepts or concerns within software. It is detrimental because it makes systems difficult to understand, reason about, change, and debug, leading to a combinatorial burden on human comprehension.
Developers are infatuated with the notions of easy-to-obtain (quick installation/startup) and familiar (looks like what they already know). This fixation leads to choosing tools that might be instantly usable but generate "giant hairball" artifacts, hindering learning new, potentially simpler, approaches.
A "construct" is a programming language feature or tool (e.g., a specific syntax or library). An "artifact" is the resulting running software over its lifetime, including its performance, reliability, and changeability. Hickey argues that constructs should be chosen based on the simplicity of the artifacts they produce, not merely on programmer convenience or superficial ease of use.
Incidental complexity is complexity that arises not from the problem itself, but from the tools, constructs, or design choices made during implementation. Hickey provocatively states it's "your fault" because it's a consequence of the developer's choices rather than an inherent domain challenge.
State introduces complexity by complecting value and time, making it difficult to reason about a value independently of when it was accessed or what other operations might have occurred. Hickey advocates for values (immutability) and constructs that compose values and time, like Clojure's references, to regain simplicity.
Tests and refactoring are described as "guard rails" that provide a safety net but do not fundamentally simplify the underlying system. While they help in making changes, they don't help in reasoning about the program's behavior or guiding it towards simplicity. If the system is inherently complex, these tools become less effective over the long haul.
Polymorphism ala carte (e.g., Clojure protocols, Haskell type classes) refers to the ability to independently define data structures, sets of functions (abstractions/specifications), and then connect them. This allows for genericity that is not tied to specific implementations, providing a powerful means to achieve flexibility and disentanglement, making it simpler to combine and reuse components.
IV. Essay Format Questions
Analyze Rich Hickey's central argument regarding the distinction between "simple" and "easy." Discuss how this distinction challenges conventional notions of software development and what practical implications it has for choosing tools and designing systems.
Hickey identifies several common software constructs (e.g., state, objects, inheritance, loops) as inherently "complex" due to "complecting." Choose three of these and explain in detail how they lead to complexity according to Hickey, providing examples of the "braiding" or "intertwining" they cause.
Discuss the speaker's critique of the prevailing "culture of complexity" in programming. How does he argue that this culture is self-reinforcing, and what steps does he suggest developers can take to break out of this rut?
Hickey outlines a "policy of abstraction" using "who, what, when, where, why" as a framework for designing simple systems. Explain this framework and how applying it helps to "draw away" from complexity and facilitate more modular and understandable software.
Evaluate Hickey's perspective on the role of testing and agile methodologies (like XP and sprints) in achieving software quality. To what extent does he see them as beneficial, and where does he argue their limitations lie in addressing the core problem of complexity?
V. Glossary of Key Terms
Simple: (Etymological root: sim-plex - one fold/braid) Refers to something that is un-braided, un-interleaved, or un-tangled. It is an objective quality of a system or component, characterized by having one role, one task, or one objective, and a clear focus without combining disparate things.
Complex: (Etymological root: com-plex - braided/folded together) Refers to something that is intertwined, inter-dependent, or braided together. It is the opposite of simple and creates systems that are difficult to understand, reason about, and change.
Easy: (Etymological root: Latin for "adjacent" or "to lie near") Refers to something that is near to our physical reach, near to our understanding (familiar), or near to our capabilities. It is a subjective and relative quality, often confused with simplicity.
Complect (verb): An archaic word revived by Hickey meaning "to interleave, entwine, or braid." It describes the act of introducing complexity by mixing disparate concerns.
Compose (verb): To place things together. In software, it refers to assembling independent, simple components, which is contrasted with complecting.
Construct: A specific feature, tool, or syntax provided by a programming language or library (e.g., an object, a loop, a method).
Artifact: The actual running software system, including its long-term behavior, performance, reliability, and ease of change, which is the ultimate output of using constructs.
Incidental Complexity: Complexity that arises not from the inherent nature of the problem being solved, but from the chosen tools, constructs, or implementation decisions. Hickey describes it as "your fault."
Environmental Complexity: Complexity that is inherent to the execution environment (e.g., contention for memory or CPU cycles in a shared system) and is not directly within the control of the software designer, but still impacts the artifact.
Values: Immutable data; data that does not change over time. Hickey argues that using values helps prevent complecting time and value, leading to simpler systems.
State: Mutable data; data whose value can change over time. Hickey views state as inherently complex because it "complects value in time," making reasoning difficult.
Polymorphism Ala Carte: A design approach (exemplified by Clojure protocols or Haskell type classes) where data structures, function definitions, and their connections are managed independently, allowing for flexible and un-tangled genericity.
Abstraction (Hickey's definition): To draw something away, particularly from its physical nature. It involves forming sets of functions or specifications that are small and focused, without dictating how they are implemented.
Declarative Programming: A programming paradigm that focuses on describing what a program should accomplish rather than how it should accomplish it. Hickey favors declarative approaches (e.g., SQL, Datalog, rule systems) for their simplicity compared to imperative methods.
Guard Rail Programming: A metaphor used to describe an over-reliance on safety nets like extensive testing, type checkers, and refactoring tools without fundamentally addressing the underlying complexity of the software. It helps prevent crashes but doesn't guide towards simplicity.
Sensibilities: The intuitive understanding and awareness that developers should cultivate to recognize "complecting" and interconnections in software that could be independent.
</file>

<file path="kube/config/dev/mathapi-config.yml">
apiVersion: v1
kind: ConfigMap
metadata:
  name: budget-mathapi-dev-config
  namespace: dev
data:
  PYTHONPATH: "/app"
  FLASK_APP: "app/app.py"
  FLASK_ENV: "production"
  FLASK_DEBUG: "0"
  API_SERVICE_URL: "http://budget-api-service:4000"
  CORS_ORIGINS: "https://budget-dev.vandenit.be"
</file>

<file path="kube/dev/mathapi-deployment.yml">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: budget-mathapi-app
  namespace: dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: budget-mathapi
  template:
    metadata:
      labels:
        app: budget-mathapi
    spec:
      containers:
        - name: budget-mathapi
          image: filipvdb321/budget-mathapi:2f6844e6f23c516ad8225b3e90599abdb3111446
          ports:
            - containerPort: 5000
          env:
            - name: PYTHONPATH
              value: /app
            - name: FLASK_APP
              value: app/app.py
            - name: FLASK_ENV
              value: production
            - name: FLASK_DEBUG
              value: "0"
          envFrom:
            - secretRef:
                name: mathapi-secrets
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "200m"
          readinessProbe:
            httpGet:
              path: /health
              port: 5000
            initialDelaySeconds: 10
            periodSeconds: 5
          livenessProbe:
            httpGet:
              path: /health
              port: 5000
            initialDelaySeconds: 15
            periodSeconds: 20
</file>

<file path="kube/dev/mathapi-service.yml">
apiVersion: v1
kind: Service
metadata:
  name: budget-mathapi-service
  namespace: dev
spec:
  selector:
    app: budget-mathapi
  ports:
    - protocol: TCP
      port: 5000
      targetPort: 5000
  type: ClusterIP
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="packages/api/src/controllers/scheduledTransactionController.test.ts">
import { describe, it, vi, expect, beforeEach, afterEach } from "vitest";
import { create } from "./scheduledTransactionController";
import { Response } from "express";

const createMockResponse = () => {
  const res: Partial<Response> = {};
  res.json = vi.fn().mockReturnValue(res);
  res.status = vi.fn().mockReturnValue(res);
  return res as Response;
};

const mocks = vi.hoisted(() => {
  return {
    getUserFromReq: vi.fn(),
    getBudget: vi.fn(),
    createScheduledTransaction: vi.fn(),
  };
});

vi.mock("./utils", () => ({
  getUserFromReq: mocks.getUserFromReq,
}));

vi.mock("../data/budget/budget.server", () => ({
  getBudget: mocks.getBudget,
}));

vi.mock("../data/ynab/ynab.server", () => ({
  createScheduledTransaction: mocks.createScheduledTransaction,
}));

const mockUser = {
  _id: "user123",
  authId: "auth123",
  name: "Test User",
};

const mockBudget = {
  _id: "budget123",
  uuid: "budget-uuid-123",
  name: "Test Budget",
};

const mockCreatedTransaction = {
  id: "transaction123",
  account_id: "account123",
  category_id: "category123",
  payee_name: "Test Payee",
  memo: "Test memo",
  amount: 10000, // In milliunits
  date: "2024-01-15",
  frequency: "never",
};

describe("scheduledTransactionController.create", () => {
  let res: Response;

  beforeEach(() => {
    res = createMockResponse();
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it("should create a scheduled transaction successfully", async () => {
    // Arrange
    const req: any = {
      params: { uuid: "budget-uuid-123" },
      body: {
        amount: 100,
        categoryId: "category123",
        date: "2024-01-15",
        payeeName: "Test Payee",
        memo: "Test memo",
        accountId: "account123",
      },
    };

    mocks.getUserFromReq.mockResolvedValue(mockUser);
    mocks.getBudget.mockResolvedValue(mockBudget);
    mocks.createScheduledTransaction.mockResolvedValue(mockCreatedTransaction);

    // Act
    await create(req, res);

    // Assert
    expect(mocks.getUserFromReq).toHaveBeenCalledWith(req);
    expect(mocks.getBudget).toHaveBeenCalledWith("budget-uuid-123", mockUser);
    expect(mocks.createScheduledTransaction).toHaveBeenCalledWith(
      mockUser,
      "budget-uuid-123",
      {
        amount: 100,
        categoryId: "category123",
        date: "2024-01-15",
        payeeName: "Test Payee",
        memo: "Test memo",
        accountId: "account123",
      }
    );
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.json).toHaveBeenCalledWith(mockCreatedTransaction);
  });

  it("should throw error when user is not found", async () => {
    // Arrange
    const req: any = {
      params: { uuid: "budget-uuid-123" },
      body: {
        amount: 100,
        categoryId: "category123",
        date: "2024-01-15",
        accountId: "account123",
      },
    };

    mocks.getUserFromReq.mockResolvedValue(null);

    // Act & Assert
    await expect(create(req, res)).rejects.toThrow("no user found");
  });

  it("should throw error when budget is not found", async () => {
    // Arrange
    const req: any = {
      params: { uuid: "budget-uuid-123" },
      body: {
        amount: 100,
        categoryId: "category123",
        date: "2024-01-15",
        accountId: "account123",
      },
    };

    mocks.getUserFromReq.mockResolvedValue(mockUser);
    mocks.getBudget.mockResolvedValue(null);

    // Act & Assert
    await expect(create(req, res)).rejects.toThrow(
      "budget budget-uuid-123 does not belong to user"
    );
  });

  it("should throw error when required fields are missing", async () => {
    // Arrange
    const req: any = {
      params: { uuid: "budget-uuid-123" },
      body: {
        // Missing required fields
        categoryId: "category123",
        date: "2024-01-15",
      },
    };

    mocks.getUserFromReq.mockResolvedValue(mockUser);
    mocks.getBudget.mockResolvedValue(mockBudget);

    // Act & Assert
    await expect(create(req, res)).rejects.toThrow(
      "Missing required fields: amount, categoryId, date, accountId"
    );
  });

  it("should throw error when amount is not a valid number", async () => {
    // Arrange
    const req: any = {
      params: { uuid: "budget-uuid-123" },
      body: {
        amount: "invalid",
        categoryId: "category123",
        date: "2024-01-15",
        accountId: "account123",
      },
    };

    mocks.getUserFromReq.mockResolvedValue(mockUser);
    mocks.getBudget.mockResolvedValue(mockBudget);

    // Act & Assert
    await expect(create(req, res)).rejects.toThrow(
      "Amount must be a valid number"
    );
  });

  it("should throw error when date format is invalid", async () => {
    // Arrange
    const req: any = {
      params: { uuid: "budget-uuid-123" },
      body: {
        amount: 100,
        categoryId: "category123",
        date: "invalid-date",
        accountId: "account123",
      },
    };

    mocks.getUserFromReq.mockResolvedValue(mockUser);
    mocks.getBudget.mockResolvedValue(mockBudget);

    // Act & Assert
    await expect(create(req, res)).rejects.toThrow(
      "Date must be in YYYY-MM-DD format"
    );
  });

  it("should sanitize string inputs", async () => {
    // Arrange
    const req: any = {
      params: { uuid: "budget-uuid-123" },
      body: {
        amount: 100,
        categoryId: "  category123  ",
        date: "2024-01-15", // Date validation happens before trimming, so no spaces
        payeeName: "  Test Payee  ",
        memo: "  Test memo  ",
        accountId: "  account123  ",
      },
    };

    mocks.getUserFromReq.mockResolvedValue(mockUser);
    mocks.getBudget.mockResolvedValue(mockBudget);
    mocks.createScheduledTransaction.mockResolvedValue(mockCreatedTransaction);

    // Act
    await create(req, res);

    // Assert
    expect(mocks.createScheduledTransaction).toHaveBeenCalledWith(
      mockUser,
      "budget-uuid-123",
      {
        amount: 100,
        categoryId: "category123",
        date: "2024-01-15", // Date is not trimmed in this test since it has no spaces
        payeeName: "Test Payee",
        memo: "Test memo",
        accountId: "account123",
      }
    );
  });

  it("should handle optional fields correctly", async () => {
    // Arrange
    const req: any = {
      params: { uuid: "budget-uuid-123" },
      body: {
        amount: 100,
        categoryId: "category123",
        date: "2024-01-15",
        accountId: "account123",
        // No payeeName or memo
      },
    };

    mocks.getUserFromReq.mockResolvedValue(mockUser);
    mocks.getBudget.mockResolvedValue(mockBudget);
    mocks.createScheduledTransaction.mockResolvedValue(mockCreatedTransaction);

    // Act
    await create(req, res);

    // Assert
    expect(mocks.createScheduledTransaction).toHaveBeenCalledWith(
      mockUser,
      "budget-uuid-123",
      {
        amount: 100,
        categoryId: "category123",
        date: "2024-01-15",
        payeeName: undefined,
        memo: undefined,
        accountId: "account123",
      }
    );
  });
});
</file>

<file path="packages/api/src/controllers/syncController.ts">
import { Request, Response } from "express";
import { syncBudgetData } from "../data/sync/sync.server";

const containsSecret = (request: Request) => {
  const secret = process.env.SYNC_SECRET;
  const requestSecret = request.headers["x-sync-secret"];
  return secret === requestSecret;
};

export const handleSyncBudgetData = async (req: Request, res: Response) => {
  // get user from database
  if (!containsSecret(req)) {
    return res.status(401).send("Unauthorized");
  }
  const nbrOfSyncedUsers = await syncBudgetData();
  res.json({
    nbrOfSyncedUsers,
  });
};
</file>

<file path="packages/api/src/controllers/userController.ts">
import { UserView } from "common-ts";
import {
  connectUserWithYnab,
  createOrUpdateUser,
  savePreferredBudget,
} from "../data/user/user.server";
import { getUserFromReq } from "./utils";
import { Request, Response } from "express";
import { isYnabTokenExpired } from "../data/ynab/ynab-api";

export const handleConnectUserWithYnab = async (
  req: Request,
  res: Response
) => {
  const user = await getUserFromReq(req);
  if (!user) {
    console.error("no user found");
    return res.status(401).send("Unauthorized");
  }
  const connection = req.body;
  await connectUserWithYnab(connection, user);
  res.send({ success: true });
};

export const handleCreateOrUpdateUser = async (req: Request, res: Response) => {
  const { authId, name } = req.body;
  await createOrUpdateUser({ authId, name });
  res.send({ success: true });
};

export const handleGetLoggedInUser = async (req: Request, res: Response) => {
  const user = await getUserFromReq(req);
  if (!user) {
    console.error("no user found");
    return res.status(401).send("Unauthorized");
  }
  const hasYnabConnection = !!user.ynab?.connection;
  const isTokenExpired =
    hasYnabConnection && (await isYnabTokenExpired(user));

  const userView: UserView = {
    authId: user.authId,
    name: user.name,
    createdAt: user.createdAt,
    updatedAt: user.updatedAt,
    settings: user.settings,
    ynab: {
      isConnected: hasYnabConnection,
      isTokenExpired,
    },
  };
  res.json(userView);
};

export const handleSavePreferredBudget = async (
  req: Request,
  res: Response
) => {
  const user = await getUserFromReq(req);
  if (!user) {
    console.error("no user found");
    return res.status(401).send("Unauthorized");
  }
  const { budgetUuid } = req.body;
  await savePreferredBudget(budgetUuid, user.authId);
  return res.send({ success: true });
};
</file>

<file path="packages/api/src/controllers/utils.ts">
import { UserType, getUserByAuthId } from "../data/user/user.server";
import { Request, Response } from "express";

export const handleRequest =
  (handler: any) => async (req: Request, res: Response) => {
    const startTime = Date.now();
    const requestId = Math.random().toString(36).substring(7);

    // Log incoming request
    console.log(` [${requestId}] ${req.method} ${req.url} - ${handler.name}`);
    if (req.method !== "GET" && Object.keys(req.body || {}).length > 0) {
      console.log(
        ` [${requestId}] Request body:`,
        JSON.stringify(req.body, null, 2)
      );
    }

    try {
      await handler(req, res);

      // Log completion with status code awareness
      const duration = Date.now() - startTime;
      const statusCode = res.statusCode;

      if (statusCode >= 400) {
        console.log(
          ` [${requestId}] ${req.method} ${req.url} completed with status ${statusCode} in ${duration}ms`
        );
      } else {
        console.log(
          ` [${requestId}] ${req.method} ${req.url} completed in ${duration}ms`
        );
      }
    } catch (exception) {
      // Log error with full details
      const duration = Date.now() - startTime;
      console.error(
        ` [${requestId}] Error handling ${req.method} ${req.url} after ${duration}ms`
      );
      console.error(` [${requestId}] Handler: ${handler.name}`);
      console.error(` [${requestId}] Exception:`, exception);
      console.error(
        ` [${requestId}] Stack:`,
        exception instanceof Error ? exception.stack : "No stack trace"
      );

      // Send generic error response
      res.status(500).json({
        error: "Internal Server Error",
        requestId: requestId,
        details:
          exception instanceof Error ? exception.message : "Unknown error",
      });
    }
  };

export const getUserFromReq = async (req: any): Promise<UserType | null> => {
  // get user sub from authorization header
  console.log(`userId: ${req.auth.payload.sub}`);
  const authId = req?.auth?.payload?.sub;
  if (!authId) {
    return null;
  }
  // get user from database
  const user = await getUserByAuthId(authId);
  if (!user) {
    return null;
  }
  return user;
};
</file>

<file path="packages/api/src/data/accounts/account.server.ts">
import connectDb from "../db";
import { LocalAccount, LocalAccountType } from "./account.schema";

export const getAccount = async (
  uuid: string
): Promise<LocalAccountType | null> => {
  const localAccount = await LocalAccount.findOne({ uuid });
  return localAccount;
};

export const findAccounts = async (
  budgetId: string
): Promise<LocalAccountType[]> => {
  await connectDb();
  const accounts = await LocalAccount.find({ budgetId }).exec();
  return accounts;
};

export const saveNewAccount = async (account: LocalAccountType) => {
  connectDb();
  const localAccount = new LocalAccount({
    uuid: account.uuid,
    name: account.name,
    balance: account.balance,
    cleared_balance: account.cleared_balance,
    uncleared_balance: account.uncleared_balance,
    budgetId: account.budgetId,
  });
  await localAccount.save();
};

export const updateAccount = async (account: LocalAccountType) => {
  connectDb();
  await LocalAccount.updateOne(
    { _id: account._id },
    {
      name: account.name,
      balance: account.balance,
      cleared_balance: account.cleared_balance,
      uncleared_balance: account.uncleared_balance,
    }
  ).exec();
};

export const deleteAccount = async (uuid: string) => {
  connectDb();
  await LocalAccount.deleteOne({ uuid }).exec();
};
</file>

<file path="packages/api/src/data/transaction/transaction.server.test.ts">
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { findTransactions, getAllCachedAISuggestionsForBudget } from "./transaction.server";
import { LocalTransaction } from "./transaction.schema";

const mocks = vi.hoisted(() => {
  return {
    connectDb: vi.fn(),
  };
});

vi.mock("../db", () => ({
  default: mocks.connectDb,
}));

mocks.connectDb.mockResolvedValue(null);

const mockDbTransactions = [
  {
    uuid: "1",
    accountName: "Account 1",
    amount: 1000,
    date: "2022-01-01T00:00:00Z",
    categoryId: "1",
    payeeName: "Payee 1",
    memo: "Memo 1",
  },
];

describe("findTransactions", () => {
  const sortMock = vi.fn();
  const findMock = vi.fn();
  vi.mocked(LocalTransaction).find = findMock;

  beforeEach(() => {
    findMock.mockReturnValue({
      sort: sortMock,
    });

    sortMock.mockResolvedValue(mockDbTransactions);
  });

  it("should find the transactions with the correct filter if date is given", async () => {
    // Arrange
    const budgetId = "2";
    const dateString = "2022-02";

    // Act
    const result = await findTransactions(budgetId, dateString);

    // Assert
    expect(Array.isArray(result)).toBe(true);
    expect(result.length).toBe(1);

    expect(findMock).toHaveBeenCalledWith({
      budgetId,
      date: { $regex: `^${dateString}` },
    });
    expect(sortMock).toHaveBeenCalledWith({ date: -1 });
  });

  it("should find the transactions with the correct filter if no date info is given", async () => {
    // Arrange
    const budgetId = "2";

    // Act
    const result = await findTransactions(budgetId);

    // Assert
    expect(Array.isArray(result)).toBe(true);
    expect(result.length).toBe(1);

    expect(findMock).toHaveBeenCalledWith({
      budgetId,
      date: { $exists: true },
    });
  });

  it("should use import_payee_name_original as payeeName when available", async () => {
    // Arrange
    const budgetId = "2";
    const mockTransactionsWithOriginal = [
      {
        uuid: "1",
        accountName: "Account 1",
        amount: 1000,
        date: "2022-01-01T00:00:00Z",
        categoryId: "1",
        payeeName: "PayPal",
        import_payee_name_original: "PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL",
        memo: "Memo 1",
      },
    ];

    sortMock.mockResolvedValueOnce(mockTransactionsWithOriginal);

    // Act
    const result = await findTransactions(budgetId);

    // Assert
    expect(result).toHaveLength(1);
    expect(result[0].payeeName).toBe("PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL");
    expect(result[0].cleanPayeeName).toBe("PayPal");
    expect(result[0].import_payee_name_original).toBe("PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL");
  });

  it("should fallback to payeeName when import_payee_name_original is not available", async () => {
    // Arrange
    const budgetId = "2";
    const mockTransactionsWithoutOriginal = [
      {
        uuid: "1",
        accountName: "Account 1",
        amount: 1000,
        date: "2022-01-01T00:00:00Z",
        categoryId: "1",
        payeeName: "PayPal",
        import_payee_name_original: null,
        memo: "Memo 1",
      },
    ];

    sortMock.mockResolvedValueOnce(mockTransactionsWithoutOriginal);

    // Act
    const result = await findTransactions(budgetId);

    // Assert
    expect(result).toHaveLength(1);
    expect(result[0].payeeName).toBe("PayPal");
    expect(result[0].cleanPayeeName).toBe("PayPal");
    expect(result[0].import_payee_name_original).toBe(null);
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });
});

describe("getAllCachedAISuggestionsForBudget", () => {
  const sortMock = vi.fn();
  const limitMock = vi.fn();
  const findMock = vi.fn();

  beforeEach(() => {
    vi.mocked(LocalTransaction).find = findMock;
    findMock.mockReturnValue({
      sort: sortMock,
    });
    sortMock.mockReturnValue({
      limit: limitMock,
    });
  });

  it("should use import_payee_name_original as payee_name when available", async () => {
    // Arrange
    const budgetId = "test-budget-id";
    const mockTransactions = [
      {
        uuid: "tx-1",
        payeeName: "PayPal",
        import_payee_name_original: "PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL",
        ai_suggested_category: "Online Services",
        ai_suggestion_confidence: 0.9,
        ai_suggestion_date: new Date("2023-01-01"),
      },
    ];

    limitMock.mockResolvedValue(mockTransactions);

    // Act
    const result = await getAllCachedAISuggestionsForBudget(budgetId);

    // Assert
    expect(result).toHaveLength(1);
    expect(result[0].transaction_id).toBe("tx-1");
    expect(result[0].payee_name).toBe("PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL");
    expect(result[0].suggested_category_name).toBe("Online Services");
    expect(result[0].confidence).toBe(0.9);
  });

  it("should fallback to payeeName when import_payee_name_original is not available", async () => {
    // Arrange
    const budgetId = "test-budget-id";
    const mockTransactions = [
      {
        uuid: "tx-2",
        payeeName: "PayPal",
        import_payee_name_original: null,
        ai_suggested_category: "Online Services",
        ai_suggestion_confidence: 0.8,
        ai_suggestion_date: new Date("2023-01-01"),
      },
    ];

    limitMock.mockResolvedValue(mockTransactions);

    // Act
    const result = await getAllCachedAISuggestionsForBudget(budgetId);

    // Assert
    expect(result).toHaveLength(1);
    expect(result[0].transaction_id).toBe("tx-2");
    expect(result[0].payee_name).toBe("PayPal");
    expect(result[0].suggested_category_name).toBe("Online Services");
    expect(result[0].confidence).toBe(0.8);
  });

  it("should handle empty payeeName gracefully", async () => {
    // Arrange
    const budgetId = "test-budget-id";
    const mockTransactions = [
      {
        uuid: "tx-3",
        payeeName: null,
        import_payee_name_original: null,
        ai_suggested_category: "Unknown",
        ai_suggestion_confidence: 0.5,
        ai_suggestion_date: new Date("2023-01-01"),
      },
    ];

    limitMock.mockResolvedValue(mockTransactions);

    // Act
    const result = await getAllCachedAISuggestionsForBudget(budgetId);

    // Assert
    expect(result).toHaveLength(1);
    expect(result[0].transaction_id).toBe("tx-3");
    expect(result[0].payee_name).toBe("");
    expect(result[0].suggested_category_name).toBe("Unknown");
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });
});
</file>

<file path="packages/api/src/models/simulation.ts">
import { Schema, model, Document, Types } from 'mongoose';

interface ICategoryChange {
  categoryId: Types.ObjectId;
  startDate: Date;
  endDate: Date;
  targetAmount: number;
}

export interface ISimulation extends Document {
  budgetId: Types.ObjectId;
  name: string;
  isActive: boolean;
  categoryChanges: ICategoryChange[];
}

const categoryChangeSchema = new Schema<ICategoryChange>({
  categoryId: { type: Schema.Types.ObjectId, required: true },
  startDate: { type: Date, required: true },
  endDate: { type: Date, required: true },
  targetAmount: { type: Number, required: true }
});

const simulationSchema = new Schema<ISimulation>({
  budgetId: { type: Schema.Types.ObjectId, required: true },
  name: { type: String, required: true },
  isActive: { type: Boolean, default: false },
  categoryChanges: [categoryChangeSchema]
}, {
  timestamps: true
});

// Index voor snelle queries op budgetId
simulationSchema.index({ budgetId: 1 });

export const Simulation = model<ISimulation>('Simulation', simulationSchema);
</file>

<file path="packages/api/src/services/openai.service.ts">
import OpenAI from 'openai';

/**
 * OpenAI service for AI-powered transaction categorization
 */
export class OpenAIService {
  private client: OpenAI | null = null;

  constructor() {
    this.initializeClient();
  }

  /**
   * Initialize OpenAI client with API key from environment
   */
  private initializeClient(): void {
    const apiKey = process.env.AI_OPENAI_API_KEY;
    
    if (!apiKey) {
      console.warn('OpenAI API key not found. AI suggestions will not be available.');
      return;
    }

    this.client = new OpenAI({
      apiKey: apiKey,
    });
  }

  /**
   * Check if OpenAI client is available
   */
  public isAvailable(): boolean {
    return this.client !== null;
  }

  /**
   * Suggest a category for a single transaction using OpenAI
   */
  public async suggestCategory(
    transaction: {
      payee_name: string;
      amount: number;
      date: string;
    },
    categories: Array<{ name: string }>,
    mappingsContext: string = ''
  ): Promise<string> {
    if (!this.client) {
      throw new Error('OpenAI client not initialized - API key missing');
    }

    const categoryNames = categories.map(cat => cat.name).join(', ');
    
    const prompt = `
    Suggest the most suitable category for the following transaction based on these available categories: ${categoryNames}.
    Special cases:
    - 'Afrekening op" means KBC credit.
    - Kbc business => Unexpected
    - Ava => Unexpected
    ${mappingsContext}
    Transaction Details:
    - Description: ${transaction.payee_name}
    - Amount: ${transaction.amount}
    - Date: ${transaction.date}

    Return only the name of the category.
    `;

    console.log('OpenAI prompt:', prompt);

    const response = await this.client.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
    });

    const suggestedCategory = response.choices[0]?.message?.content?.trim();
    
    if (!suggestedCategory) {
      throw new Error('No suggestion received from OpenAI');
    }

    console.log('OpenAI suggestion:', suggestedCategory);
    return suggestedCategory;
  }

  /**
   * Create batch tasks for multiple transaction categorizations
   */
  public createBatchTasks(
    transactions: Array<{
      id: string;
      payee_name: string;
      amount: number;
      date: string;
    }>,
    categories: Array<{ name: string }>,
    mappingsContext: string = ''
  ): Array<any> {
    const categoryNames = categories.map(cat => cat.name).join(', ');
    
    const tasks = transactions.map((transaction, index) => {
      const prompt = `
        Suggest the most suitable category for the following transaction based on these available categories: ${categoryNames}.
        Special cases:
        - 'Afrekening op" means KBC credit.
        - Kbc business => Unexpected
        - Ava => Unexpected
        ${mappingsContext}
        Transaction Details:
        - Description: ${transaction.payee_name}
        - Amount: ${transaction.amount}
        - Date: ${transaction.date}

        Return only the name of the category.
        `;
      
      return {
        custom_id: `transaction-${transaction.id}-${index}`,
        method: 'POST',
        url: '/v1/chat/completions',
        body: {
          model: 'gpt-4o-mini',
          temperature: 0.2,
          messages: [
            {
              role: 'user',
              content: prompt,
            },
          ],
        },
      };
    });

    return tasks;
  }

  /**
   * Submit a batch job to OpenAI
   */
  public async submitBatchJob(
    tasks: Array<any>,
    jobDescription: string = 'Transaction categorization'
  ): Promise<any> {
    if (!this.client) {
      throw new Error('OpenAI client not initialized - API key missing');
    }

    // Create JSONL content in memory
    const jsonlContent = tasks.map(task => JSON.stringify(task)).join('\n');
    
    // Convert to buffer for file upload
    const jsonlBuffer = Buffer.from(jsonlContent, 'utf-8');
    
    try {
      // Upload the file
      const batchFile = await this.client.files.create({
        file: new File([jsonlBuffer], `batch_tasks_${Date.now()}.jsonl`, {
          type: 'application/jsonl',
        }),
        purpose: 'batch',
      });

      // Create the batch job
      const batchJob = await this.client.batches.create({
        input_file_id: batchFile.id,
        endpoint: '/v1/chat/completions',
        completion_window: '24h',
        metadata: {
          description: jobDescription,
        },
      });

      console.log(`Batch job created with ID: ${batchJob.id}`);
      return batchJob;
    } catch (error) {
      console.error('Error creating batch job:', error);
      throw error;
    }
  }

  /**
   * Get batch job status and results
   */
  public async getBatchJobStatus(batchId: string): Promise<any> {
    if (!this.client) {
      throw new Error('OpenAI client not initialized - API key missing');
    }

    try {
      const batch = await this.client.batches.retrieve(batchId);
      return batch;
    } catch (error) {
      console.error('Error retrieving batch job:', error);
      throw error;
    }
  }

  /**
   * Process batch job results
   */
  public async processBatchResults(batchId: string): Promise<Array<any>> {
    if (!this.client) {
      throw new Error('OpenAI client not initialized - API key missing');
    }

    try {
      const batch = await this.client.batches.retrieve(batchId);
      
      if (batch.status !== 'completed' || !batch.output_file_id) {
        throw new Error(`Batch job not completed. Status: ${batch.status}`);
      }

      const file = await this.client.files.content(batch.output_file_id);
      const fileContent = await file.text();
      
      // Parse JSONL results
      const results = fileContent
        .trim()
        .split('\n')
        .map(line => JSON.parse(line));

      return results;
    } catch (error) {
      console.error('Error processing batch results:', error);
      throw error;
    }
  }
}

// Export singleton instance
export const openAIService = new OpenAIService();
</file>

<file path="packages/api/src/services/payeeMappings.service.ts">
import connectDb from '../data/db';
import mongoose from 'mongoose';

/**
 * Schema for payee mappings stored in MongoDB
 */
const PayeeMappingSchema = new mongoose.Schema({
  budgetId: { type: mongoose.Schema.Types.ObjectId, required: true },
  payeeName: { type: String, required: true },
  categoryName: { type: String, required: true },
  confidence: { type: Number, default: 1.0 },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
});

// Create compound index for efficient lookups
PayeeMappingSchema.index({ budgetId: 1, payeeName: 1 });

const PayeeMapping = mongoose.model('PayeeMapping', PayeeMappingSchema);

/**
 * Service for managing payee to category mappings
 * Handles learning from user categorizations
 */
export class PayeeMappingsService {
  private budgetId: mongoose.Types.ObjectId;

  constructor(budgetId: string) {
    this.budgetId = new mongoose.Types.ObjectId(budgetId);
  }

  /**
   * Learn from a transaction categorization
   */
  public async learnFromTransaction(
    payeeName: string,
    categoryName: string,
    confidence: number = 1.0
  ): Promise<void> {
    await connectDb();

    try {
      // Update existing mapping or create new one
      await PayeeMapping.findOneAndUpdate(
        {
          budgetId: this.budgetId,
          payeeName: payeeName,
        },
        {
          categoryName: categoryName,
          confidence: confidence,
          updatedAt: new Date(),
        },
        {
          upsert: true,
          new: true,
        }
      );

      console.log(`Learned mapping: ${payeeName} -> ${categoryName}`);
    } catch (error) {
      console.error('Error learning from transaction:', error);
      throw error;
    }
  }

  /**
   * Get category suggestion for a payee based on learned mappings
   */
  public async getSuggestionForPayee(payeeName: string): Promise<string | null> {
    await connectDb();

    try {
      const mapping = await PayeeMapping.findOne({
        budgetId: this.budgetId,
        payeeName: payeeName,
      }).sort({ confidence: -1, updatedAt: -1 });

      return mapping?.categoryName || null;
    } catch (error) {
      console.error('Error getting suggestion for payee:', error);
      return null;
    }
  }

  /**
   * Get all mappings for this budget as context for AI prompts
   */
  public async getMappingsForPrompt(): Promise<string> {
    await connectDb();

    try {
      const mappings = await PayeeMapping.find({
        budgetId: this.budgetId,
      })
        .sort({ confidence: -1, updatedAt: -1 })
        .limit(20); // Limit to most relevant mappings

      if (mappings.length === 0) {
        return '';
      }

      const mappingStrings = mappings.map(
        mapping => `${mapping.payeeName} -> ${mapping.categoryName}`
      );

      return `\nPrevious categorizations:\n${mappingStrings.join('\n')}\n`;
    } catch (error) {
      console.error('Error getting mappings for prompt:', error);
      return '';
    }
  }

  /**
   * Get mapping statistics for a budget
   */
  public async getMappingStats(): Promise<{
    totalMappings: number;
    recentMappings: number;
    topPayees: Array<{ payeeName: string; categoryName: string; count: number }>;
  }> {
    await connectDb();

    try {
      const totalMappings = await PayeeMapping.countDocuments({
        budgetId: this.budgetId,
      });

      const oneWeekAgo = new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

      const recentMappings = await PayeeMapping.countDocuments({
        budgetId: this.budgetId,
        updatedAt: { $gte: oneWeekAgo },
      });

      // Get top payees by frequency
      const topPayees = await PayeeMapping.aggregate([
        { $match: { budgetId: this.budgetId } },
        {
          $group: {
            _id: { payeeName: '$payeeName', categoryName: '$categoryName' },
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
        { $limit: 10 },
        {
          $project: {
            payeeName: '$_id.payeeName',
            categoryName: '$_id.categoryName',
            count: 1,
            _id: 0,
          },
        },
      ]);

      return {
        totalMappings,
        recentMappings,
        topPayees,
      };
    } catch (error) {
      console.error('Error getting mapping stats:', error);
      throw error;
    }
  }

  /**
   * Clear all mappings for a budget (for testing/reset purposes)
   */
  public async clearAllMappings(): Promise<void> {
    await connectDb();

    try {
      await PayeeMapping.deleteMany({
        budgetId: this.budgetId,
      });

      console.log(`Cleared all mappings for budget ${this.budgetId}`);
    } catch (error) {
      console.error('Error clearing mappings:', error);
      throw error;
    }
  }

  /**
   * Delete a specific mapping
   */
  public async deleteMapping(payeeName: string): Promise<boolean> {
    await connectDb();

    try {
      const result = await PayeeMapping.deleteOne({
        budgetId: this.budgetId,
        payeeName: payeeName,
      });

      return result.deletedCount > 0;
    } catch (error) {
      console.error('Error deleting mapping:', error);
      throw error;
    }
  }

  /**
   * Search mappings by payee name pattern
   */
  public async searchMappings(searchTerm: string): Promise<Array<{
    payeeName: string;
    categoryName: string;
    confidence: number;
    updatedAt: Date;
  }>> {
    await connectDb();

    try {
      const mappings = await PayeeMapping.find({
        budgetId: this.budgetId,
        payeeName: { $regex: searchTerm, $options: 'i' },
      })
        .sort({ confidence: -1, updatedAt: -1 })
        .limit(50);

      return mappings.map(mapping => ({
        payeeName: mapping.payeeName,
        categoryName: mapping.categoryName,
        confidence: mapping.confidence,
        updatedAt: mapping.updatedAt,
      }));
    } catch (error) {
      console.error('Error searching mappings:', error);
      throw error;
    }
  }
}

/**
 * Factory function to create PayeeMappingsService instance
 */
export const createPayeeMappingsService = (budgetId: string): PayeeMappingsService => {
  return new PayeeMappingsService(budgetId);
};
</file>

<file path="packages/api/src/utils/validation.ts">
export function isValidUUID(uuid: string): boolean {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(uuid);
}
</file>

<file path="packages/api/tests/test.mockdata.mocks.ts">
import { am, c } from "vitest/dist/reporters-5f784f42.js";

export const mockTransactions = [
  {
    id: "1",
    name: "mock transaction",
    categoryId: "1",
    amount: 100,
    cleanPayeeName: "mock payee",
    memo: "test memo 1",
  },
  {
    id: "1",
    name: "mock transaction",
    categoryId: "1",
    amount: 200,
    cleanPayeeName: "mock payee 2",
    memo: "test memo 2",
  },
];

export const mockCategories = [
  {
    _id: "1",
    key: "mock category",
  },
  {
    _id: "2",
    key: "mock category 2",
  },
];

export const mockUser = {
  // Mocked user object
  authId: "test",
  name: "Test User",
  // Add other necessary user properties
};

export const mockBudget = {
  // Mocked budget object
  id: "test",
  name: "Test Budget",
  // Add other necessary budget properties
};
</file>

<file path="packages/common-ts/src/components/AmountInput.tsx">
import React, { useState } from 'react';

interface AmountInputProps {
    value: number;
    onChange: (value: number) => void;
    placeholder?: string;
    required?: boolean;
    className?: string;
    showToggle?: boolean; // Show income/expense toggle buttons
}

const AmountInput: React.FC<AmountInputProps> = ({
    value,
    onChange,
    placeholder = "0.00",
    required = false,
    className = "",
    showToggle = true
}) => {
    const [isExpense, setIsExpense] = useState(value < 0);
    const absoluteValue = Math.abs(value);

    const handleAmountChange = (newAmount: number) => {
        const finalAmount = isExpense ? -Math.abs(newAmount) : Math.abs(newAmount);
        onChange(finalAmount);
    };

    const handleToggle = (expense: boolean) => {
        setIsExpense(expense);
        if (value !== 0) {
            onChange(expense ? -Math.abs(value) : Math.abs(value));
        }
    };

    return (
        <div className={`space-y-3 ${className}`}>
            {showToggle && (
                <div className="flex gap-2">
                    <button
                        type="button"
                        onClick={() => handleToggle(false)}
                        className={`flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 ${
                            !isExpense
                                ? 'bg-green-100 text-green-800 border-2 border-green-300 hover:bg-green-200 focus:ring-green-500 dark:bg-green-900 dark:text-green-200 dark:border-green-700 dark:hover:bg-green-800'
                                : 'bg-gray-100 text-gray-600 border-2 border-gray-200 hover:bg-gray-200 focus:ring-gray-500 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-600 dark:hover:bg-gray-700'
                        }`}
                    >
                         Income
                    </button>
                    <button
                        type="button"
                        onClick={() => handleToggle(true)}
                        className={`flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 ${
                            isExpense
                                ? 'bg-red-100 text-red-800 border-2 border-red-300 hover:bg-red-200 focus:ring-red-500 dark:bg-red-900 dark:text-red-200 dark:border-red-700 dark:hover:bg-red-800'
                                : 'bg-gray-100 text-gray-600 border-2 border-gray-200 hover:bg-gray-200 focus:ring-gray-500 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-600 dark:hover:bg-gray-700'
                        }`}
                    >
                         Expense
                    </button>
                </div>
            )}
            
            <div className="relative">
                <div className="absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-500 dark:text-gray-400 font-medium pointer-events-none">
                    
                </div>
                <input
                    type="number"
                    step="0.01"
                    min="0"
                    value={absoluteValue || ''}
                    onChange={(e) => handleAmountChange(Number(e.target.value))}
                    className={`input input-bordered w-full pl-10 pr-4 ${
                        isExpense
                            ? 'text-red-600 dark:text-red-400'
                            : 'text-green-600 dark:text-green-400'
                    }`}
                    placeholder={placeholder}
                    required={required}
                    inputMode="decimal"
                />
            </div>
        </div>
    );
};

export { AmountInput };
</file>

<file path="packages/common-ts/src/transaction/transaction.utils.ts">
import { Category } from "../category";

export type Transaction = {
  uuid: string;
  accountName: string;
  amount: number;
  date: string;
  categoryId: string | undefined | null;
  payeeName: string;
  cleanPayeeName: string;
  memo: string;
  import_payee_name_original?: string;
};

export interface GroupedTransactions {
  [key: string]: Transaction[];
}

export type TransactionsWithCategories = {
  transactions: Transaction[];
  categories: Category[];
};

export type PayeeWithActivity = {
  payeeName: string;
  activity: number;
};
</file>

<file path="packages/mathapi/app/simulations/reduced-salary.json">
[
    {
        "date": "2025-02-03",
        "amount": "2000",
        "reason": "Simulation: -2000 minder aan salaris",
        "category": "Salary"
    }
]
</file>

<file path="packages/mathapi/app/tests/conftest.py">
"""
Configuration file for pytest to handle imports and common fixtures.
"""

import sys
import os

# Add the app directory to Python path so we can import app modules
app_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if app_dir not in sys.path:
    sys.path.insert(0, app_dir)

# Add the mathapi root directory to Python path 
root_dir = os.path.dirname(app_dir)
if root_dir not in sys.path:
    sys.path.insert(0, root_dir)

import pytest
</file>

<file path="packages/mathapi/app/auth.py">
from functools import wraps
from flask import request, jsonify, current_app
import jwt
from jwt.algorithms import RSAAlgorithm
import requests
import os
from dotenv import load_dotenv

load_dotenv()

def get_auth0_public_key():
    """Fetch Auth0 public key from JWKS endpoint."""
    domain = os.getenv('AUTH0_DOMAIN')
    jwks_url = f"https://{domain}/.well-known/jwks.json"
    jwks = requests.get(jwks_url).json()
    # Get the first key (usually there's only one)
    public_key = RSAAlgorithm.from_jwk(jwks['keys'][0])
    return public_key

def requires_auth(f):
    """Decorator to check if request has valid JWT token."""
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get('Authorization', None)
        if not auth_header:
            return jsonify({"message": "No authorization header"}), 401
        
        try:
            # Strip 'Bearer ' from token
            token = auth_header.split(' ')[1]
            # Verify token
            payload = jwt.decode(
                token,
                get_auth0_public_key(),
                algorithms=['RS256'],
                audience=os.getenv('AUTH0_AUDIENCE'),
                issuer=f"https://{os.getenv('AUTH0_DOMAIN')}/"
            )
            # Add user info to request context
            request.auth = {"payload": payload}
            return f(*args, **kwargs)
        except jwt.ExpiredSignatureError:
            return jsonify({"message": "Token has expired"}), 401
        except jwt.InvalidTokenError as e:
            current_app.logger.error(f"Invalid token error: {str(e)}")
            return jsonify({"message": "Invalid token"}), 401
        except Exception as e:
            current_app.logger.error(f"Authentication error: {str(e)}")
            return jsonify({"message": "Authentication error"}), 500
            
    return decorated
</file>

<file path="packages/mathapi/.gitignore">
# Coverage files
.coverage
htmlcov/

# Python cache
__pycache__/
*.py[cod]
*$py.class

# Virtual environment
venv/
env/

# IDE files
.vscode/
.idea/

# OS files
.DS_Store
Thumbs.db

# Pytest cache
.pytest_cache/

# Environment variables
.env
.env.local
</file>

<file path="packages/mathapi/Dockerfile">
# Gebruik een lichte Python-basisimage
FROM python:3.10-slim

WORKDIR /app

# Copy only the app package to the container
COPY ../../packages/mathapi ./

# Installeer dependencies
RUN pip install -r requirements.txt

# Maak de app module beschikbaar
ENV PYTHONPATH=/app
ENV FLASK_ENV=production
ENV FLASK_DEBUG=0

# Maak een niet-root gebruiker voor veiligheid
RUN adduser --disabled-password --gecos '' pythonuser
USER pythonuser

# Stel de standaardpoort in
EXPOSE 5000

# Start de applicatie met Flask
CMD ["flask", "--app", "app/app.py", "run", "--host=0.0.0.0"]

# TODO: Upgrade naar Gunicorn voor productie gebruik
# CMD ["gunicorn", "--bind", "0.0.0.0:5000", "app.app:app"]
</file>

<file path="packages/mathapi/test_domiciliering.py">
#!/usr/bin/env python3
"""
Test script for direct debit pattern preprocessing.
"""

from app.payee_mappings_mongo import MongoPayeeMappingsManager

def test_direct_debit_patterns():
    print(' Testing direct debit pattern preprocessing:')
    print('=' * 60)

    manager = MongoPayeeMappingsManager('test-budget')

    test_cases = [
        'het raster vzw domiciliring 122401816796 30172-1 30172-1',
        'belgacom domiciliring 987654321 12345-6',
        'electrabel domiciliring 1122334455667',
        'test company bv domiciliring',
        'monica campus vzw domiciliring 999888777',
        'vodafone belgium domiciliring 555666777 99999-8',
        'proximus domiciliring 111222333444555',
        'de lijn domiciliring 777888999 11111-2 22222-3'
    ]

    print('Testing multiple direct debit patterns:')
    for test in test_cases:
        result = manager.test_preprocessing(test)
        print(f'  Original: {test[:50]}...')
        print(f'  Cleaned:  "{result}"')
        print()

    print(' All direct debit patterns tested!')

if __name__ == '__main__':
    test_direct_debit_patterns()
</file>

<file path="packages/mathapi/testdata.json">
[
    {
        "_id": {
            "$oid": "66ab697ff9292fc9e1e030ed"
        },
        "uuid": "627bf469-136d-4a4e-a636-7b34ab176d0b",
        "name": "Boekhouding",
        "balance": 99510,
        "budgeted": -1229490,
        "activity": 0,
        "targetAmount": 1321090,
        "historicalAverage": 11000,
        "typicalSpendingPattern": 0.13333333333333333,
        "budgetId": {
            "$oid": "66ab697ef9292fc9e1e03024"
        },
        "__v": 0,
        "target": {
            "goal_type": "NEED",
            "goal_day": null,
            "goal_cadence": 0,
            "goal_cadence_frequency": null,
            "goal_creation_month": "2024-06-01",
            "goal_target": 1321090,
            "goal_target_month": "2025-01-31",
            "goal_percentage_complete": 100,
            "goal_months_to_budget": 1,
            "goal_under_funded": 0,
            "goal_overall_funded": 5064990,
            "goal_overall_left": 0
        }
    },
    {
        "_id": {
            "$oid": "66ab697ff9292fc9e1e03107"
        },
        "uuid": "bfbbca9d-d845-44aa-822d-b8008c774a1b",
        "name": "Sociale Bijdrage",
        "balance": 55740,
        "budgeted": -1254900,
        "activity": 0,
        "targetAmount": 2621280,
        "historicalAverage": 26720,
        "typicalSpendingPattern": 0.45161290322580644,
        "budgetId": {
            "$oid": "66ab697ef9292fc9e1e03024"
        },
        "__v": 0,
        "target": {
            "goal_type": "NEED",
            "goal_day": null,
            "goal_cadence": 1,
            "goal_cadence_frequency": 3,
            "goal_creation_month": "2024-11-01",
            "goal_target": 2621280,
            "goal_target_month": "2025-01-31",
            "goal_percentage_complete": 2,
            "goal_months_to_budget": 1,
            "goal_under_funded": 2565540,
            "goal_overall_funded": 55740,
            "goal_overall_left": 2565540
        }
    },
    {
        "_id": {
            "$oid": "66ab697ff9292fc9e1e03113"
        },
        "uuid": "bfc0e6e7-110b-4dd0-a022-72a6b3604ea5",
        "name": "Car Insurance",
        "balance": 0,
        "budgeted": 15520,
        "activity": -15520,
        "targetAmount": 1338240,
        "historicalAverage": 6180,
        "typicalSpendingPattern": 0.4193548387096774,
        "budgetId": {
            "$oid": "66ab697ef9292fc9e1e03024"
        },
        "__v": 0,
        "target": {
            "goal_type": "NEED",
            "goal_day": null,
            "goal_cadence": 13,
            "goal_cadence_frequency": 1,
            "goal_creation_month": "2023-07-01",
            "goal_target": 1338240,
            "goal_target_month": "2024-07-23",
            "goal_percentage_complete": 1,
            "goal_months_to_budget": 7,
            "goal_under_funded": 175660,
            "goal_overall_funded": 15520,
            "goal_overall_left": 1322720
        }
    }
]
</file>

<file path="packages/web/__tests__/app/components/transactions-page/payee-tooltip.test.tsx">
import { render, screen } from '@testing-library/react';
import { PayeeTooltip } from '../../../../app/components/transactions-page/payee-tooltip';

describe('PayeeTooltip', () => {

  it('should render clean payee name', () => {
    render(
      <PayeeTooltip
        cleanPayeeName="PayPal"
        fullPayeeName="PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL"
      />
    );

    expect(screen.getByText('PayPal')).toBeDefined();
  });

  it('should show tooltip with DaisyUI classes when full payee name is different', () => {
    const { container } = render(
      <PayeeTooltip
        cleanPayeeName="PayPal"
        fullPayeeName="PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL"
      />
    );

    const tooltipElement = container.querySelector('.tooltip');
    expect(tooltipElement).toBeDefined();
    expect(tooltipElement).toHaveAttribute('data-tip', 'PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL');
  });

  it('should not show tooltip when payee names are the same', () => {
    const { container } = render(
      <PayeeTooltip
        cleanPayeeName="PayPal"
        fullPayeeName="PayPal"
      />
    );

    const tooltipElement = container.querySelector('.tooltip');
    expect(tooltipElement).toBeNull();
  });

  it('should not show tooltip when no full payee name provided', () => {
    const { container } = render(
      <PayeeTooltip
        cleanPayeeName="PayPal"
      />
    );

    const tooltipElement = container.querySelector('.tooltip');
    expect(tooltipElement).toBeNull();
  });

  it('should have cursor-help styling when tooltip is shown', () => {
    render(
      <PayeeTooltip
        cleanPayeeName="PayPal"
        fullPayeeName="PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL"
      />
    );

    const payeeElement = screen.getByText('PayPal');
    expect(payeeElement).toHaveClass('cursor-help');
    expect(payeeElement).toHaveClass('text-left');
  });

  it('should have consistent left alignment with and without tooltip', () => {
    const { rerender } = render(
      <PayeeTooltip
        cleanPayeeName="PayPal"
        fullPayeeName="PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL"
      />
    );

    // With tooltip
    let payeeElement = screen.getByText('PayPal');
    expect(payeeElement).toHaveClass('text-left');

    // Without tooltip (same payee names)
    rerender(
      <PayeeTooltip
        cleanPayeeName="PayPal"
        fullPayeeName="PayPal"
      />
    );

    payeeElement = screen.getByText('PayPal');
    expect(payeeElement).toHaveClass('text-left');
  });
});
</file>

<file path="packages/web/__tests__/app/components/budget-navigation.test.tsx">
import { expect, test, vi } from "vitest";
import { render, screen } from "@testing-library/react";
import BudgetNavigation from "../../../app/components/budget-navigation";

// Mock Next.js navigation
vi.mock('next/navigation', () => ({
  usePathname: () => '/budgets/test-uuid/transactions',
  useParams: () => ({ budgetUuid: 'test-uuid' }),
}));

const mockBudgets = [
  { uuid: "1", name: "Budget 1" },
  { uuid: "2", name: "Budget 2" },
];

test("BudgetNavigation renders correctly when logged in", () => {
  render(<BudgetNavigation budgets={mockBudgets} loggedIn={true} />);
  const budgetLinks = screen.getAllByRole("link", {
    name: mockBudgets[0].name,
  });
  // every budget has a link for mobile and web
  expect(budgetLinks).toHaveLength(2);

  // todo : always works
  expect(screen.queryByRole("button", { name: "Sign Outje?" })).toBeDefined();
});

test("BudgetNavigation renders correctly when logged out", () => {
  render(<BudgetNavigation budgets={mockBudgets} loggedIn={false} />);

  expect(screen.queryByRole("button", { name: "Sign Out" })).toBeNull();
});
</file>

<file path="packages/web/app/api/ynab/auth.ts">
import { NextAuthOptions } from "next-auth";
import { connectUserWithYnab } from "../user/user.client";

export const ynabAuthOptions: NextAuthOptions = {
  providers: [
    {
      id: "ynab",
      name: "YNAB",
      type: "oauth",
      authorization: {
        params: {
          scope: "",
        },
        url: "https://app.ynab.com/oauth/authorize",
      },
      token: "https://app.ynab.com/oauth/token",
      clientId: process.env.YNAB_CLIENT_ID,
      clientSecret: process.env.YNAB_CLIENT_SECRET,
      profile(profile) {
        return {
          id: "test",
        };
      },
      userinfo: {
        request: () => ({}),
      },
    },
  ],
  callbacks: {
    async jwt({ token, account }) {
      // Persist the OAuth access_token to the token right after signin
      if (account && account.refresh_token) {
        await connectUserWithYnab({
          accessToken: account.access_token || "",
          refreshToken: account.refresh_token || "",
        });
        //syncLoggedInUser();
      }
      return token;
    },
    async session({ session }) {
      // Send properties to the client, like an access_token from a provider.
      return session;
    },
  },
};
</file>

<file path="packages/web/app/api/accounts.client.ts">
import { apiGet } from "./client";

export type Account = {
  _id?: string;
  uuid: string;
  name: string;
  balance: number;
  cleared_balance: number;
  uncleared_balance: number;
  budgetId: string;
};

/**
 * Get accounts for a budget from Node.js API
 */
export const getAccounts = async (budgetUuid: string): Promise<Account[]> => {
  return apiGet(`budgets/${budgetUuid}/accounts`);
};
</file>

<file path="packages/web/app/api/accounts.server.ts">
"use server";
import { apiFetch } from "./client";

export type Account = {
  _id?: string;
  uuid: string;
  name: string;
  balance: number;
  cleared_balance: number;
  uncleared_balance: number;
  budgetId: string;
};

/**
 * Get accounts for a budget from Node.js API (server-side)
 */
export const getAccounts = async (budgetUuid: string): Promise<Account[]> => {
  return apiFetch(`budgets/${budgetUuid}/accounts`);
};
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/constants.ts">
export type TimeRange = '1m' | '3m' | '6m' | '9m' | '1y';

export const TIME_RANGES = {
    '1m': { label: '1 month', days: 30 },
    '3m': { label: '3 months', days: 90 },
    '6m': { label: '6 months', days: 180 },
    '9m': { label: '9 months', days: 270 },
    '1y': { label: '1 year', days: 365 }
} as const;

export const DEFAULT_TIME_RANGE: TimeRange = '3m';
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/FutureChangesSection.tsx">
import { getCategories } from '@/app/api/categories.client';
import { getAccounts } from '@/app/api/accounts.server';
import { getPrediction } from '@/app/api/math.server';
import { FutureChangesTable } from './FutureChangesTable';
import { TimeRange, TIME_RANGES } from './constants';

interface FutureChangesSectionProps {
    budgetUuid: string;
    timeRange: TimeRange;
}

export default async function FutureChangesSection({ budgetUuid, timeRange }: FutureChangesSectionProps) {
    const daysAhead = TIME_RANGES[timeRange].days;

    const [predictionData, categories, accounts] = await Promise.all([
        getPrediction(budgetUuid, daysAhead),
        getCategories(budgetUuid),
        getAccounts(budgetUuid)
    ]);

    return (
        <FutureChangesTable
            predictionData={predictionData}
            categories={categories}
            accounts={accounts}
            budgetUuid={budgetUuid}
        />
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/InteractiveSimulationsSection.tsx">
import { getCategories } from '@/app/api/categories.client';
import { getSimulations } from './actions';
import InteractiveSimulations from './InteractiveSimulations';

interface InteractiveSimulationsSectionProps {
    budgetUuid: string;
}

export default async function InteractiveSimulationsSection({ budgetUuid }: InteractiveSimulationsSectionProps) {
    const [categories, simulations] = await Promise.all([
        getCategories(budgetUuid),
        getSimulations(budgetUuid)
    ]);

    const categoryOptions = categories.map(category => ({ uuid: category.uuid, name: category.name }));

    return (
        <InteractiveSimulations
            categoryOptions={categoryOptions}
            initialSimulations={simulations}
        />
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/prediction-data.server.ts">
import { apiGet } from "@/app/api/client";

export type SimulationData = {
    [date: string]: {
        balance: number;
        balance_diff?: number;
        changes: Array<{
            amount: number;
            category: string;
            reason: string;
            is_simulation?: boolean;
            memo?: string;
        }>;
    };
};

export type PredictionData = {
    [simulationName: string]: SimulationData;
};
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/PredictionChartSection.tsx">
import { PredictionChart } from '@/components/charts/prediction-chart';
import { getCategories } from '@/app/api/categories.client';
import { getPrediction } from '@/app/api/math.server';
import { TimeRange, TIME_RANGES } from './constants';

interface PredictionChartSectionProps {
    budgetUuid: string;
    timeRange: TimeRange;
}

export default async function PredictionChartSection({ budgetUuid, timeRange }: PredictionChartSectionProps) {
    const daysAhead = TIME_RANGES[timeRange].days;

    const [predictionData, categories] = await Promise.all([
        getPrediction(budgetUuid, daysAhead),
        getCategories(budgetUuid),
    ]);

    return (
        <PredictionChart
            predictionData={predictionData}
            categories={categories}
            variant="detail"
            selectedTimeRange={timeRange}
        />
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/transactions/page.tsx">
import TransactionsPage from "../../../components/transactions-page";
import BudgetSubNavigation from "../../../components/budget-sub-navigation";

async function TransactionsRoute({
  params,
  searchParams,
}: {
  params: { budgetUuid: string };
  searchParams: { [key: string]: string | undefined };
}) {
  const { budgetUuid } = params;
  const { categoryUuid, month, dayOfMonth } = searchParams;

  return (
    <>
      <BudgetSubNavigation budgetUuid={budgetUuid} />
      <TransactionsPage
        budgetUuid={budgetUuid}
        categoryUuid={categoryUuid}
        month={month}
        dayOfMonth={dayOfMonth}
      />
    </>
  );
}

export default TransactionsRoute;
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/UnapprovedStats.tsx">
"use client";

interface Props {
    totalTransactions: number;
    categorizedCount: number;
    uncategorizedCount: number;
    onApproveAll: () => void;
    isApproving: boolean;
    lastResult?: any;
}

export default function UnapprovedStats({
    totalTransactions,
    categorizedCount,
    uncategorizedCount,
    onApproveAll,
    isApproving,
    lastResult
}: Props) {
    return (
        <div className="card bg-base-100 shadow-xl">
            <div className="card-body">
                <div className="flex flex-col md:flex-row justify-between items-center gap-4">
                    <div className="stats stats-horizontal shadow">
                        <div className="stat">
                            <div className="stat-figure text-warning">
                                <span className="text-3xl"></span>
                            </div>
                            <div className="stat-title">Unapproved</div>
                            <div className="stat-value text-warning">{totalTransactions}</div>
                            <div className="stat-desc">
                                {totalTransactions === 0 ? 'All approved!' : 'Transactions need approval'}
                            </div>
                        </div>

                        {totalTransactions > 0 && (
                            <>
                                <div className="stat">
                                    <div className="stat-figure text-success">
                                        <span className="text-2xl"></span>
                                    </div>
                                    <div className="stat-title">Categorized</div>
                                    <div className="stat-value text-success">{categorizedCount}</div>
                                    <div className="stat-desc">Ready to approve</div>
                                </div>

                                <div className="stat">
                                    <div className="stat-figure text-orange-500">
                                        <span className="text-2xl"></span>
                                    </div>
                                    <div className="stat-title">Uncategorized</div>
                                    <div className="stat-value text-orange-500">{uncategorizedCount}</div>
                                    <div className="stat-desc">Need categorization</div>
                                </div>
                            </>
                        )}
                    </div>

                    <div className="flex flex-col gap-3">
                        {totalTransactions > 0 && (
                            <button
                                className="btn btn-success btn-lg gap-2"
                                onClick={onApproveAll}
                                disabled={isApproving}
                            >
                                {isApproving ? (
                                    <>
                                        <span className="loading loading-spinner loading-sm"></span>
                                        Approving All...
                                    </>
                                ) : (
                                    <>
                                        <span className="text-xl"></span>
                                        Approve All ({totalTransactions})
                                    </>
                                )}
                            </button>
                        )}

                        {lastResult && !lastResult.error && (
                            <div className="badge badge-success gap-2">
                                <span></span>
                                {lastResult.approved_count} approved
                            </div>
                        )}
                    </div>
                </div>

                {totalTransactions > 0 && (
                    <div className="mt-4 text-sm text-gray-600">
                        <div className="grid md:grid-cols-2 gap-4">
                            <div>
                                <p>
                                    <span className="badge badge-outline badge-success mr-2"> Approve</span>
                                    <strong>Approve transactions</strong> that are already categorized correctly.
                                </p>
                            </div>
                            <div>
                                <p>
                                    <span className="badge badge-outline badge-info mr-2"> Edit</span>
                                    <strong>Change category</strong> and approve in one action.
                                </p>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/UncategorisedStats.tsx">
"use client";

interface Props {
    totalTransactions: number;
    aiSuggestionsCount: number;
    manuallyModifiedCount: number;
    onApplyAll: () => void;
    onApplyAIOnly: () => void;
    isApplying: boolean;
    lastResult?: any;
}

export default function UncategorisedStats({
    totalTransactions,
    aiSuggestionsCount,
    manuallyModifiedCount,
    onApplyAll,
    onApplyAIOnly,
    isApplying,
    lastResult
}: Props) {
    return (
        <div className="card bg-base-100 shadow-xl">
            <div className="card-body">
                <div className="flex flex-col md:flex-row justify-between items-center gap-4">
                    <div className="stats stats-horizontal shadow">
                        <div className="stat">
                            <div className="stat-figure text-primary">
                                <span className="text-3xl"></span>
                            </div>
                            <div className="stat-title">Uncategorised</div>
                            <div className="stat-value text-primary">{totalTransactions}</div>
                            <div className="stat-desc">
                                {totalTransactions === 0 ? 'All done!' : 'Transactions need attention'}
                            </div>
                        </div>

                        {totalTransactions > 0 && (
                            <>
                                <div className="stat">
                                    <div className="stat-figure text-blue-500">
                                        <span className="text-2xl"></span>
                                    </div>
                                    <div className="stat-title">AI Suggestions</div>
                                    <div className="stat-value text-blue-500">{aiSuggestionsCount}</div>
                                    <div className="stat-desc">Ready to apply</div>
                                </div>

                                <div className="stat">
                                    <div className="stat-figure text-orange-500">
                                        <span className="text-2xl"></span>
                                    </div>
                                    <div className="stat-title">Manual Changes</div>
                                    <div className="stat-value text-orange-500">{manuallyModifiedCount}</div>
                                    <div className="stat-desc">Your modifications</div>
                                </div>
                            </>
                        )}
                    </div>

                    <div className="flex flex-col gap-3">
                        {totalTransactions > 0 && (
                            <>
                                <button
                                    className="btn btn-primary btn-lg gap-2"
                                    onClick={onApplyAll}
                                    disabled={isApplying}
                                >
                                    {isApplying ? (
                                        <>
                                            <span className="loading loading-spinner loading-sm"></span>
                                            Applying All Changes...
                                        </>
                                    ) : (
                                        <>
                                            <span className="text-xl"></span>
                                            Apply All ({totalTransactions})
                                        </>
                                    )}
                                </button>

                                {aiSuggestionsCount > 0 && (
                                    <button
                                        className="btn btn-outline btn-primary gap-2"
                                        onClick={onApplyAIOnly}
                                        disabled={isApplying}
                                    >
                                        <span className="text-xl"></span>
                                        Apply AI Only ({aiSuggestionsCount})
                                    </button>
                                )}
                            </>
                        )}

                        {lastResult && !lastResult.error && (
                            <div className="badge badge-success gap-2">
                                <span></span>
                                {lastResult.updated_transactions?.length || lastResult.length} applied
                            </div>
                        )}
                    </div>
                </div>

                {totalTransactions > 0 && (
                    <div className="mt-4 text-sm text-gray-600">
                        <div className="grid md:grid-cols-2 gap-4">
                            <div>
                                <p>
                                    <span className="badge badge-outline badge-primary mr-2"> AI</span>
                                    <strong>AI suggestions</strong> are based on your past categorizations.
                                </p>
                            </div>
                            <div>
                                <p>
                                    <span className="badge badge-outline badge-warning mr-2"> Manual</span>
                                    <strong>Manual changes</strong> will be learned for future suggestions.
                                </p>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/page.tsx">
import BudgetPage from "../../components/budget-page";
import BudgetSubNavigation from "../../components/budget-sub-navigation";

async function BudgetRoute({ params }: { params: { budgetUuid: string } }) {
  const { budgetUuid } = params;

  return (
    <>
      <BudgetSubNavigation budgetUuid={budgetUuid} />
      <BudgetPage budgetUuid={budgetUuid} />
    </>
  );
}

export default BudgetRoute;
</file>

<file path="packages/web/app/components/budget-page/current-month.tsx">
import Link from "next/link";
import CategoryCard from "./category-card";
import MonthTotalOverview from "./month-total-overview";
import HiddenProgressBars from "./hidden-progress-bars";
import { Category, MonthlyForcast, MonthSummary, MonthTotal, percentageSpent } from "common-ts";
import type { PredictionData } from '@/app/budgets/[budgetUuid]/predictions/prediction-data.server';

type Props = {
  budgetUuid: string;
  categories: Category[];
  monthSummary: MonthSummary;
  monthPercentage: number;
  monthTotal: MonthTotal;
  forecast: MonthlyForcast;
  predictionData?: PredictionData;
};

const sortByCategoryUsageWithInflowNameFirst = (a: Category, b: Category) => {
  if (a.name.toLowerCase().includes("inflow")) {
    return -1;
  }
  if (b.name.toLowerCase().includes("inflow")) {
    return 1;
  }
  return percentageSpent(a) - percentageSpent(b);
};

const withBudgetFilter = (category: Category) => {
  return category.budgeted > 0;
};

const CurrentMonth = ({
  categories,
  budgetUuid,
  monthSummary,
  monthPercentage,
  monthTotal,
  forecast,
  predictionData,
}: Props) => {
  return (
    <div className="card-body">
      <h2 className="card-title">
        <Link
          className="link"
          href={`/budgets/${budgetUuid}/transactions?month=${monthSummary.month}`}
        >
          {monthSummary.month}
        </Link>
      </h2>
      <HiddenProgressBars />
      <MonthTotalOverview
        month={monthSummary.month}
        monthTotal={monthTotal}
        monthPercentage={monthPercentage}
        forecast={forecast}
        categories={categories}
        budgetUuid={budgetUuid}
        predictionData={predictionData}
      />
      <div className="flex flex-wrap mb-2 -mx-2">
        {categories
          .filter(withBudgetFilter)
          .sort(sortByCategoryUsageWithInflowNameFirst)
          .map((category) => (
            <CategoryCard
              key={category.uuid}
              budgetUuid={budgetUuid}
              currentMonthLbl={monthSummary.month}
              category={category}
              monthTotal={monthTotal}
            />
          ))}
      </div>
    </div>
  );
};

export default CurrentMonth;
</file>

<file path="packages/web/app/components/charts/category-pie-chart.tsx">
"use client";
import React, { useRef, useState, MouseEvent } from "react";
import { useRouter } from "next/navigation";
import {
  Chart as ChartJS,
  ArcElement,
  Tooltip,
  Legend,
  InteractionItem,
} from "chart.js";
import { Pie, getElementAtEvent } from "react-chartjs-2";
import ChartDataLabels from "chartjs-plugin-datalabels";

const MIN_PERCENTAGE_TO_DISPLAY = 4;

ChartJS.register(ArcElement, Tooltip, Legend, ChartDataLabels);

import { chartFormatter, isOnMobileDevice, nameToUniqueColor, valueToPercentageOfTotal } from "./util";
import { filter, pipe } from "ramda";
import { Category, isInflowCategory } from "common-ts";
import { absoluteD1000Number, formatAmount } from "common-ts";

type Props = {
  categories: Category[];
  month: string;
  budgetUuid: string;
  selectedAmountTypes?: CategoryAmountType[];
};

const options = {
  plugins: {
    legend: {
      display: false,
    },
  },
};



type CategoryAmountType = "activity" | "balance" | "budgeted";
type CategoryAmountTypeWithProps = {
  type: CategoryAmountType;
  label: string;
  negative?: boolean; // if true positive values will be filtered out
};
const amountTypes: CategoryAmountTypeWithProps[] = [
  { type: "activity", label: "Spent", negative: true },
  { type: "balance", label: "Available" },
  { type: "budgeted", label: "Budgeted" },
];

const nonInflowCategoryWithUsage =
  (categoryAmountType: CategoryAmountType) => (category: Category) =>
    !isInflowCategory(category) && category[categoryAmountType] !== 0;

const extraAmountFitler =
  (categoryAmountType: CategoryAmountType) => (category: Category) => {
    const categoryWithProps = amountTypes.find(
      (amountType) => amountType.type === categoryAmountType
    );
    if (!categoryWithProps) return true;
    if (categoryWithProps.negative) {
      return category[categoryAmountType] < 0;
    }
    return true;
  };

const notExcludedCategory =
  (excludedCategories: string[]) => (category: Category) =>
    !excludedCategories.includes(category.name);

export const CategoryPieChart = ({
  categories,
  month,
  budgetUuid,
  selectedAmountTypes,
}: Props) => {
  // category amount type state to be used by toggle
  const [categoryAmountType, setCategoryAmountType] =
    useState<CategoryAmountType>("activity");
  // categories to exclude from pie chart state
  const [excludedCategories, setExcludedCategories] = useState<string[]>([]);

  const getCategoryAmountTypeLabel = (type: CategoryAmountType) =>
    amountTypes.find((amountType) => amountType.type === type)?.label || "";

  const sortyByName = (a: Category, b: Category) =>
    a.name.localeCompare(b.name);

  // todo: put sort in pipe
  const categoriesWithUsage: Category[] = pipe(
    filter(nonInflowCategoryWithUsage(categoryAmountType)),
    filter(extraAmountFitler(categoryAmountType))
  )(categories).sort(sortyByName);

  const filteredCategories = categoriesWithUsage.filter(
    notExcludedCategory(excludedCategories)
  );
  const totalAmount = absoluteD1000Number(
    filteredCategories.reduce(
      (total, category) => total + category[categoryAmountType],
      0
    )
  );

  const data = {
    labels: filteredCategories.map((category) => category.name),
    datasets: [
      {
        type: "pie" as const,
        label: getCategoryAmountTypeLabel(categoryAmountType),
        data: filteredCategories.map((category) =>
          absoluteD1000Number(category[categoryAmountType])
        ),
        borderColor: "rgb(255, 99, 132)",
        backgroundColor: filteredCategories.map((category) =>
          nameToUniqueColor(category.name)
        ),
        datalabels: {
          //black
          color: "#000000",
          formatter: chartFormatter(totalAmount, MIN_PERCENTAGE_TO_DISPLAY),
        },
      },
    ],
  };

  const router = useRouter();
  const chartRef = useRef<any>(null);

  const onClick = (event: MouseEvent<HTMLCanvasElement>) => {
    const { current: chart } = chartRef;
    if (!chart) {
      return;
    }
    handleChartEvent(getElementAtEvent(chart, event));
  };

  const toggleCategory = (categoryName: string) => {
    setExcludedCategories((excludedCategories) =>
      excludedCategories.includes(categoryName)
        ? excludedCategories.filter((category) => category !== categoryName)
        : [...excludedCategories, categoryName]
    );
  };

  const navigateToCategory = (categoryName: string) => {
    // navigate to category with router
    // todo should be parent component that handles this
    const category = categories.find(
      (category) => category.name === categoryName
    );
    if (!category) return;

    router.push(
      `/budgets/${budgetUuid}/transactions?month=${month}&categoryUuid=${category.uuid}`
    );
  };

  const handleChartEvent = (element: InteractionItem[]) => {
    if (!element.length) return;

    const { index } = element[0];
    const { labels } = data;
    if (!isOnMobileDevice()) {
      navigateToCategory(labels[index]);
    }
  };
  return (
    <>
      <AmountTypeToggle
        current={categoryAmountType}
        onChange={setCategoryAmountType}
        selectedAmountTypes={selectedAmountTypes}
      />
      <CategoryPieChartLegend
        categories={categoriesWithUsage}
        excludedCategories={excludedCategories}
        onToggleCategory={toggleCategory}
        amountType={categoryAmountType}
      />
      <Pie data={data} onClick={onClick} ref={chartRef} options={options} />
    </>
  );
};

const AmountTypeToggle = ({
  current,
  onChange,
  selectedAmountTypes,
}: {
  current: CategoryAmountType;
  onChange: (type: CategoryAmountType) => void;
  selectedAmountTypes?: CategoryAmountType[];
}) => {
  const partOfSelectedAmountsFilter = (type: CategoryAmountTypeWithProps) =>
    selectedAmountTypes ? selectedAmountTypes.includes(type.type) : true;
  const isActive = (type: CategoryAmountType) =>
    current === type ? "tab-active" : "";
  return (
    // daisyui boxed tab
    <div className="tabs tabs-boxed">
      {amountTypes.filter(partOfSelectedAmountsFilter).map((type) => (
        <button
          key={type.type}
          className={`tab ${isActive(type.type)}`}
          onClick={() => onChange(type.type)}
        >
          {type.label}
        </button>
      ))}
    </div>
  );
};

const CategoryPieChartLegend = ({
  categories,
  excludedCategories,
  onToggleCategory,
  amountType,
}: {
  categories: Category[];
  excludedCategories: string[];
  onToggleCategory: (categoryName: string) => void;
  amountType: CategoryAmountType;
}) => (
  <div className="flex flex-wrap m-2">
    {categories.map((category) => (
      <div
        className="flex items-center mx-2 tooltip"
        data-tip={formatAmount(category[amountType])}
        key={category.uuid}
      >
        <label className="cursor-pointer">
          <input
            type="checkbox"
            checked={!excludedCategories.includes(category.name)}
            onChange={() => onToggleCategory(category.name)}
          />
          <span
            className="ml-2"
            style={{
              color: nameToUniqueColor(category.name),
            }}
          >
            {category.name}
          </span>
        </label>
      </div>
    ))}
  </div>
);
</file>

<file path="packages/web/app/components/charts/mothly-spending-chart.tsx">
"use client";
import React, { MouseEvent, useRef } from "react";
import type { InteractionItem } from "chart.js";
import {
  Chart as ChartJS,
  LinearScale,
  CategoryScale,
  BarElement,
  PointElement,
  LineElement,
  Legend,
  Tooltip,
} from "chart.js";
import { useRouter } from "next/navigation";
import { Bar, getElementAtEvent } from "react-chartjs-2";
import { MonthlySpendingData } from "./util";

ChartJS.register(
  LinearScale,
  CategoryScale,
  BarElement,
  PointElement,
  LineElement,
  Legend,
  Tooltip
);

export const options = {
  responsive: true,
  scales: {
    y: {
      beginAtZero: true,
    },
  },
};

type Props = {
  spendingData: MonthlySpendingData[];
  categoryUuid: string;
  month: string;
  budgetUuid: string;
};

export const MonthlySpendingChart = ({
  spendingData,
  month,
  categoryUuid,
  budgetUuid,
}: Props) => {
  const router = useRouter();

  const data = {
    labels: spendingData.map((data) => data.dayOfMonth),
    datasets: [
      {
        type: "bar" as const,
        label: "Dataset 1",
        data: spendingData.map((data) => data.spent),
        borderColor: "rgb(255, 99, 132)",
        backgroundColor: "rgba(255, 99, 132, 0.5)",
        datalabels: {
          formatter: (value: string, context: any) => {
            return "";
          },
        },
      },
    ],
  };

  const printDatasetAtEvent = (dataset: InteractionItem[]) => {
    if (!dataset.length) return;

    const datasetIndex = dataset[0].datasetIndex;

    console.log(data.datasets[datasetIndex].label);
  };

  type Props = {
    spendingData: MonthlySpendingData[];
  };

  // see https://react-chartjs-2.js.org/examples/chart-events for handling more data
  const handleChartEvent = (element: InteractionItem[]) => {
    if (!element.length) return;

    const { index } = element[0];
    const { labels } = data;
    const dayOfMonth = labels[index];
    // todo: should parent be client component that handles this?
    router.push(
      `/budgets/${budgetUuid}/transactions?month=${month}&dayOfMonth=${dayOfMonth}&categoryUuid=${categoryUuid}`
    );
  };

  const chartRef = useRef<any>(null);

  const onClick = (event: MouseEvent<HTMLCanvasElement>) => {
    const { current: chart } = chartRef;
    if (!chart) {
      return;
    }
    handleChartEvent(getElementAtEvent(chart, event));
  };

  return <Bar options={options} data={data} onClick={onClick} ref={chartRef} />;
};
</file>

<file path="packages/web/app/components/charts/payee-activity-chart.tsx">
"use client";
import React, { useRef, useState, MouseEvent } from "react";
import {
  Chart as ChartJS,
  ArcElement,
  Tooltip,
  Legend,
} from "chart.js";
import { Pie } from "react-chartjs-2";
import ChartDataLabels from "chartjs-plugin-datalabels";

const MIN_PERCENTAGE_TO_DISPLAY = 4;

ChartJS.register(ArcElement, Tooltip, Legend, ChartDataLabels);

import { chartFormatter, isOnMobileDevice, nameToUniqueColor, valueToPercentageOfTotal } from "./util";
import { Category, isInflowCategory, PayeeWithActivity } from "common-ts";
import { absoluteD1000Number, formatAmount } from "common-ts";

type Props = {
  payeesWithActivities: PayeeWithActivity[];
};

const options = {
  plugins: {
    legend: {
      display: false,
    },
  },
};

export const PayeeActivityChart = ({
  payeesWithActivities
}: Props) => {

  // payees to exclude from pie chart state
  const [excludedPayees, setExcludedPayees] = useState<string[]>([]);
  const nonExcludedPayees = payeesWithActivities.filter(
    (payee) => !excludedPayees.includes(payee.payeeName)
  );
  const totalAmount = absoluteD1000Number(
    nonExcludedPayees.reduce(
      (total, PayeeWithActivity) => total + PayeeWithActivity.activity,
      0
    )
  );

  const data = {
    labels: nonExcludedPayees.map((payee) => payee.payeeName),
    datasets: [
      {
        type: "pie" as const,
        label: "Payee Activity",
        data: nonExcludedPayees.map((payeeWithActivity) =>
          absoluteD1000Number(payeeWithActivity.activity)
        ),
        borderColor: "rgb(255, 99, 132)",
        backgroundColor: nonExcludedPayees.map((payeeWithActivity) =>
          nameToUniqueColor(payeeWithActivity.payeeName)
        ),
        datalabels: {
          //black
          color: "#000000",
          formatter: chartFormatter(totalAmount, MIN_PERCENTAGE_TO_DISPLAY),
        },
      },
    ],
  };

  const chartRef = useRef<any>(null);

  const togglePayee = (payeeName: string) => {
    setExcludedPayees((excludedPayees) =>
      excludedPayees.includes(payeeName)
        ? excludedPayees.filter((payee) => payee !== payeeName)
        : [...excludedPayees, payeeName]
    );
  };

  return (
    <>
      <PayeeChartLegend
        payeesWithActivity={payeesWithActivities}
        excludedPayees={excludedPayees}
        onTogglePayee={togglePayee}
      />
      <Pie data={data} ref={chartRef} options={options} />
    </>
  );
};


const PayeeChartLegend = ({
  payeesWithActivity,
  excludedPayees,
  onTogglePayee,
}: {
  payeesWithActivity: PayeeWithActivity[];
  excludedPayees: string[];
  onTogglePayee: (payeeName: string) => void;
}) => (
  <div className="flex flex-wrap m-2">
    {payeesWithActivity.map((payee) => (
      <div
        className="flex items-center mx-2 tooltip"
        data-tip={formatAmount(payee.activity)}
        key={payee.payeeName}
      >
        <label className="cursor-pointer">
          <input
            type="checkbox"
            checked={!excludedPayees.includes(payee.payeeName)}
            onChange={() => onTogglePayee(payee.payeeName)}
          />
          <span
            className="ml-2"
            style={{
              color: nameToUniqueColor(payee.payeeName),
            }}
          >
            {payee.payeeName}
          </span>
        </label>
      </div>
    ))}
  </div>
);
</file>

<file path="packages/web/app/components/transactions-page/category-editor.tsx">
"use client";

import React, { useState } from 'react';
import { Category } from 'common-ts';
import { FaCheck, FaTimes, FaEdit } from 'react-icons/fa';

interface CategoryEditorProps {
  // Current category information
  currentCategoryName?: string;
  currentCategoryId?: string;
  
  // Available categories
  categories: Category[];
  
  // Callbacks
  onSave: (categoryId: string, categoryName: string) => Promise<void>;
  onCancel?: () => void;
  
  // Display options
  showEditButton?: boolean;
  placeholder?: string;
  className?: string;
  
  // Loading state
  isLoading?: boolean;
  
  // Size variants
  size?: 'sm' | 'md' | 'lg';
}

export const CategoryEditor: React.FC<CategoryEditorProps> = ({
  currentCategoryName,
  currentCategoryId,
  categories,
  onSave,
  onCancel,
  showEditButton = true,
  placeholder = "Select category",
  className = '',
  isLoading = false,
  size = 'sm'
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [selectedCategoryId, setSelectedCategoryId] = useState(currentCategoryId || '');
  const [isSaving, setIsSaving] = useState(false);

  const handleStartEdit = () => {
    setIsEditing(true);
    setSelectedCategoryId(currentCategoryId || '');
  };

  const handleCancel = () => {
    setIsEditing(false);
    setSelectedCategoryId(currentCategoryId || '');
    onCancel?.();
  };

  const handleSave = async () => {
    if (!selectedCategoryId) return;
    
    const selectedCategory = categories.find(c => c._id === selectedCategoryId || c.uuid === selectedCategoryId);
    if (!selectedCategory) return;

    setIsSaving(true);
    try {
      await onSave(selectedCategoryId, selectedCategory.name);
      setIsEditing(false);
    } catch (error) {
      console.error('Error saving category:', error);
      // Keep editing mode open on error
    } finally {
      setIsSaving(false);
    }
  };

  const getSizeClasses = () => {
    switch (size) {
      case 'lg':
        return 'text-base px-4 py-2';
      case 'md':
        return 'text-sm px-3 py-2';
      case 'sm':
      default:
        return 'text-xs px-2.5 py-1.5';
    }
  };

  const getButtonSizeClasses = () => {
    switch (size) {
      case 'lg':
        return 'w-8 h-8';
      case 'md':
        return 'w-7 h-7';
      case 'sm':
      default:
        return 'w-6 h-6';
    }
  };

  if (isLoading) {
    return (
      <div className={`inline-flex items-center gap-2 ${getSizeClasses()} ${className}`}>
        <span className="loading loading-dots loading-sm"></span>
        <span className="text-slate-500">Loading...</span>
      </div>
    );
  }

  if (!isEditing) {
    return (
      <div className={`inline-flex items-center gap-2 ${className}`}>
        {currentCategoryName ? (
          <span className={`inline-flex items-center px-3 py-1.5 rounded-full text-sm font-medium bg-slate-100 text-slate-700 border border-slate-200 dark:bg-slate-800 dark:text-slate-300 dark:border-slate-700 ${getSizeClasses()}`}>
            {currentCategoryName}
          </span>
        ) : (
          <span className={`inline-flex items-center px-3 py-1.5 rounded-full text-sm font-medium bg-gray-50 text-gray-500 border border-gray-200 dark:bg-gray-900 dark:text-gray-500 dark:border-gray-700 ${getSizeClasses()}`}>
            No category
          </span>
        )}
        
        {showEditButton && (
          <button
            onClick={handleStartEdit}
            className={`inline-flex items-center justify-center rounded-full bg-blue-100 text-blue-600 hover:bg-blue-200 dark:bg-blue-900/20 dark:text-blue-400 dark:hover:bg-blue-900/40 transition-colors ${getButtonSizeClasses()}`}
            title="Edit category"
          >
            <FaEdit className="w-3 h-3" />
          </button>
        )}
      </div>
    );
  }

  return (
    <div className={`inline-flex items-center gap-2 ${className}`}>
      <select
        value={selectedCategoryId}
        onChange={(e) => setSelectedCategoryId(e.target.value)}
        className={`rounded-lg border border-slate-300 bg-white text-slate-700 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20 dark:border-slate-600 dark:bg-slate-800 dark:text-slate-300 dark:focus:border-blue-400 ${getSizeClasses()}`}
        disabled={isSaving}
      >
        <option value="">{placeholder}</option>
        {categories.map((category) => (
          <option key={category._id || category.uuid} value={category._id || category.uuid}>
            {category.name}
          </option>
        ))}
      </select>
      
      <button
        onClick={handleSave}
        disabled={!selectedCategoryId || isSaving}
        className={`inline-flex items-center justify-center rounded-full bg-emerald-100 text-emerald-600 hover:bg-emerald-200 disabled:opacity-50 disabled:cursor-not-allowed dark:bg-emerald-900/20 dark:text-emerald-400 dark:hover:bg-emerald-900/40 transition-colors ${getButtonSizeClasses()}`}
        title="Save category"
      >
        {isSaving ? (
          <span className="loading loading-spinner loading-xs"></span>
        ) : (
          <FaCheck className="w-3 h-3" />
        )}
      </button>
      
      <button
        onClick={handleCancel}
        disabled={isSaving}
        className={`inline-flex items-center justify-center rounded-full bg-red-100 text-red-600 hover:bg-red-200 disabled:opacity-50 disabled:cursor-not-allowed dark:bg-red-900/20 dark:text-red-400 dark:hover:bg-red-900/40 transition-colors ${getButtonSizeClasses()}`}
        title="Cancel"
      >
        <FaTimes className="w-3 h-3" />
      </button>
    </div>
  );
};

export default CategoryEditor;
</file>

<file path="packages/web/app/components/transactions-page/payee-chart.tsx">
import { PayeeWithActivity } from "common-ts";
import { PayeeActivityChart } from "../charts/payee-activity-chart";

export const PayeeChart = ({
    payeesWithActivities
}: {
    payeesWithActivities: PayeeWithActivity[];
}) => {
    return (
        <PayeeActivityChart payeesWithActivities={payeesWithActivities.sort(
            (a, b) => b.activity - a.activity
        )} />
    );
}
</file>

<file path="packages/web/app/components/transactions-page/payee-tooltip.tsx">
interface PayeeTooltipProps {
  cleanPayeeName: string;
  fullPayeeName?: string;
  className?: string;
}

export function PayeeTooltip({ cleanPayeeName, fullPayeeName, className = '' }: PayeeTooltipProps) {
  // Don't show tooltip if no full payee name or if it's the same as clean name
  const shouldShowTooltip = fullPayeeName &&
    fullPayeeName.trim() !== '' &&
    fullPayeeName !== cleanPayeeName;

  if (!shouldShowTooltip) {
    return (
      <div className={`font-semibold text-lg dark:text-white truncate text-left ${className}`}>
        {cleanPayeeName}
      </div>
    );
  }

  return (
    <div className={`tooltip tooltip-top ${className}`} data-tip={fullPayeeName}>
      <div className="font-semibold text-lg dark:text-white truncate cursor-help text-left">
        {cleanPayeeName}
      </div>
    </div>
  );
}
</file>

<file path="packages/web/app/components/transactions-page/transaction-amount.tsx">
import { formatAmount } from "common-ts";

export const TransactionAmount = ({
    amount,
}: {
    amount: number;
}) => {
    return (
        <div
            className={`font-bold text-lg ${amount >= 0 ? "text-green-500 dark:text-green-200" : "text-red-500 dark:text-red-300"
                }  `}
        >
            {formatAmount(amount)}
        </div>
    );
};
</file>

<file path="packages/web/app/components/transactions-page/transaction-badge.tsx">
import React from 'react';
import { FaRobot, FaPencilAlt, FaExclamationTriangle, FaClock } from 'react-icons/fa';

export type BadgeType =
  | 'ai-cached'
  | 'ai-generated'
  | 'ai-uncategorized'
  | 'manual-edit'
  | 'uncategorized'
  | 'loading'
  | 'no-suggestion'
  | 'approved'
  | 'pending-approval';

interface TransactionBadgeProps {
  type: BadgeType;
  text?: string;
  className?: string;
  size?: 'xs' | 'sm' | 'md' | 'lg';
}

export const TransactionBadge: React.FC<TransactionBadgeProps> = ({
  type,
  text,
  className = '',
  size = 'sm'
}) => {
  const getBadgeConfig = () => {
    switch (type) {
      case 'ai-cached':
        return {
          className: 'bg-emerald-100 text-emerald-800 border border-emerald-200 dark:bg-emerald-900/20 dark:text-emerald-300 dark:border-emerald-800',
          icon: <FaRobot className="w-3 h-3" />,
          defaultText: 'AI (Cached)',
          textColor: ''
        };
      case 'ai-generated':
        return {
          className: 'bg-blue-100 text-blue-800 border border-blue-200 dark:bg-blue-900/20 dark:text-blue-300 dark:border-blue-800',
          icon: <FaRobot className="w-3 h-3" />,
          defaultText: 'AI (Generated)',
          textColor: ''
        };
      case 'ai-uncategorized':
        return {
          className: 'bg-amber-100 text-amber-800 border border-amber-200 dark:bg-amber-900/20 dark:text-amber-300 dark:border-amber-800',
          icon: <FaRobot className="w-3 h-3" />,
          defaultText: 'AI (Uncategorized)',
          textColor: ''
        };
      case 'manual-edit':
        return {
          className: 'bg-amber-100 text-amber-800 border border-amber-200 dark:bg-amber-900/20 dark:text-amber-300 dark:border-amber-800',
          icon: <FaPencilAlt className="w-3 h-3" />,
          defaultText: 'Manual Edit',
          textColor: ''
        };
      case 'uncategorized':
        return {
          className: 'bg-red-100 text-red-800 border border-red-200 dark:bg-red-900/20 dark:text-red-300 dark:border-red-800',
          icon: <FaExclamationTriangle className="w-3 h-3" />,
          defaultText: 'Uncategorized',
          textColor: ''
        };
      case 'loading':
        return {
          className: 'bg-gray-100 text-gray-600 border border-gray-200 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-700',
          icon: <span className="loading loading-spinner loading-xs"></span>,
          defaultText: 'Loading...',
          textColor: ''
        };
      case 'no-suggestion':
        return {
          className: 'bg-gray-50 text-gray-500 border border-gray-200 dark:bg-gray-900 dark:text-gray-500 dark:border-gray-700',
          icon: <FaExclamationTriangle className="w-3 h-3" />,
          defaultText: 'No Suggestion',
          textColor: ''
        };
      case 'approved':
        return {
          className: 'bg-emerald-100 text-emerald-800 border border-emerald-200 dark:bg-emerald-900/20 dark:text-emerald-300 dark:border-emerald-800',
          icon: null,
          defaultText: 'Approved',
          textColor: ''
        };
      case 'pending-approval':
        return {
          className: 'bg-amber-100 text-amber-800 border border-amber-200 dark:bg-amber-900/20 dark:text-amber-300 dark:border-amber-800',
          icon: <FaClock className="w-3 h-3" />,
          defaultText: 'Pending',
          textColor: ''
        };
      default:
        return {
          className: 'bg-gray-100 text-gray-600 border border-gray-200 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-700',
          icon: null,
          defaultText: 'Unknown',
          textColor: ''
        };
    }
  };

  const config = getBadgeConfig();
  const displayText = text || config.defaultText;

  return (
    <span
      className={`inline-flex items-center gap-1 px-2.5 py-1 rounded-full text-xs font-medium ${config.className} ${className}`}
      title={displayText}
    >
      {config.icon}
      <span className="truncate max-w-24 sm:max-w-32 md:max-w-none">
        {displayText}
      </span>
    </span>
  );
};

// Category badge for displaying category names
interface CategoryBadgeProps {
  categoryName: string;
  isManuallyModified?: boolean;
  isUncategorized?: boolean;
  isCached?: boolean;
  className?: string;
  size?: 'xs' | 'sm' | 'md' | 'lg';
}

export const CategoryBadge: React.FC<CategoryBadgeProps> = ({
  categoryName,
  isManuallyModified = false,
  isUncategorized = false,
  isCached = false,
  className = '',
  size = 'sm'
}) => {
  const getBadgeClass = () => {
    if (isManuallyModified) return 'bg-amber-100 text-amber-800 border border-amber-200 dark:bg-amber-900/20 dark:text-amber-300 dark:border-amber-800';
    if (isUncategorized) return 'bg-red-100 text-red-800 border border-red-200 dark:bg-red-900/20 dark:text-red-300 dark:border-red-800';
    if (isCached) return 'bg-emerald-100 text-emerald-800 border border-emerald-200 dark:bg-emerald-900/20 dark:text-emerald-300 dark:border-emerald-800';
    return 'bg-slate-100 text-slate-700 border border-slate-200 dark:bg-slate-800 dark:text-slate-300 dark:border-slate-700';
  };

  return (
    <span
      className={`inline-flex items-center px-3 py-1.5 rounded-full text-sm font-medium ${getBadgeClass()} ${className}`}
      title={categoryName}
    >
      <span className="truncate max-w-24 sm:max-w-32 md:max-w-none">
        {categoryName}
      </span>
    </span>
  );
};
</file>

<file path="packages/web/app/components/transactions-page/transaction-content.tsx">
"use client";
import { useState } from "react";
import CategorySelect from "./category-select";
import { CategoryPieChart } from "../charts/category-pie-chart";
import {
  GroupedTransactions,
  Category,
  formatAmount,
  Transaction,
  PayeeWithActivity,

} from "common-ts";
import { calculateTotals, formatDate, groupByDate } from "./utils";
import { FaArrowDown, FaArrowUp, FaChartBar, FaChartPie, FaList } from "react-icons/fa";
import { TransactionList } from "./transaction-list";
import { TransactionTotals } from "./transaction-totals";
import { PayeeActivityChart } from "../charts/payee-activity-chart";
import { payeeWithActivityReducer } from "./payeeWithActivity-reducer";
import { PayeeChart } from "./payee-chart";

const TransactionContent = ({
  budgetUuid,
  categoryUuid,
  categories,
  transactions,
  month,
}: {
  budgetUuid: string;
  categoryUuid?: string;
  month?: string;
  categories: Category[];
  transactions: Transaction[];
}) => {
  const [viewMode, setViewMode] = useState("list");
  const [newCategoryUuid, setNewCategoryUuid] = useState(categoryUuid);
  const usedCategoryUuid = newCategoryUuid || categoryUuid;

  const groupedTransactions = groupByDate(transactions);

  const toggleView = (mode: string) => {
    setViewMode(mode);
  };

  const usedCategoryId = categories.find(
    (category) => category.uuid === usedCategoryUuid
  )?._id;

  const categoryFilter = (transaction: Transaction) =>
    usedCategoryId === undefined || transaction.categoryId === usedCategoryId;

  const filteredTransactions = transactions.filter(categoryFilter);
  const payeesWithActivities = filteredTransactions.reduce(payeeWithActivityReducer, []);
  const categoryPieChartDisabled = categoryUuid ? true : false;
  return (
    <>
      <h1 className="m-2">Transactions {month}</h1>
      <CategorySelect
        categoryUuid={usedCategoryUuid}
        categories={categories}
        onChange={setNewCategoryUuid}
      />
      <>
        <div className="p-4">
          <h1 className="text-lg font-bold text-center mb-4 dark:text-white">
            Bank Transactions
          </h1>
          <div>
            <button onClick={() => toggleView("graph")} className="p-2 disabled" disabled={categoryPieChartDisabled}>
              <FaChartBar title="Show Graph" className={categoryPieChartDisabled ? "text-gray-400" : "text-current"}
              />
            </button>
            <button onClick={() => toggleView("list")} className="p-2">
              <FaList title="Show List" />
            </button>
            <button onClick={() => toggleView("payeeChart")} className="p-2">
              <FaChartPie title="Show payee overview" />
            </button>
          </div>
          <TransactionTotals transactions={filteredTransactions} />
        </div>
        {viewMode === "graph" && (
          <CategoryPieChart
            month={month || ""}
            categories={categories}
            selectedAmountTypes={["activity"]}
            budgetUuid={budgetUuid}
          />
        )}
        {viewMode === "list" && (
          <TransactionList
            transactions={filteredTransactions}
            categories={categories}
            budgetUuid={budgetUuid}
            enableCategoryEdit={true}
          />
        )}
        {viewMode === "payeeChart" && (
          <PayeeChart payeesWithActivities={payeesWithActivities} />
        )}
      </>
    </>
  );
};

export default TransactionContent;
</file>

<file path="packages/web/app/components/transactions-page/transaction-date-group.tsx">
import React, { useState } from 'react';
import { formatAmount } from 'common-ts';
import { formatDate, calculateTotalsGeneric } from './utils';
import { FaArrowDown, FaArrowUp, FaChevronDown, FaChevronRight } from 'react-icons/fa';

interface TransactionDateGroupProps<T extends { date: string; amount: number }> {
  date: string;
  transactions: T[];
  children: React.ReactNode;

  // Display options
  showTotals?: boolean;
  showTransactionCount?: boolean;
  defaultOpen?: boolean;

  // Styling
  className?: string;
  headerClassName?: string;
  contentClassName?: string;

  // Custom totals calculation (if transactions have different structure)
  customTotals?: {
    income: number;
    outcome: number;
  };
}

export function TransactionDateGroup<T extends { date: string; amount: number }>({
  date,
  transactions,
  children,
  showTotals = true,
  showTransactionCount = true,
  defaultOpen = false,
  className = '',
  headerClassName = '',
  contentClassName = '',
  customTotals
}: TransactionDateGroupProps<T>) {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  const toggleOpen = () => setIsOpen(!isOpen);

  // Calculate totals
  const totals = customTotals || calculateTotalsGeneric(transactions);

  return (
    <div className={`bg-white dark:bg-slate-900 rounded-xl shadow-sm border border-slate-200 dark:border-slate-700 overflow-hidden ${className}`}>
      {/* Header */}
      <button
        onClick={toggleOpen}
        className={`w-full text-left p-5 bg-gradient-to-r from-slate-50 to-gray-50 dark:from-slate-800 dark:to-gray-800 hover:from-slate-100 hover:to-gray-100 dark:hover:from-slate-700 dark:hover:to-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-inset flex justify-between items-center transition-all duration-200 ${headerClassName}`}
        aria-expanded={isOpen}
        aria-controls={`transactions-${date}`}
      >
        {/* Left side - Date and count */}
        <div className="flex items-center gap-3">
          <div className="flex items-center gap-2">
            {isOpen ? (
              <FaChevronDown className="w-4 h-4 text-gray-500" />
            ) : (
              <FaChevronRight className="w-4 h-4 text-gray-500" />
            )}
            <span className="font-semibold text-lg">{formatDate(date)}</span>
          </div>

          {showTransactionCount && (
            <div className="inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium bg-slate-100 text-slate-700 border border-slate-200 dark:bg-slate-800 dark:text-slate-300 dark:border-slate-700">
              {transactions.length} transaction{transactions.length !== 1 ? 's' : ''}
            </div>
          )}
        </div>

        {/* Right side - Totals */}
        {showTotals && (
          <div className="flex items-center gap-4">
            {/* Income */}
            {totals.income > 0 && (
              <div className="flex items-center gap-2">
                <FaArrowUp className="text-green-500 w-4 h-4" />
                <span className="font-bold text-green-600">
                  {formatAmount(totals.income)}
                </span>
              </div>
            )}

            {/* Outcome */}
            {totals.outcome < 0 && (
              <div className="flex items-center gap-2">
                <FaArrowDown className="text-red-500 w-4 h-4" />
                <span className="font-bold text-red-600">
                  {formatAmount(Math.abs(totals.outcome))}
                </span>
              </div>
            )}

            {/* Net total if both income and outcome exist */}
            {totals.income > 0 && totals.outcome < 0 && (
              <div className="hidden sm:flex items-center gap-2 border-l pl-4 ml-2">
                <span className="text-sm text-gray-500">Net:</span>
                <span className={`font-bold ${(totals.income + totals.outcome) >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                  {formatAmount(totals.income + totals.outcome)}
                </span>
              </div>
            )}
          </div>
        )}
      </button>

      {/* Content */}
      {isOpen && (
        <div
          id={`transactions-${date}`}
          className={`p-5 space-y-3 bg-white dark:bg-slate-900 ${contentClassName}`}
        >
          {children}
        </div>
      )}
    </div>
  );
}

// Simplified version for basic transaction lists
interface SimpleTransactionDateGroupProps {
  date: string;
  transactionCount: number;
  income: number;
  outcome: number;
  children: React.ReactNode;
  defaultOpen?: boolean;
  className?: string;
}

export function SimpleTransactionDateGroup({
  date,
  transactionCount,
  income,
  outcome,
  children,
  defaultOpen = false,
  className = ''
}: SimpleTransactionDateGroupProps) {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className={`mb-4 ${className}`}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full text-left text-md font-semibold py-2 px-4 bg-gray-100 dark:bg-gray-800 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none flex justify-between items-center"
        aria-expanded={isOpen}
        aria-controls={`simple-transactions-${date}`}
      >
        <span>{formatDate(date)}</span>
        <span className="flex items-center">
          <FaArrowUp className="text-green-500 mr-2" />
          <span className="font-bold mr-4">
            {formatAmount(income)}
          </span>
          <FaArrowDown className="text-red-500 mr-2" />
          <span className="font-bold">
            {formatAmount(Math.abs(outcome))}
          </span>
        </span>
      </button>

      {isOpen && (
        <div id={`simple-transactions-${date}`} className="mt-2 space-y-2">
          {children}
        </div>
      )}
    </div>
  );
}
</file>

<file path="packages/web/app/components/transactions-page/transaction-totals.tsx">
import { Transaction } from "common-ts";
import { TransactionAmount } from "./transaction-amount";

export const TransactionTotals = ({
    transactions,
}: {
    transactions: Transaction[];
}) => {
    const total = transactions.reduce((acc, transaction) => acc + transaction.amount, 0);
    const totalInflow = transactions.reduce((acc, transaction) => transaction.amount > 0 ? acc + transaction.amount : acc, 0);
    const totalOutflow = transactions.reduce((acc, transaction) => transaction.amount < 0 ? acc + transaction.amount : acc, 0);

    return (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 p-6 bg-gradient-to-r from-slate-50 to-gray-50 dark:from-slate-900 dark:to-gray-900 rounded-xl border border-slate-200 dark:border-slate-700">
            {/* Total */}
            <div className="text-center">
                <div className="text-sm font-medium text-slate-600 dark:text-slate-400 mb-1">
                    Total
                </div>
                <div className="text-2xl font-bold">
                    <TransactionAmount amount={total} />
                </div>
            </div>

            {/* Inflow */}
            <div className="text-center">
                <div className="text-sm font-medium text-slate-600 dark:text-slate-400 mb-1">
                    Inflow
                </div>
                <div className="text-2xl font-bold text-emerald-600 dark:text-emerald-400">
                    <TransactionAmount amount={totalInflow} />
                </div>
            </div>

            {/* Outflow */}
            <div className="text-center">
                <div className="text-sm font-medium text-slate-600 dark:text-slate-400 mb-1">
                    Outflow
                </div>
                <div className="text-2xl font-bold text-red-600 dark:text-red-400">
                    <TransactionAmount amount={Math.abs(totalOutflow)} />
                </div>
            </div>
        </div>
    );
}
</file>

<file path="packages/web/app/components/transactions-page/utils.tsx">
import moment from "moment";
import {
  GroupedTransactions,
  Transaction,
} from "common-ts";

export const formatDate = (dateString: string): string => {
  return moment(dateString).format("dddd, MMMM Do YYYY");
};

export const groupByDate = (
  transactions: Transaction[]
): GroupedTransactions => {
  return transactions.reduce(
    (groups: GroupedTransactions, transaction: Transaction) => {
      const date = transaction.date;
      if (!groups[date]) {
        groups[date] = [];
      }
      groups[date].push(transaction);
      return groups;
    },
    {}
  );
};

export const calculateTotals = (
  transactions: Transaction[]
): { income: number; outcome: number } => {
  return transactions.reduce(
    ({ income, outcome }, transaction) => {
      if (transaction.amount >= 0) {
        income += transaction.amount;
      } else {
        outcome += transaction.amount;
      }
      return { income, outcome };
    },
    { income: 0, outcome: 0 }
  );
};

// Generic grouping function that works with any transaction-like object
export const groupByDateGeneric = <T extends { date: string }>(
  transactions: T[]
): { [date: string]: T[] } => {
  return transactions.reduce(
    (groups: { [date: string]: T[] }, transaction: T) => {
      const date = transaction.date;
      if (!groups[date]) {
        groups[date] = [];
      }
      groups[date].push(transaction);
      return groups;
    },
    {}
  );
};

// Generic totals calculation for any transaction-like object with amount
export const calculateTotalsGeneric = <T extends { amount: number }>(
  transactions: T[]
): { income: number; outcome: number } => {
  return transactions.reduce(
    ({ income, outcome }, transaction) => {
      if (transaction.amount >= 0) {
        income += transaction.amount;
      } else {
        outcome += transaction.amount;
      }
      return { income, outcome };
    },
    { income: 0, outcome: 0 }
  );
};
</file>

<file path="packages/web/app/components/budget-sub-navigation.tsx">
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { FaHome, FaCreditCard, FaChartLine, FaRobot } from "react-icons/fa";

interface Props {
    budgetUuid: string;
}

export default function BudgetSubNavigation({ budgetUuid }: Props) {
    const pathname = usePathname();

    const isActive = (path: string) => {
        if (path === `/budgets/${budgetUuid}`) {
            return pathname === path;
        }
        return pathname.startsWith(path);
    };

    const getNavItemClass = (path: string) => {
        const baseClass = "inline-flex items-center gap-3 px-6 py-3 text-sm font-medium rounded-lg transition-all duration-200 relative";

        if (isActive(path)) {
            return `${baseClass} bg-blue-100 text-blue-800 border border-blue-200 dark:bg-blue-900/20 dark:text-blue-300 dark:border-blue-800 shadow-sm`;
        }

        return `${baseClass} text-slate-600 hover:text-slate-800 hover:bg-slate-50 dark:text-slate-400 dark:hover:text-slate-200 dark:hover:bg-slate-800`;
    };

    const navItems = [
        {
            href: `/budgets/${budgetUuid}`,
            icon: <FaHome className="w-4 h-4" />,
            label: "Overview",
            path: `/budgets/${budgetUuid}`
        },
        {
            href: `/budgets/${budgetUuid}/transactions`,
            icon: <FaCreditCard className="w-4 h-4" />,
            label: "Transactions",
            path: `/budgets/${budgetUuid}/transactions`
        },
        {
            href: `/budgets/${budgetUuid}/predictions`,
            icon: <FaChartLine className="w-4 h-4" />,
            label: "Predictions",
            path: `/budgets/${budgetUuid}/predictions`
        },
        {
            href: `/budgets/${budgetUuid}/uncategorised`,
            icon: <FaRobot className="w-4 h-4" />,
            label: "AI Assistant",
            path: `/budgets/${budgetUuid}/uncategorised`
        }
    ];

    return (
        <div className="mb-8">
            <div className="bg-white dark:bg-slate-900 rounded-xl shadow-sm border border-slate-200 dark:border-slate-700 p-2">
                <nav className="flex flex-wrap justify-center gap-2">
                    {navItems.map((item) => (
                        <Link
                            key={item.path}
                            href={item.href}
                            className={getNavItemClass(item.path)}
                        >
                            {item.icon}
                            <span className="hidden sm:inline">{item.label}</span>

                            {/* Active indicator */}
                            {isActive(item.path) && (
                                <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-8 h-0.5 bg-blue-500 rounded-full"></div>
                            )}
                        </Link>
                    ))}
                </nav>
            </div>
        </div>
    );
}
</file>

<file path="packages/web/app/hooks/use-category-update.ts">
"use client";

import { useState } from "react";
import { updateTransactionCategory } from "../budgets/[budgetUuid]/transactions/actions";

interface UseCategoryUpdateOptions {
  budgetId: string;
  onSuccess?: (transactionId: string, categoryName: string) => void;
  onError?: (error: Error) => void;
}

export const useCategoryUpdate = ({
  budgetId,
  onSuccess,
  onError,
}: UseCategoryUpdateOptions) => {
  const [isUpdating, setIsUpdating] = useState(false);
  const [updatingTransactionId, setUpdatingTransactionId] = useState<
    string | null
  >(null);

  const updateCategory = async (
    transactionId: string,
    _categoryId: string, // Not used but kept for API compatibility
    categoryName: string,
    isManualChange: boolean = true
  ) => {
    setIsUpdating(true);
    setUpdatingTransactionId(transactionId);

    try {
      // Call Server Action
      const result = await updateTransactionCategory(
        budgetId,
        transactionId,
        categoryName,
        isManualChange
      );

      if (result.success) {
        onSuccess?.(transactionId, categoryName);
        return result;
      } else {
        throw new Error(result.error ?? "Failed to update category");
      }
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error occurred";
      onError?.(new Error(errorMessage));
      throw error;
    } finally {
      setIsUpdating(false);
      setUpdatingTransactionId(null);
    }
  };

  return {
    updateCategory,
    isUpdating,
    updatingTransactionId,
    isUpdatingTransaction: (transactionId: string) =>
      updatingTransactionId === transactionId,
  };
};

export default useCategoryUpdate;
</file>

<file path="packages/web/app/utils/functional.ts">
import * as R from "ramda";

type AsyncFunction<T, R> = (input: T) => Promise<R>;

export const pipeP =
  <T, R>(...fns: AsyncFunction<any, any>[]): AsyncFunction<T, R> =>
  (input: T): Promise<R> =>
    fns.reduce<Promise<any>>(
      (promise, fn) => promise.then(fn),
      Promise.resolve(input)
    );

export const composeP = <T, R>(
  ...fns: AsyncFunction<any, any>[]
): AsyncFunction<T, R> => pipeP(...fns.reverse());
</file>

<file path="packages/web/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-[color,box-shadow] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Button = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }
>(({ className, variant, size, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
})
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="packages/web/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row gap-2",
        month: "flex flex-col gap-4",
        caption: "flex justify-center pt-1 relative items-center w-full",
        caption_label: "text-sm font-medium",
        nav: "flex items-center gap-1",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "size-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-x-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "size-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start:
          "day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_range_end:
          "day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("size-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("size-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}

export { Calendar }
</file>

<file path="packages/web/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

const DialogTrigger = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Trigger>
>(({ ...props }, ref) => (
  <DialogPrimitive.Trigger ref={ref} data-slot="dialog-trigger" {...props} />
))
DialogTrigger.displayName = "DialogTrigger"

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

const DialogClose = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Close>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Close>
>(({ ...props }, ref) => (
  <DialogPrimitive.Close ref={ref} data-slot="dialog-close" {...props} />
))
DialogClose.displayName = "DialogClose"

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    data-slot="dialog-overlay"
    className={cn(
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = "DialogOverlay"

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal data-slot="dialog-portal">
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      data-slot="dialog-content"
      className={cn(
        "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
        <XIcon />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = "DialogContent"

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="packages/web/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "border-input file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="packages/web/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="packages/web/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="packages/web/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex h-9 w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("px-2 py-1.5 text-sm font-medium", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="packages/web/components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground font-medium",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground font-medium",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="packages/web/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 inline-flex h-5 w-9 shrink-0 items-center rounded-full border-2 border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background pointer-events-none block size-4 rounded-full ring-0 shadow-lg transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }
</file>

<file path="packages/web/lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="packages/web/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="packages/web/Dockerfile">
# Use a node image as base
FROM node:20-alpine AS base
 
# Add build arguments
ARG NEXT_PUBLIC_SENTRY_ENABLED=false
ENV NEXT_PUBLIC_SENTRY_ENABLED=$NEXT_PUBLIC_SENTRY_ENABLED

WORKDIR /app

# Copy the root package.json, package-lock.json
COPY ../../package.json ../../package-lock.json ./

# Copy only the web package to the container
COPY ../../packages/web ./packages/web
COPY ../../packages/common-ts ./packages/common-ts

# Copy the root tsconfig.json
COPY ../../tsconfig.json ./

# Install dependencies and bootstrap with npm workspaces
RUN npm install

# Build the common-ts package first
RUN npm run build --workspace common-ts

# Build the web package
RUN NEXT_PUBLIC_SENTRY_ENABLED=false npm run build --workspace web

# Set the working directory to the web package
WORKDIR /app/packages/web

# Expose the port
EXPOSE 3000

# Start the application
CMD ["npm", "start"]
</file>

<file path="packages/web/postcss.config.js">
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
</file>

<file path="packages/web/vitest.setup.ts">
import '@testing-library/jest-dom'
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.
.sentryclirc
# dependencies
node_modules
.pnp
.pnp.js
.vscode
# testing
coverage

# next.js
.next/
out/

# production
build
dist

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.env
*secrets.env
test.yml
.kubectl-dev.md
.next

__pycache__

/kube/dev/api-deployment.yml
/kube/dev/web-deployment.yml
/kube/dev/ai-deployment.yml

# Documentation
.docs/
</file>

<file path="test-endpoint-migration.js">
#!/usr/bin/env node
/**
 * Integration test script to verify endpoint migration from Python to Node.js
 * Run this after starting both services to ensure no endpoints are broken
 */

const https = require('https');
const http = require('http');

// Test configuration
const PYTHON_API_BASE = 'http://localhost:5000';
const NODE_API_BASE = 'http://localhost:4000';
const TEST_BUDGET_ID = 'test-budget-123';

// Mock auth token for testing (replace with real token if needed)
const AUTH_TOKEN = 'test-token';

/**
 * Make HTTP request with promise
 */
function makeRequest(url, options = {}) {
    return new Promise((resolve, reject) => {
        const protocol = url.startsWith('https') ? https : http;
        const requestOptions = {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${AUTH_TOKEN}`,
                ...options.headers
            }
        };

        const req = protocol.request(url, requestOptions, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    const jsonData = data ? JSON.parse(data) : {};
                    resolve({
                        status: res.statusCode,
                        data: jsonData,
                        headers: res.headers
                    });
                } catch (e) {
                    resolve({
                        status: res.statusCode,
                        data: data,
                        headers: res.headers
                    });
                }
            });
        });

        req.on('error', reject);
        
        if (options.body) {
            req.write(options.body);
        }
        
        req.end();
    });
}

/**
 * Test endpoint availability
 */
async function testEndpoint(name, url, options = {}) {
    try {
        console.log(` Testing ${name}...`);
        const response = await makeRequest(url, options);
        
        if (response.status >= 200 && response.status < 300) {
            console.log(`   ${name} - Status: ${response.status}`);
            return true;
        } else if (response.status === 401) {
            console.log(`    ${name} - Status: ${response.status} (Auth required - expected)`);
            return true; // Auth errors are expected in this test
        } else {
            console.log(`   ${name} - Status: ${response.status}`);
            console.log(`     Response: ${JSON.stringify(response.data).substring(0, 200)}...`);
            return false;
        }
    } catch (error) {
        console.log(`   ${name} - Error: ${error.message}`);
        return false;
    }
}

/**
 * Test service availability
 */
async function testServiceHealth(serviceName, baseUrl) {
    console.log(`\n Testing ${serviceName} service health...`);
    
    try {
        const healthUrl = `${baseUrl}/health`;
        const response = await makeRequest(healthUrl);
        
        if (response.status === 200) {
            console.log(`   ${serviceName} service is running`);
            return true;
        } else {
            console.log(`   ${serviceName} service health check failed - Status: ${response.status}`);
            return false;
        }
    } catch (error) {
        console.log(`   ${serviceName} service is not running - ${error.message}`);
        return false;
    }
}

/**
 * Main test function
 */
async function runTests() {
    console.log(' Starting Endpoint Migration Integration Tests');
    console.log('=' * 60);

    // Test service health
    const pythonHealthy = await testServiceHealth('Python API', PYTHON_API_BASE);
    const nodeHealthy = await testServiceHealth('Node.js API', NODE_API_BASE);

    if (!pythonHealthy || !nodeHealthy) {
        console.log('\n One or more services are not running. Please start both services:');
        console.log('   Python API: cd packages/mathapi && python app/app.py');
        console.log('   Node.js API: cd packages/api && npm run dev');
        process.exit(1);
    }

    console.log('\n Testing migrated endpoints...');
    
    // Test migrated endpoints (should work in Node.js, may be removed from Python)
    const migratedTests = [
        {
            name: 'Node.js - Uncategorized Transactions',
            url: `${NODE_API_BASE}/budgets/${TEST_BUDGET_ID}/uncategorized-transactions`
        },
        {
            name: 'Node.js - Unapproved Transactions', 
            url: `${NODE_API_BASE}/budgets/${TEST_BUDGET_ID}/unapproved-transactions`
        },
        {
            name: 'Node.js - Cached AI Suggestions',
            url: `${NODE_API_BASE}/budgets/${TEST_BUDGET_ID}/ai-suggestions/cached`
        },
        {
            name: 'Node.js - AI Suggestion Stats',
            url: `${NODE_API_BASE}/budgets/${TEST_BUDGET_ID}/ai-suggestions/stats`
        }
    ];

    console.log('\n Testing migrated endpoints in Node.js...');
    let migratedPassed = 0;
    for (const test of migratedTests) {
        const passed = await testEndpoint(test.name, test.url);
        if (passed) migratedPassed++;
    }

    // Test remaining Python endpoints (should still work)
    const pythonTests = [
        {
            name: 'Python - Balance Prediction',
            url: `${PYTHON_API_BASE}/balance-prediction/data?budget_id=${TEST_BUDGET_ID}`
        },
        {
            name: 'Python - Suggest Categories',
            url: `${PYTHON_API_BASE}/uncategorised-transactions/suggest-categories?budget_id=${TEST_BUDGET_ID}`
        },
        {
            name: 'Python - Async Suggestions',
            url: `${PYTHON_API_BASE}/uncategorised-transactions/suggestions-async?budget_id=${TEST_BUDGET_ID}`,
            options: {
                method: 'POST',
                body: JSON.stringify({ transaction_ids: ['test-tx-1'] })
            }
        },
        {
            name: 'Python - Single Suggestion',
            url: `${PYTHON_API_BASE}/uncategorised-transactions/suggest-single?budget_id=${TEST_BUDGET_ID}`,
            options: {
                method: 'POST', 
                body: JSON.stringify({ transaction_id: 'test-tx-1' })
            }
        }
    ];

    console.log('\n Testing remaining Python endpoints...');
    let pythonPassed = 0;
    for (const test of pythonTests) {
        const passed = await testEndpoint(test.name, test.url, test.options);
        if (passed) pythonPassed++;
    }

    // Summary
    console.log('\n Test Results Summary:');
    console.log('=' * 40);
    console.log(`Migrated endpoints (Node.js): ${migratedPassed}/${migratedTests.length} passed`);
    console.log(`Remaining endpoints (Python): ${pythonPassed}/${pythonTests.length} passed`);
    
    const totalPassed = migratedPassed + pythonPassed;
    const totalTests = migratedTests.length + pythonTests.length;
    
    if (totalPassed === totalTests) {
        console.log('\n All tests passed! Migration appears successful.');
        process.exit(0);
    } else {
        console.log(`\n  ${totalTests - totalPassed} tests failed. Please check the endpoints.`);
        process.exit(1);
    }
}

// Run tests
runTests().catch(error => {
    console.error(' Test runner failed:', error);
    process.exit(1);
});
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
      "baseUrl": ".",
      "paths": {
        "common-ts": ["packages/common-ts/dist"]
      },
      "composite": true,
      "declaration": true,
      "declarationMap": true,
      "skipLibCheck": true,
      "target": "ES2020",
      "module": "commonjs",
      "moduleResolution": "node",
      "strict": true,
      "esModuleInterop": true,
      "forceConsistentCasingInFileNames": true,
      "noFallthroughCasesInSwitch": true
    },
    "include": ["packages/**/*"]
  }
</file>

<file path="docs/bugfixes/openbugs.md">
# open bugs
## apply all doesn't take into account changed categories
- I changed some categories in the ai assistant screen. when I then pressed apply all they were not applied. only with a single apply
- when applying a change in the uncategorised or unapproved only the number on top in the badge is updated, but the transaction itself and the number below are only upated after a refresh
## wrong payee mapping

### description

\_id
683f03e78200e8996f2eee6d
budget_uuid
"1b443ebf-ea07-4ab7-8fd5-9330bf80608c"
payee_name
"vanden it - gezamenlijke overschrijvingsopdracht referentie 1004982/20"
category_name
"Salery"
original_payee_name
"VANDEN IT BV - Gezamenlijke overschrijvingsopdracht Referentie 1004982"

The mapped payee mapping should be "vandent it" or "vandent IT BV" instead of "vanden it - gezamenlijke overschrijvingsopdracht referentie 1004982/2025"

### proposed solution

Improve the preprocessing of the payee name to remove bank-specific details and keep only the core merchant name. Make sure the part "gezamelijke overschrijvingsopdracht" is not hardcoded but part of the country specific configuration.
Also take into account the sign of the amount to link with a payee
</file>

<file path="docs/new features/category-simulations-future.md">
# Future Simulation Improvements



## Extended Features

1. **Advanced Simulation Management**
   - Copy existing simulations
   - Templates for common scenarios
   - Simulation groups/folders
   - Export/import simulations

2. **Rich Transaction Support**
   - Recurring transactions
   - Transaction templates
   - Bulk transaction import
   - Transaction categories and tags

3. **Advanced Category Features**
   - Percentage-based changes
   - Gradual changes over time
   - Category groups
   - Seasonal patterns

4. **Enhanced UI/UX**
   - Drag-and-drop timeline
   - Visual comparison between simulations
   - Interactive charts and graphs
   - Simulation impact analysis
   - Mobile-friendly interface

5. **Integration Features**
   - Export to Excel/CSV
   - Share simulations between budgets
   - API integration for external tools
   - Webhooks for simulation events

## Technical Improvements

1. **Performance**
   - Caching layer for simulation results
   - Batch processing for large simulations
   - Optimized MongoDB queries
   - Client-side state management

2. **Testing**
   - Comprehensive integration tests
   - Load testing for large simulations
   - Visual regression tests
   - End-to-end test suite
   - Performance benchmarks

3. **Monitoring**
   - Usage analytics
   - Performance metrics
   - Error tracking
   - User behavior analysis

4. **Security**
   - Fine-grained access control
   - Audit logging
   - Rate limiting
   - Input validation

## Future Use Cases

1. **Financial Planning**
   - Retirement planning
   - Mortgage scenarios
   - Investment strategies
   - Debt repayment plans

2. **Business Use**
   - Budget forecasting
   - Cash flow analysis
   - Project cost estimation
   - Revenue projections

3. **Personal Finance**
   - Vacation planning
   - Major purchase planning
   - Savings goals
   - Debt reduction strategies

## Implementation Considerations

1. **Scalability**
   - Horizontal scaling strategy
   - Data partitioning
   - Multi-region support
   - Background job processing

2. **Maintainability**
   - Code documentation
   - API versioning
   - Feature flags
   - Migration strategies

3. **User Experience**
   - Onboarding flow
   - Help documentation
   - Tutorial system
   - Feedback collection
</file>

<file path="docs/new features/end-to-end-encryption.md">
# End-to-End Encryption

For development guidelines, refer to [Best Practices](../best-practices.md)

## Current status
- All financial data is stored in plain text in MongoDB
- Server and DB admins can read all user data
- No data segregation between users beyond basic access control

## Wanted status (MVP)
- Users can safely store their financial data
- Only the user can decrypt their own data
- Server/DB admins cannot read user data
- Basic key management in place
- Minimal impact on existing features

## Implementation Steps

### 1. Client-Side Key Generation
- [ ] Generate encryption key when user first logs in
- [ ] Derive key from user's password using PBKDF2
- [ ] Store encrypted key in browser's localStorage
- [ ] Add key verification on login

### 2. Basic Data Encryption
Start with most sensitive data:
- [ ] Encrypt transaction amounts
- [ ] Encrypt account balances
- [ ] Encrypt category budgeted amounts
- [ ] Store encryption metadata (version, algorithm)

### 3. API Layer Updates
- [ ] Update API endpoints to handle encrypted data
- [ ] Add encryption middleware for requests/responses
- [ ] Validate encrypted data format
- [ ] Error handling for encryption/decryption failures

### 4. Database Changes
- [ ] Update MongoDB schemas for encrypted fields
- [ ] Add indexes that work with encrypted data
- [ ] Migration script for existing data
- [ ] Backup strategy for encrypted data

### 5. Testing & Validation
- [ ] Unit tests for encryption/decryption
- [ ] Integration tests with encrypted data
- [ ] Performance testing
- [ ] Security audit of implementation

## Technical Decisions

### Encryption Algorithm
- Use AES-256-GCM for data encryption
- Use PBKDF2 for key derivation
- Store IV (Initialization Vector) with encrypted data

### Data Format
```typescript
interface EncryptedField {
  iv: string;          // Base64 encoded IV
  data: string;        // Base64 encoded encrypted data
  version: number;     // Encryption version for future upgrades
}
```

### Example Implementation
```typescript
// Key generation
const generateKey = async (password: string, salt: string) => {
  const keyMaterial = await window.crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(password),
    "PBKDF2",
    false,
    ["deriveBits", "deriveKey"]
  );
  
  return window.crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: new TextEncoder().encode(salt),
      iterations: 100000,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    true,
    ["encrypt", "decrypt"]
  );
};

// Encryption
const encrypt = async (data: string, key: CryptoKey) => {
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const encoded = new TextEncoder().encode(data);
  
  const encrypted = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    encoded
  );

  return {
    iv: btoa(String.fromCharCode(...iv)),
    data: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
    version: 1
  };
};
```

## Future Enhancements
- Key rotation mechanism
- Backup key storage
- Recovery procedures
- Shared data between users (e.g., family budgets)
- Hardware security module (HSM) integration

## Security Considerations
- Key storage security
- Browser security limitations
- Network security (MitM attacks)
- Backup security
- Recovery procedures

## Impact on Features
- Slight performance impact due to encryption/decryption
- Need to handle offline access
- Search functionality limitations
- Analytics/reporting complexity

## First Milestone
Get basic encryption working for transaction amounts:
1. Implement key generation and storage
2. Update transaction model for encrypted amounts
3. Implement encryption/decryption in frontend
4. Update relevant API endpoints
5. Test with real YNAB data
6. Verify data is encrypted in MongoDB

This provides a foundation we can build upon while protecting the most sensitive data first.
</file>

<file path="docs/new features/mathapi-production-ready.md">
# Math API Production Ready

For development guidelines, refer to [Best Practices](../best-practices.md)

## Current status
- Development Flask server
- Debug endpoints exposed (interactive views)
- Inconsistent authentication
- Basic error handling
- No proper logging
- No proper monitoring

## Wanted status
- Production-grade WSGI server (Gunicorn)
- Only authenticated endpoints
- Proper security measures
- Comprehensive logging
- Monitoring and health checks
- Performance optimizations

## Implementation Steps

### 1. Security Improvements
- [ ] Remove all debug/interactive endpoints
- [ ] Make authentication mandatory for all endpoints
- [ ] Implement proper rate limiting
- [ ] Add request validation middleware
- [ ] Implement proper CORS settings
- [ ] Add security headers

### 2. Production Server Setup
- [ ] Replace Flask development server with Gunicorn
- [ ] Configure proper worker settings
- [ ] Implement graceful shutdown
- [ ] Add proper process management
- [ ] Configure timeout settings

### 3. Logging & Monitoring
- [ ] Implement structured logging
- [ ] Add request/response logging
- [ ] Configure proper log rotation
- [ ] Add performance metrics
- [ ] Implement proper health checks
- [ ] Add Prometheus metrics

### 4. Performance Optimization
- [ ] Implement proper caching strategy
- [ ] Optimize database queries
- [ ] Add connection pooling
- [ ] Configure proper timeouts
- [ ] Implement circuit breakers for external services

### 5. Documentation & Testing
- [ ] Add API documentation (OpenAPI/Swagger)
- [ ] Add load testing
- [ ] Improve test coverage
- [ ] Add integration tests
- [ ] Document deployment procedures

## Technical Decisions

### Server Configuration
```python
# gunicorn.conf.py
import multiprocessing

# Server socket
bind = "0.0.0.0:5000"
backlog = 2048

# Worker processes
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = "sync"
worker_connections = 1000
timeout = 30
keepalive = 2

# Logging
accesslog = "-"
errorlog = "-"
loglevel = "info"
```

### Example Production Dockerfile
```dockerfile
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# Add Gunicorn
RUN pip install gunicorn

# Add monitoring
RUN pip install prometheus_client

# Non-root user
RUN adduser --disabled-password --gecos "" appuser
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# Start Gunicorn
CMD ["gunicorn", "--config", "gunicorn.conf.py", "app.app:app"]
```

## First Milestone
1. [ ] Remove interactive endpoints
2. [ ] Implement mandatory authentication
3. [ ] Switch to Gunicorn
4. [ ] Add basic monitoring
5. [ ] Update deployment configuration

## Impact
- Improved security
- Better performance
- Proper monitoring
- Production-ready setup
- Easier maintenance

## Dependencies
- Gunicorn
- Prometheus client
- Structured logging
- Rate limiting middleware
- Authentication middleware
</file>

<file path="docs/new features/project-architecture.md">
# Project Architecture

## Project Structure
- Monorepo setup with NPM workspaces
- Packages:
  - `web`: Next.js frontend (TypeScript)
  - `api`: Express.js backend (TypeScript)
  - `mathapi`: Flask Python service
  - `common-ts`: Shared TypeScript types/utilities

## Technology Stack

### Frontend (web)
- Next.js 14.2+ with App Router
- TypeScript
- DaisyUI + Tailwind for styling
- Chart.js with date-fns adapter for visualizations
- Auth0 for authentication with auto-redirect on session expiry
- Sentry for error tracking (optional via SENTRY_DISABLED)
- Vitest for testing
- Additional utilities:
  - Ramda for functional programming
  - React Icons
  - Date-fns for date manipulation

### Backend (api)
- Express.js
- TypeScript
- MongoDB for data storage
- YNAB API integration
- OpenAI integration
- Prometheus metrics

### Math API (mathapi)
- Flask (Python)
- MongoDB for caching
- JWT authentication via Auth0
- Gunicorn for production (TODO)
- Endpoints:
  1. Balance Prediction
     - `/balance-prediction/data` (Authenticated)
       - Input: budget_id, days_ahead (default: 300)
       - Uses: YNAB scheduled transactions, MongoDB categories & accounts
       - Returns: Daily balance predictions with transaction details
     - `/balance-prediction/interactive` (Development/Debug)
       - Interactive visualization of balance predictions
       - Shows different simulation scenarios

  2. Transaction Management
     - `/scheduled-transactions`
       - Input: budget_id
       - Uses: YNAB API
       - Returns: Future scheduled transactions
     - `/uncategorised-transactions/suggest-categories`
       - Input: budget_id
       - Uses: YNAB API for transactions, MongoDB for categories
       - Returns: AI-suggested categories for uncategorized transactions
     - `/uncategorised-transactions/apply-categories` (POST)
       - Input: budget_id, transaction_id, category_id mappings
       - Uses: YNAB API
       - Applies suggested categories to transactions

  3. System
     - `/health`
       - Basic health check endpoint
       - Used by Kubernetes probes

  4. Data Sources:
     - YNAB API:
       - Scheduled transactions
       - Uncategorized transactions
       - Account balances
     - MongoDB:
       - Categories
       - Budget metadata
       - Account information
     - Simulation files:
       - JSON-based scenario definitions
       - Stored in app/simulations/

### Shared (common-ts)
- TypeScript types
- Utility functions
- Shared between web and api

## Development Setup

### Local Development
```bash
# Install all dependencies
npm install

# Start all services concurrently
npm run dev
# This will start:
# - Web (localhost:3000)
# - API (localhost:4000)
# - Math API (localhost:5000)

# Or start services individually:
npm run dev:web
npm run dev:api
npm run dev:mathapi
```

### Docker Development
```bash
docker-compose up --build
```

## Kubernetes Setup

### Namespaces
- `dev`: Development environment
- `monitoring`: Prometheus/Grafana

### Services per Namespace
Dev namespace contains:
- `budget-web-app`: Frontend service
- `budget-api-app`: Backend API
- `budget-mathapi-app`: Math API service

### Configuration
- ConfigMaps for non-sensitive configuration
- Secrets for sensitive data
- Network policies for service isolation
- Health checks and readiness probes

### Deployment Flow
1. GitHub Actions build Docker images
2. Push to Docker Hub (skipped for Dependabot PRs)
3. Update Kubernetes deployments
4. Rolling updates without downtime

## Authentication Flow
1. Frontend uses Auth0 for user login
2. JWT token is passed to APIs
3. APIs validate tokens via Auth0
4. Math API accepts tokens from API service
5. Auto-redirect to login on session expiry (401 responses)

## Data Flow
1. Frontend calls API for YNAB data
2. API caches data in MongoDB
3. Math API performs calculations
4. Results are cached
5. Frontend displays visualizations

## Environment Variables

### Web (.env)
```
AUTH0_*=Auth0 configuration
API_URL=Backend API URL
MATH_API_URL=Math API URL
SENTRY_DISABLED=true/false
```

### API (.env)
```
MONGODB_URI=MongoDB connection string
AUTH0_*=Auth0 configuration
YNAB_*=YNAB API configuration
OPENAI_API_KEY=OpenAI key
```

### Math API (.env)
```
MONGODB_URI=MongoDB connection string
AUTH0_*=Auth0 configuration
API_SERVICE_URL=API service URL
FLASK_APP=app/app.py
FLASK_ENV=development/production
```

## Development Best Practices
1. Feature files in `docs/new features/`
2. TypeScript strict mode
3. Error handling via Sentry
4. Metrics via Prometheus
5. Tests with Vitest for frontend
6. Security reviews for auth changes

## Deployment Checks
1. Linting/Type checking
2. Tests (Vitest for frontend)
3. Docker builds
4. Kubernetes health checks
5. Monitoring alerts

## Common Issues & Solutions
1. Math API cold starts
   - Solution: Keep minimum replicas running
   - Implement warm-up endpoints

2. MongoDB connection timeouts
   - Solution: Connection pooling
   - Proper retry mechanisms
   - Monitor connection metrics

3. Auth0 token refresh
   - Solution: Implement silent refresh
   - Handle token expiration with auto-redirect
   - Monitor token lifetimes

4. YNAB API rate limiting
   - Solution: Implement caching
   - Queue requests when needed
   - Monitor rate limit headers

5. Kubernetes resource limits
   - Solution: Regular resource monitoring
   - Adjust limits based on usage
   - Set up HPA (Horizontal Pod Autoscaling)

## Monitoring & Observability
1. Prometheus metrics
   - Resource usage
   - Request latencies
   - Business metrics

2. Grafana dashboards
   - System overview
   - Service health
   - Custom alerts

3. Sentry error tracking
   - Error aggregation
   - Performance monitoring
   - User impact analysis

4. API health endpoints
   - Service status
   - Dependency checks
   - Custom health metrics

5. Kubernetes resource monitoring
   - Pod status
   - Node health
   - Cluster metrics
</file>

<file path="docs/best-practices.md">
# Development Best Practices

## General Practices
- Follow Next.js best practices (refer to ./docs/nextjs/docs)
- Use daisyui for styling
- Ensure proper error handling
- Write comprehensive tests
- Document API endpoints
- Regular security audits
- Code review focus
- Clear documentation
- No implementation shortcuts

## Testing
- Unit tests for all new features
- Integration tests for API endpoints
- Performance testing where relevant
- Security testing for sensitive features
- Test coverage monitoring
- Automated testing in CI/CD

## Security
- Regular security audits
- Proper error handling
- Secure data storage
- Input validation
- Authentication & authorization
- Network security
- Backup security
- Recovery procedures

## Documentation
- Write all documentation in English
- Clear API documentation
- Code comments for complex logic
- Update README for major changes
- Document deployment procedures
- Keep documentation up-to-date
- Include examples where helpful

## Monitoring & Logging
- Structured logging
- Performance metrics
- Health checks
- Error tracking
- Usage analytics
- Audit logging for sensitive operations
</file>

<file path="kube/config/dev/web-config.yml">
apiVersion: v1
kind: ConfigMap
metadata:
  name: budget-web-dev-config
  namespace: dev
data:
  NEXTAUTH_URL: https://budget-dev.vandenit.be
  AUTH0_BASE_URL: https://budget-dev.vandenit.be
  AUTH0_ISSUER_BASE_URL: "https://vandenit.eu.auth0.com"
  AUTH0_SCOPE: "openid profile"
  AUTH0_CALLBACK: api/defauth/callback
  AUTH0_AUDIENCE: "https://vandenit.eu.auth0.com/api/v2/"
  API_URL: "http://budget-api-svc:4000"
  MATH_API_URL: "http://budget-mathapi-service:5000"
</file>

<file path="packages/api/src/controllers/budgetController.ts">
import { findBudgets, getBudget } from "../data/budget/budget.server";
import { getBudgetOverviewForUser } from "../data/main.budget.server";
import { Request, Response } from "express";
import { getUserFromReq } from "./utils";
import { Budget } from "common-ts";
import { findAccounts } from "../data/accounts/account.server";

export const getBudgetFromReq = async (req: Request): Promise<Budget> => {
  const user = await getUserFromReq(req);
  if (!user) {
    throw new Error("no user found");
  }
  const budget = await getBudget(req.params.uuid, user);
  if (!budget) {
    throw new Error(`budget ${req.params.uuid} does not belong to user`);
  } 
 
  return budget;
};

export const findBudgetsForUser = async (req: Request, res: Response) => {
  // get user from database
  const user = await getUserFromReq(req);
  if (!user) {
    console.error("no user found");
    return res.status(401).send("Unauthorized");
  }
  // get budgets for user
  const budgets = await findBudgets(user);
  res.json(budgets);
};

export const getBudgetForUser = async (req: Request, res: Response) => {
  const budget = await getBudgetFromReq(req);
  res.json(budget);
};

export const handleGetBudgetOverviewForUser = async (
  req: Request,
  res: Response
) => {
  const budget = await getBudgetFromReq(req);
  // get budget overview for user
  const budgetOverview = await getBudgetOverviewForUser(budget._id);
  res.json(budgetOverview);
};

export const getAccountsForBudget = async (req: Request, res: Response) => {
  const user = await getUserFromReq(req);
  if (!user) {
    throw new Error("no user found");
  }

  const budget = await getBudget(req.params.uuid, user);
  if (!budget) {
    throw new Error(`budget ${req.params.uuid} does not belong to user`);
  }

  const accounts = await findAccounts(budget._id);
  res.json(accounts);
};
</file>

<file path="packages/api/src/data/transaction/transaction.schema.ts">
import mongoose from "mongoose";
const { Schema, model } = mongoose;

const localTransactionSchema = new Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
  },
  uuid: { type: String, index: true, unique: true },
  budgetId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "LocalBudget",
  },
  accountName: String,
  amount: Number,
  date: String,
  categoryId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "LocalCategory",
    nullable: true,
  },
  payeeName: String,
  memo: String,
  // Original payee name from YNAB import (before any payee rename rules)
  import_payee_name_original: String,
  // AI suggestions caching (same as Python implementation)
  ai_suggested_category: String,
  ai_suggestion_date: Date,
  ai_suggestion_confidence: Number,
  _cache_only: Boolean, // For cache-only documents
});

export const LocalTransaction =
  mongoose.models.LocalTransaction ||
  model("LocalTransaction", localTransactionSchema);
</file>

<file path="packages/api/src/data/transaction/transaction.server.ts">
import connectDb from "../db";
import { LocalTransaction } from "./transaction.schema";
import { Transaction } from "common-ts";
import { extractPayeeName } from "./utils";

export type NewOrUpdatedTransaction = {
  accountName: string;
  amount: number;
  date: string;
  categoryId: string | undefined | null;
  payeeName: string | undefined | null;
  memo: string | undefined | null;
  import_payee_name_original: string | undefined | null;
};

const TRANSACTION_LIMIT = 10000;
/**
 * Finds transactions based on the provided budgetId and date filter.
 * If a date filter is provided, it will return transactions for the specified month (YYYY-MM format) or for the specified year with format YYYY.
 * If no date filter is provided, it will return all transactions with a limit of TRANSACTION_LIMIT
 * @param budgetId - The ID of the budget to search for transactions.
 * @param dateFilterString - Optional. The date filter string in either YYYY-MM or YYYY format.
 * @returns A promise that resolves to an array of transactions.
 */
export const findTransactions = async (
  budgetId: string,
  dateFilterString?: string // YYYY-MM for transactions of 1 month or YYYY for all of 1 year
): Promise<Transaction[]> => {
  await connectDb();
  console.log("find transactions:" + budgetId + "/" + dateFilterString);

  // find transactions with month with format YYYY-MM or include all if month empty
  const dateFilter = dateFilterString
    ? { $regex: `^${dateFilterString}` }
    : { $exists: true };
  const filter = {
    budgetId,
    date: dateFilter,
  };
  console.log("filter?" + JSON.stringify(filter));
  const localTransactions = await LocalTransaction.find(filter).sort({
    date: -1,
  });
  return localTransactions.map((transaction) => {
    // Use import_payee_name_original as payeeName if available, otherwise use payeeName
    const displayPayeeName = transaction.import_payee_name_original || transaction.payeeName;

    return {
      uuid: transaction.uuid,
      accountName: transaction.accountName,
      amount: transaction.amount,
      date: transaction.date,
      categoryId: transaction.categoryId,
      payeeName: displayPayeeName,
      cleanPayeeName: extractPayeeName(transaction.payeeName),
      memo: transaction.memo,
      import_payee_name_original: transaction.import_payee_name_original,
    };
  });
};

// todo refactor to have bulk inserts, updates and deletes
export const insertOrUpdateMissingTransaction = async (
  uuid: string,
  deleted: boolean,
  budgetId: string,
  newData: NewOrUpdatedTransaction
) => {
  const localTransaction = await LocalTransaction.findOne({ uuid });
  if (!localTransaction && !deleted) {
    const newLocalTransaction = new LocalTransaction({
      uuid,
      budgetId: budgetId,
      ...newData,
    });
    await newLocalTransaction.save();
  } else if (localTransaction) {
    if (deleted) {
      await LocalTransaction.deleteOne({ uuid }).exec();
      return;
    }
    await LocalTransaction.updateOne({ uuid }, newData).exec();
  }
};

/**
 * Get uncategorized transactions (transactions without a category)
 */
export const getUncategorizedTransactions = async (
  budgetId: string
): Promise<Transaction[]> => {
  await connectDb();

  const localTransactions = await LocalTransaction.find({
    budgetId,
    $or: [{ categoryId: null }, { categoryId: undefined }, { categoryId: "" }],
  }).sort({ date: -1 });

  return localTransactions.map((transaction) => {
    // Use import_payee_name_original as payeeName if available, otherwise use payeeName
    const displayPayeeName = transaction.import_payee_name_original || transaction.payeeName;

    return {
      uuid: transaction.uuid,
      accountName: transaction.accountName,
      amount: transaction.amount,
      date: transaction.date,
      categoryId: transaction.categoryId,
      payeeName: displayPayeeName,
      cleanPayeeName: extractPayeeName(transaction.payeeName),
      memo: transaction.memo,
      import_payee_name_original: transaction.import_payee_name_original,
    };
  });
};

/**
 * Get cached AI suggestion for a transaction
 * Uses same field structure as Python SimpleAISuggestionsService
 */
export const getCachedAISuggestion = async (
  budgetId: string,
  transactionId: string
): Promise<string | null> => {
  await connectDb();

  const transaction = await LocalTransaction.findOne({
    budgetId,
    uuid: transactionId,
    ai_suggested_category: { $exists: true, $ne: null },
  });

  if (transaction?.ai_suggested_category) {
    // Check if suggestion is not too old (7 days, same as Python)
    const suggestionDate = transaction.ai_suggestion_date;
    if (suggestionDate) {
      const age = Date.now() - suggestionDate.getTime();
      const daysDiff = age / (1000 * 60 * 60 * 24);
      if (daysDiff <= 7) {
        return transaction.ai_suggested_category;
      }
      return null; // Expired
    }
    // Old suggestion without date - still valid
    return transaction.ai_suggested_category;
  }

  return null;
};

/**
 * Get cached AI suggestions for multiple transactions
 * Uses same logic as Python SimpleAISuggestionsService.get_cached_suggestions_batch
 */
export const getCachedAISuggestionsBatch = async (
  budgetId: string,
  transactionIds: string[]
): Promise<Record<string, string>> => {
  await connectDb();

  const transactions = await LocalTransaction.find({
    budgetId,
    uuid: { $in: transactionIds },
    ai_suggested_category: { $exists: true, $ne: null },
  });

  const result: Record<string, string> = {};
  const cutoffDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // 7 days ago

  transactions.forEach((transaction) => {
    const suggestionDate = transaction.ai_suggestion_date;

    // Check if not expired (or no date = keep it, same as Python)
    if (!suggestionDate || suggestionDate >= cutoffDate) {
      result[transaction.uuid] = transaction.ai_suggested_category;
    }
  });

  return result;
};

/**
 * Get all cached AI suggestions for a budget
 * Returns all cached suggestions without filtering by transaction IDs
 */
export const getAllCachedAISuggestionsForBudget = async (budgetId: string) => {
  await connectDb();

  const transactions = await LocalTransaction.find({
    budgetId,
    ai_suggested_category: { $exists: true, $ne: null },
  })
    .sort({ ai_suggestion_date: -1 })
    .limit(1000);

  return transactions.map((transaction) => ({
    transaction_id: transaction.uuid,
    payee_name: transaction.import_payee_name_original || transaction.payeeName || "",
    suggested_category_name: transaction.ai_suggested_category ?? "",
    confidence: transaction.ai_suggestion_confidence ?? 0.8,
    cached_at: transaction.ai_suggestion_date ?? new Date(),
  }));
};

/**
 * Store AI suggestion for a transaction
 * Uses same logic as Python SimpleAISuggestionsService.store_suggestion
 */
export const storeAISuggestion = async (
  budgetId: string,
  transactionId: string,
  payeeName: string,
  suggestedCategory: string,
  confidence: number = 0.8
): Promise<boolean> => {
  await connectDb();

  try {
    // Try to update existing transaction
    const result = await LocalTransaction.findOneAndUpdate(
      { budgetId, uuid: transactionId },
      {
        $set: {
          ai_suggested_category: suggestedCategory,
          ai_suggestion_date: new Date(),
          ai_suggestion_confidence: confidence,
        },
      },
      { upsert: false }
    );

    if (result) {
      return true;
    } else {
      // Transaction might not exist in local collection yet
      // Create a minimal document for caching (same as Python)
      await LocalTransaction.findOneAndUpdate(
        { budgetId, uuid: transactionId },
        {
          $set: {
            budgetId,
            uuid: transactionId,
            payeeName,
            ai_suggested_category: suggestedCategory,
            ai_suggestion_date: new Date(),
            ai_suggestion_confidence: confidence,
            _cache_only: true, // Mark as cache-only document
          },
        },
        { upsert: true }
      );
      return true;
    }
  } catch (error) {
    console.error("Error storing AI suggestion:", error);
    return false;
  }
};
</file>

<file path="packages/api/src/models/simulation.model.ts">
import { Schema, model } from 'mongoose';

const categoryChangeSchema = new Schema({
    categoryId: { type: String, required: true },
    startDate: { type: Date, required: true },
    endDate: { type: Date, required: true },
    targetAmount: { type: Number, required: true }
});

const simulationSchema = new Schema({
    budgetId: { type: Schema.Types.ObjectId, required: true, ref: 'Budget' },
    name: { type: String, required: true },
    isActive: { type: Boolean, default: false },
    categoryChanges: [categoryChangeSchema]
}, {
    timestamps: true
});

export const Simulation = model('Simulation', simulationSchema);
</file>

<file path="packages/api/Dockerfile">
# Use a node image as base
FROM node:20-alpine AS base

# Add build arguments
ARG SENTRY_DISABLED=false
ENV SENTRY_DISABLED=$SENTRY_DISABLED

WORKDIR /app

# Copy the root package.json, package-lock.json
COPY ../../package.json ../../package-lock.json ./
# Copy only the api package to the container
COPY ../../packages/api ./packages/api
COPY ../../packages/common-ts ./packages/common-ts
# Copy the root tsconfig.json
COPY ../../tsconfig.json ./

# Install dependencies and bootstrap with npm workspaces
RUN npm install

# Build the common-ts package first
RUN npm run build --workspace common-ts

# Build the api package - conditionally use Sentry
RUN --mount=type=secret,id=SENTRY_AUTH_TOKEN \
    if [ "$SENTRY_DISABLED" = "true" ] ; then \
        npm run build:api ; \
    else \
        export SENTRY_AUTH_TOKEN=$(cat /run/secrets/SENTRY_AUTH_TOKEN) && \
        npm run build:api ; \
    fi

# Set the working directory to the api package
WORKDIR /app/packages/api

# Expose the port
EXPOSE 4000

# Start the application
CMD ["npm", "start"]
</file>

<file path="packages/common-ts/src/index.ts">
// export all
export * from "./transaction";
export * from "./category";
export * from "./budget";
export * from "./main.budget.utils";
export * from "./amounts";
export * from "./forecasting";
export * from "./components/forms";
export * from "./components/AmountInput";
export * from "./user";
export * from "./logging";
</file>

<file path="packages/mathapi/app/tests/unit/README.md">
# Unit Tests for Prediction API

This package contains comprehensive unit tests for the prediction API functionality that calculates balance projections and spending patterns.

## Test Overview

### 1. Prediction API Tests (`test_prediction_api.py`)

Tests for the core prediction algorithm functions:

**What's being tested:**

-  `calculate_initial_balance()` - Account balance aggregation
-  `initialize_daily_projection()` - Daily projection setup
-  `add_future_transactions_to_projection()` - Scheduled transaction handling
-  `process_need_categories()` - Category spending logic
-  `apply_need_category_spending()` - Complex spending patterns
-  `calculate_running_balance()` - Balance calculations over time

**Scenarios:**

- Monthly, quarterly, and yearly spending cadences
- Current month balance handling with scheduled transactions
- Target date handling for specific categories
- Edge cases with partial consumption of balances
- Complex date calculations and month boundaries

## How to Run Tests

### Option 1: Pytest (Recommended)

```bash
cd packages/mathapi

# All prediction tests
pytest app/tests/unit/test_prediction_api.py -v

# Specific test function
pytest app/tests/unit/test_prediction_api.py::test_calculate_initial_balance -v

# All unit tests
pytest app/tests/unit/ -v
```

### Option 2: Python unittest

```bash
cd packages/mathapi
python -m unittest app.tests.unit.test_prediction_api
```

## Test Output Interpretation

### Successful Test Run

```
=================== 43 passed in 3.26s ===================
```

### Failed Tests

Tests will show specific failures and errors with traceback information for debugging.

## What These Tests Validate

### Balance Calculations

- Initial balance aggregation from multiple accounts
- Running balance calculations over time periods
- Handling of negative balances and edge cases

### Spending Pattern Logic

- Monthly, quarterly, and yearly spending cadences
- Current month vs future month handling
- Target date calculations and goal handling

### Date Handling

- Month boundary calculations
- Leap year handling
- End-of-month date adjustments

### Edge Cases

- Scheduled transactions exceeding available balance
- Partial consumption of category balances
- Complex goal configurations

## Test Dependencies

- `pytest` for test framework
- `datetime` and `calendar` for date calculations
- The prediction API modules

## Code Coverage

These tests cover the following critical paths:

- Prediction algorithm logic (89% coverage)
- Balance calculation functions (100% coverage)
- Date handling utilities (95% coverage)
- Error scenarios and edge cases

## Contributing

When adding new prediction features:

1. Add tests to `test_prediction_api.py`
2. Update this README with new scenarios
3. Run all tests to prevent regressions
4. Ensure coverage remains high

## Troubleshooting

### Import Errors

Make sure you're running the tests from the `packages/mathapi` directory.

### Date-related Test Failures

Some tests may be sensitive to the current date. Check if tests use fixed dates or relative calculations.
</file>

<file path="packages/mathapi/app/tests/unit/test_prediction_api.py">
import pytest
from datetime import datetime, timedelta
from app.prediction_api import (
    calculate_initial_balance,
    initialize_daily_projection,
    add_future_transactions_to_projection,
    calculate_running_balance,
    add_simulations_to_projection,
    process_need_categories,
    process_need_category,
    apply_need_category_spending
)
import calendar

def test_calculate_initial_balance():
    # Test data
    accounts = [
        {"balance": 1000},  # 1.0 after division by 1000
        {"balance": 2000},  # 2.0 after division by 1000
    ]

    expected_balance = 3.0  # (1000 + 2000) / 1000
    assert abs(calculate_initial_balance(accounts) - expected_balance) < 0.01

def test_initialize_daily_projection():
    initial_balance = 1000.0
    days_ahead = 2

    result = initialize_daily_projection(initial_balance, days_ahead)

    # We expect 3 dates (today + 2 days ahead)
    assert len(result) == 3

    # Check structure of the entries
    for date, data in result.items():
        assert "balance" in data
        assert "changes" in data
        assert isinstance(data["changes"], list)

    # Check initial balance entry
    today = datetime.now().date().isoformat()
    assert result[today]["changes"][0] == {
        "reason": "Initial Balance",
        "amount": initial_balance,
        "category": "Starting Balance"
    }

def test_add_future_transactions_to_projection():
    # Setup test data
    base_date = datetime.now().date()
    daily_projection = {
        base_date.isoformat(): {"balance": 0, "changes": []},
        (base_date + timedelta(days=1)).isoformat(): {"balance": 0, "changes": []}
    }

    future_transactions = [
        {
            "date_next": base_date.isoformat(),
            "category_name": "Groceries",
            "amount": -50000,  # -50.0 after division by 1000
            "account_name": "Checking",
            "payee_name": "Supermarket",
            "memo": "Weekly groceries",
            "id": "test-transaction-id"
        }
    ]

    result = add_future_transactions_to_projection(daily_projection, future_transactions)

    # Verify the transaction was added correctly
    assert len(daily_projection[base_date.isoformat()]["changes"]) == 1
    added_transaction = daily_projection[base_date.isoformat()]["changes"][0]
    assert added_transaction["amount"] == -50.0
    assert added_transaction["category"] == "Groceries"
    assert added_transaction["reason"] == "Scheduled Transaction"

    # Verify scheduled_dates_by_category
    assert "Groceries" in result
    assert base_date.isoformat() in result["Groceries"]

def test_add_simulations_to_projection():
    # Setup test data
    base_date = datetime.now().date()
    daily_projection = {
        base_date.isoformat(): {"balance": 0, "changes": []}
    }

    simulations = [
        {
            "date": base_date.isoformat(),
            "amount": "-100.0",
            "reason": "Test Simulation",
            "category": "Test Category"
        }
    ]

    add_simulations_to_projection(daily_projection, simulations)

    # Verify simulation was added
    assert len(daily_projection[base_date.isoformat()]["changes"]) == 1
    added_sim = daily_projection[base_date.isoformat()]["changes"][0]
    assert added_sim["amount"] == -100.0
    assert added_sim["reason"] == "Test Simulation"
    assert added_sim["category"] == "Test Category"
    assert added_sim["is_simulation"] is True

def test_calculate_running_balance():
    # Setup test data
    base_date = datetime.now().date()
    daily_projection = {
        base_date.isoformat(): {
            "balance": 0,
            "changes": [{"amount": 1000.0}]  # Initial balance
        },
        (base_date + timedelta(days=1)).isoformat(): {
            "balance": 0,
            "changes": [{"amount": -200.0}]  # Expense
        }
    }

    calculate_running_balance(daily_projection, 1000.0, 1)

    # Verify running balances
    assert abs(daily_projection[base_date.isoformat()]["balance"] - 1000.0) < 0.01
    assert abs(daily_projection[(base_date + timedelta(days=1)).isoformat()]["balance"] - 800.0) < 0.01

@pytest.fixture
def base_daily_projection():
    base_date = datetime.now().date()
    projection = {}

    # Create a projection for 365 days
    for day in range(366):
        date = (base_date + timedelta(days=day)).isoformat()
        projection[date] = {
            "balance": 0,
            "changes": []
        }

    return projection

@pytest.fixture
def base_projection():
    """Create a base projection for testing different spending scenarios."""
    # Create projection for 2 years starting from Jan 1, 2025
    start_date = datetime(2025, 1, 1).date()
    projection = {}

    # Create projection for 2 years
    for day in range(730):
        date = (start_date + timedelta(days=day)).isoformat()
        projection[date] = {
            "balance": 0,
            "changes": []
        }

    return projection


def test_process_need_category_monthly():
    base_date = datetime.now().date()
    daily_projection = {}

    # Add data for a full year
    current_date = base_date
    while current_date < (base_date + timedelta(days=365)):
        daily_projection[current_date.isoformat()] = {"balance": 0, "changes": []}
        current_date += timedelta(days=1)

    category = {
        "name": "Rent",
        "balance": 0,
        "target": {
            "goal_type": "NEED",
            "goal_target": 100000,  # 100 after division by 1000
            "goal_cadence": 1,  # Monthly
            "goal_cadence_frequency": 1,
            "goal_day": 1,  # First of the month
            "goal_overall_left": 100000
        }
    }

    scheduled_dates = {}

    process_need_category(
        daily_projection,
        category,
        category["target"],
        scheduled_dates,
        365  # days_ahead
    )

    # Check if a payment was scheduled for next month
    next_month = (base_date.replace(day=1) + timedelta(days=32)).replace(day=1)
    next_month_str = next_month.isoformat()

    assert next_month_str in daily_projection
    changes = [c for c in daily_projection[next_month_str]["changes"]
              if c["category"] == "Rent"]
    assert len(changes) == 1
    assert changes[0]["amount"] == -100.0


def test_process_need_category_quarterly():
    base_date = datetime.now().date()
    daily_projection = {
        base_date.isoformat(): {"balance": 0, "changes": []}
    }

    # Add data for a full year
    current_date = base_date
    while current_date < (base_date + timedelta(days=365)):
        daily_projection[current_date.isoformat()] = {"balance": 0, "changes": []}
        current_date += timedelta(days=1)

    category = {
        "name": "Insurance",
        "balance": 0,
        "target": {
            "goal_type": "NEED",
            "goal_target": 300000,  # 300 after division by 1000
            "goal_cadence": 3,  # Quarterly
            "goal_cadence_frequency": 1,
            "goal_day": 15,  # 15th of the month
            "goal_overall_left": 300000
        }
    }

    scheduled_dates = {}

    process_need_category(
        daily_projection,
        category,
        category["target"],
        scheduled_dates,
        365  # days_ahead
    )

    # Calculate the next quarter date
    def next_quarter_date(date):
        # Round down to the nearest quarter
        month = ((date.month - 1) // 3) * 3 + 1
        next_quarter = date.replace(month=month, day=15)
        if next_quarter <= date:
            if month + 3 > 12:
                next_quarter = next_quarter.replace(year=next_quarter.year + 1, month=(month + 3) - 12)
            else:
                next_quarter = next_quarter.replace(month=month + 3)
        return next_quarter

    next_quarter = next_quarter_date(base_date)
    next_quarter_str = next_quarter.isoformat()

    assert next_quarter_str in daily_projection
    changes = [c for c in daily_projection[next_quarter_str]["changes"]
              if c["category"] == "Insurance"]
    assert len(changes) == 1
    assert changes[0]["amount"] == -300.0


def test_process_need_category_yearly():
    base_date = datetime.now().date()
    daily_projection = {}

    # Add data for two years
    current_date = base_date
    while current_date < (base_date + timedelta(days=730)):
        daily_projection[current_date.isoformat()] = {"balance": 0, "changes": []}
        current_date += timedelta(days=1)

    # Set the target_month to 2 months from now
    target_month = (base_date + timedelta(days=60)).replace(day=1)
    target_month_str = target_month.isoformat()

    category = {
        "name": "Taxes",
        "balance": 0,
        "target": {
            "goal_type": "NEED",
            "goal_target": 1200000,  # 1200 after division by 1000
            "goal_cadence": 13,  # Yearly
            "goal_cadence_frequency": 1,
            "goal_target_month": target_month_str,
            "goal_day": 15,
            "goal_overall_left": 1200000
        }
    }

    scheduled_dates = {}

    process_need_category(
        daily_projection,
        category,
        category["target"],
        scheduled_dates,
        730  # days_ahead
    )

    # Check if payment was scheduled for the target month
    target_date = target_month.replace(day=15).isoformat()

    assert target_date in daily_projection
    changes = [c for c in daily_projection[target_date]["changes"]
              if c["category"] == "Taxes"]
    assert len(changes) == 1
    assert changes[0]["amount"] == -1200.0


def test_process_need_categories():
    base_date = datetime.now().date()
    daily_projection = {}

    # Add data for a full year
    current_date = base_date
    while current_date < (base_date + timedelta(days=365)):
        daily_projection[current_date.isoformat()] = {"balance": 0, "changes": []}
        current_date += timedelta(days=1)

    categories = [
        {
            "name": "Rent",
            "balance": 0,
            "target": {
                "goal_type": "NEED",
                "goal_target": 100000,
                "goal_cadence": 1,
                "goal_cadence_frequency": 1,
                "goal_day": 1,
                "goal_overall_left": 100000
            }
        },
        {
            "name": "No Target",
            "balance": 0
        },
        {
            "name": "Other Type",
            "balance": 0,
            "target": {
                "goal_type": "SAVINGS",
                "goal_target": 50000
            }
        }
    ]

    scheduled_dates = {}

    process_need_categories(daily_projection, categories, scheduled_dates, 365)

    # Verify that only the NEED category was processed
    next_month = (base_date.replace(day=1) + timedelta(days=32)).replace(day=1)
    next_month_str = next_month.isoformat()

    assert next_month_str in daily_projection
    changes = [c for c in daily_projection[next_month_str]["changes"]
              if c["category"] == "Rent"]
    assert len(changes) == 1

    # Verify other categories were not processed
    all_changes = []
    for date, data in daily_projection.items():
        all_changes.extend(data["changes"])

    assert not any(c["category"] == "No Target" for c in all_changes)
    assert not any(c["category"] == "Other Type" for c in all_changes)


def test_current_month_balance_with_scheduled_transactions_exceeding_balance(base_projection):
    """Test current month balance when scheduled transactions exceed the current balance.
    
    This reproduces the bug where a category has a positive balance but scheduled transactions
    that will consume more than the balance, resulting in a negative effective balance.
    In this case, no additional spending should be predicted.
    
    Example: Sociale bijdrage Afbetaling has 579.92 balance but 1000 in scheduled transactions.
    """
    today = datetime.now().date()
    # Use end of month for spending prediction
    spending_day = 30 if today.month != 2 else 28  # Simplified for test
    current_month_date = today.replace(day=spending_day).isoformat()
    
    # Add scheduled transactions that exceed the current balance
    # Two transactions of 500 each = 1000 total
    base_projection[today.replace(day=20).isoformat()]["changes"].append({
        "reason": "Scheduled Transaction",
        "amount": -500.0,  # 500
        "category": "Sociale bijdrage Afbetaling"
    })
    base_projection[today.replace(day=29).isoformat()]["changes"].append({
        "reason": "Scheduled Transaction", 
        "amount": -500.0,  # 500
        "category": "Sociale bijdrage Afbetaling"
    })
    
    category = {
        "name": "Sociale bijdrage Afbetaling",
        "balance": 579920,  # 579.92 (in milliunits)
        "target": {
            "goal_type": "NEED",
            "goal_target": 1350000,  # 1350 (in milliunits)
            "goal_cadence": 1,
            "goal_cadence_frequency": 1,
            "goal_day": None,  # End of month
            "goal_target_month": None,
            "goal_overall_left": 432890  # 432.89 (in milliunits)
        }
    }
    
    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        579.92,  # current_balance (in regular units)
        1350.0,  # target_amount (in regular units)
        30,  # days_ahead
        432.89  # global_overall_left (in regular units)
    )
    
    # Check end of current month - should have NO additional spending prediction
    # because scheduled transactions (1000) exceed current balance (579.92)
    changes = [c for c in base_projection[current_month_date]["changes"] 
              if c["category"] == "Sociale bijdrage Afbetaling" and c["reason"] == "Current Month Balance"]
    
    assert len(changes) == 0, "Should not predict additional spending when scheduled transactions exceed balance"


def test_current_month_balance_with_scheduled_transactions_partial_consumption(base_projection):
    """Test current month balance when scheduled transactions partially consume the balance.
    
    This tests the case where scheduled transactions consume part of the balance,
    but there's still a positive effective balance remaining.
    
    Example: Eating Out has 188.35 balance with 100 in scheduled transactions.
    Should predict spending of remaining 88.35.
    """
    today = datetime.now().date()
    # Use actual end of month for spending prediction
    import calendar
    days_in_month = calendar.monthrange(today.year, today.month)[1]
    current_month_date = today.replace(day=days_in_month).isoformat()

    
    # Add scheduled transaction that partially consumes the balance
    base_projection[today.replace(day=15).isoformat()]["changes"].append({
        "reason": "Scheduled Transaction",
        "amount": -100.0,  # 100
        "category": "Eating Out"
    })
    
    category = {
        "name": "Eating Out",
        "balance": 188350,  # 188.35 (in milliunits)
        "target": {
            "goal_type": "NEED",
            "goal_target": 600000,  # 600 (in milliunits)
            "goal_cadence": 1,
            "goal_cadence_frequency": 1,
            "goal_day": None,  # End of month
            "goal_target_month": None,
            "goal_overall_left": 0  # Already fully funded
        }
    }
    
    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        188.35,  # current_balance (in regular units)
        600.0,  # target_amount (in regular units)
        30,  # days_ahead
        0  # global_overall_left (in regular units)
    )
    
    # Check end of current month - should predict spending of remaining balance after scheduled transactions
    # Effective balance = 188.35 - 100 = 88.35
    changes = [c for c in base_projection[current_month_date]["changes"] 
              if c["category"] == "Eating Out" and c["reason"] == "Current Month Balance"]
    
    assert len(changes) == 1, "Should predict spending of remaining balance"
    assert abs(changes[0]["amount"] - (-88.35)) < 0.01, f"Should spend remaining balance of 88.35, got {changes[0]['amount']}"


def test_quarterly_category_with_specific_target_date(base_projection):
    """Test quarterly category with goal_target_month set to specific date (like 2025-10-15).
    
    This reproduces the bug where:
    1. Current month incorrectly gets spending prediction when goal_overall_left is 0
    2. Target month (October 15) doesn't get the spending prediction
    3. Wrong recurring pattern starts from wrong month
    
    Example: BTW kwartaal should have payment on October 15, 2025, then every 3 months after.
    """
    today = datetime.now().date()
    
    # Create a category similar to BTW kwartaal
    category = {
        "name": "BTW kwartaal",
        "balance": 0,
        "target": {
            "goal_type": "NEED",
            "goal_target": 8037640,  # 8037.64 (in milliunits)
            "goal_cadence": 1,  # Monthly base
            "goal_cadence_frequency": 3,  # Every 3 months
            "goal_target_month": "2025-10-15",  # October 15, 2025
            "goal_day": None,  # Use end of month
            "goal_overall_left": 0,  # Fully funded
            "goal_overall_funded": 8196610  # 8196.61 (in milliunits)
        }
    }
    
    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        0,  # current_balance
        8037.64,  # target_amount (in regular units)
        365,  # days_ahead
        0  # global_overall_left (in regular units) - fully funded
    )
    
    # Check current month - should have NO spending because goal_overall_left is 0
    current_month_end = today.replace(day=30 if today.month != 2 else 28)
    current_month_changes = [c for c in base_projection[current_month_end.isoformat()]["changes"] 
                           if c["category"] == "BTW kwartaal"]
    
    assert len(current_month_changes) == 0, f"Should not have spending in current month when fully funded, but found: {current_month_changes}"
    
    # Check October 15, 2025 - should have the target spending
    october_15_date = datetime(2025, 10, 15).date().isoformat()
    october_changes = [c for c in base_projection[october_15_date]["changes"] 
                      if c["category"] == "BTW kwartaal"]
    
    assert len(october_changes) == 1, f"Should have spending on October 15, 2025, but found: {october_changes}"
    # Since goal_overall_left is 0, it should use goal_overall_funded amount
    expected_amount = 8196.61  # goal_overall_funded converted to regular units
    assert abs(october_changes[0]["amount"] - (-expected_amount)) < 0.01, f"Should spend {expected_amount} on October 15"
    
    # Check that no spending happens in January (wrong recurring pattern)
    january_31_date = datetime(2026, 1, 31).date().isoformat()
    january_changes = [c for c in base_projection[january_31_date]["changes"] 
                      if c["category"] == "BTW kwartaal"]
    
    assert len(january_changes) == 0, f"Should not have spending in January 2026, but found: {january_changes}"
    
    # Check that next quarterly payment is in January 15, 2026 (3 months after October 15)
    january_15_date = datetime(2026, 1, 15).date().isoformat()
    january_15_changes = [c for c in base_projection[january_15_date]["changes"] 
                         if c["category"] == "BTW kwartaal"]
    
    assert len(january_15_changes) == 1, "Should have next quarterly payment on January 15, 2026"
    assert abs(january_15_changes[0]["amount"] - (-8037.64)) < 0.01, "Should spend target amount 8037.64 in January"


def test_yearly_cadence_with_target_month(base_projection):
    """Test yearly cadence (13) with a target month specified."""
    base_date = datetime.now().date()
    target_month = (base_date + timedelta(days=60)).replace(day=1)

    category = {
        "name": "Yearly Tax",
        "target": {
            "goal_type": "NEED",
            "goal_target": 1200000,  # 1200
            "goal_cadence": 13,  # Yearly
            "goal_cadence_frequency": 1,
            "goal_target_month": target_month.isoformat(),
            "goal_day": 15
        }
    }

    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        0,  # current_balance
        1200.0,  # target_amount
        730,  # days_ahead
        1200.0  # global_overall_left
    )

    # Check if payment was scheduled for target month
    target_date = target_month.replace(day=15).isoformat()
    changes = [c for c in base_projection[target_date]["changes"]
              if c["category"] == "Yearly Tax"]

    assert len(changes) == 1
    assert changes[0]["amount"] == -1200.0
    assert changes[0]["reason"] == "Yearly Payment"


def test_current_month_with_balance(base_projection):
    """Test handling of current month with existing balance."""
    today = datetime.now().date()

    # Set the spending day to 1 for consistency
    spending_day = 1
    current_month_date = today.replace(day=spending_day).isoformat()

    category = {
        "name": "Current Month Category",
        "target": {
            "goal_type": "NEED",
            "goal_target": 100000,  # 100
            "goal_cadence": 1,
            "goal_cadence_frequency": 1,
            "goal_day": spending_day
        }
    }

    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        50.0,  # current_balance
        100.0,  # target_amount
        30,  # days_ahead
        100.0  # global_overall_left
    )

    # Check if current balance was applied
    changes = [c for c in base_projection[current_month_date]["changes"]
              if c["category"] == "Current Month Category"]

    assert len(changes) == 1
    assert changes[0]["amount"] == -50.0
    assert changes[0]["reason"] == "Current Month Balance"


def test_recurring_monthly_spending(base_projection):
    """Test regular monthly spending pattern."""
    base_date = datetime.now().date()
    category = {
        "name": "Monthly Rent",
        "target": {
            "goal_type": "NEED",
            "goal_target": 100000,  # 100
            "goal_cadence": 1,
            "goal_cadence_frequency": 1,
            "goal_day": 1
        }
    }

    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        0,  # current_balance
        100.0,  # target_amount
        60,  # days_ahead
        100.0  # global_overall_left
    )

    # Check next month's payment
    next_month = (base_date.replace(day=1) + timedelta(days=32)).replace(day=1)
    next_month_str = next_month.isoformat()

    changes = [c for c in base_projection[next_month_str]["changes"]
              if c["category"] == "Monthly Rent"]

    assert len(changes) == 1
    assert changes[0]["amount"] == -100.0
    assert changes[0]["reason"] == "Future Month Target"


def test_quarterly_spending_with_target_month(base_projection):
    """Test quarterly spending with a specific target month."""
    base_date = datetime.now().date()
    target_month = (base_date + timedelta(days=60)).replace(day=1)

    category = {
        "name": "Quarterly Insurance",
        "target": {
            "goal_type": "NEED",
            "goal_target": 300000,  # 300
            "goal_cadence": 3,  # Quarterly
            "goal_target_month": target_month.isoformat(),
            "goal_day": 15
        }
    }

    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        0,  # current_balance
        300.0,  # target_amount
        365,  # days_ahead
        300.0  # global_overall_left
    )

    # Check first payment in target month
    first_payment_date = target_month.replace(day=15).isoformat()
    changes = [c for c in base_projection[first_payment_date]["changes"]
              if c["category"] == "Quarterly Insurance"]

    assert len(changes) == 1, f"Should have payment on {first_payment_date}, but found: {changes}"
    assert changes[0]["amount"] == -300.0


def test_spending_with_scheduled_transactions(base_projection):
    """Test spending calculation when there are already scheduled transactions."""
    base_date = datetime.now().date()
    next_month = (base_date.replace(day=1) + timedelta(days=32)).replace(day=1)

    # Add a scheduled transaction
    base_projection[next_month.isoformat()]["changes"].append({
        "reason": "Scheduled Transaction",
        "amount": -50.0,
        "category": "Monthly Bills"
    })

    category = {
        "name": "Monthly Bills",
        "target": {
            "goal_type": "NEED",
            "goal_target": 100000,  # 100 target
            "goal_cadence": 1,
            "goal_cadence_frequency": 1,
            "goal_day": 1
        }
    }

    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        0,  # current_balance
        100.0,  # target_amount
        60,  # days_ahead
        100.0  # global_overall_left
    )

    # Verify that only the remaining amount was added
    changes = [c for c in base_projection[next_month.isoformat()]["changes"]
              if c["category"] == "Monthly Bills"]

    assert len(changes) == 2  # Original scheduled + remaining amount
    scheduled = next(c for c in changes if c["reason"] == "Scheduled Transaction")
    remaining = next(c for c in changes if c["reason"] == "Future Month Target")
    assert scheduled["amount"] == -50.0
    assert remaining["amount"] == -50.0  # Remaining amount to reach target


def test_current_month_salary_prediction_without_balance(base_projection):
    """Test salary predictions for current month (without balance) and future month."""
    # Use current date for testing
    today = datetime.now().date()

    category = {
        "name": "Salery",
        "balance": 0,
        "target": {
            "goal_type": "NEED",
            "goal_target": 7348210,  # 7348.21 (in milliunits)
            "goal_cadence": 1,
            "goal_cadence_frequency": 1,
            "goal_day": 4,
            "goal_target_month": None,
            "goal_overall_left": 7348210
        }
    }

    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        0,  # current_balance
        7348.21,  # target_amount (in regular units)
        60,  # days_ahead
        7348.21  # global_overall_left (in regular units)
    )

    # Check current month (4th day)
    current_month_date = today.replace(day=4).isoformat()
    current_month_changes = [c for c in base_projection[current_month_date]["changes"]
                  if c["category"] == "Salery"]
    assert len(current_month_changes) == 1, "Should have salary entry for current month 4th"
    assert current_month_changes[0]["amount"] == -7348.21, "Current month salary amount should be correct"
    assert current_month_changes[0]["reason"] == "Current Month Target", "Current month should be marked as Current Month Target"

    # Check next month (4th day)
    next_month = (today.replace(day=1) + timedelta(days=32)).replace(day=4)
    next_month_date = next_month.isoformat()
    next_month_changes = [c for c in base_projection[next_month_date]["changes"]
                   if c["category"] == "Salery"]
    assert len(next_month_changes) == 1, "Should have salary entry for next month 4th"
    assert next_month_changes[0]["amount"] == -7348.21, "Next month salary amount should be correct"
    assert next_month_changes[0]["reason"] == "Future Month Target", "Next month should be marked as Future Month Target"


def test_current_month_salary_prediction_with_balance(base_projection):
    """Test salary predictions when there is a current balance."""
    # Use current date for testing
    today = datetime.now().date()

    category = {
        "name": "Salery",
        "balance": 3674105,  # Half of the target amount (in milliunits)
        "target": {
            "goal_type": "NEED",
            "goal_target": 7348210,  # 7348.21 (in milliunits)
            "goal_cadence": 1,
            "goal_cadence_frequency": 1,
            "goal_day": 4,
            "goal_target_month": None,
            "goal_overall_left": 7348210
        }
    }

    apply_need_category_spending(
        base_projection,
        category,
        category["target"],
        3674.105,  # current_balance (in regular units)
        7348.21,  # target_amount (in regular units)
        60,  # days_ahead
        7348.21  # global_overall_left (in regular units)
    )

    # Check current month (4th day)
    current_month_date = today.replace(day=4).isoformat()
    current_month_changes = [c for c in base_projection[current_month_date]["changes"]
                  if c["category"] == "Salery"]
    assert len(current_month_changes) == 1, "Should have salary entry for current month 4th"
    assert current_month_changes[0]["amount"] == -3674.105, "Current month salary should use current_balance"
    assert current_month_changes[0]["reason"] == "Current Month Balance", "Current month should use current balance"

    # Check next month (4th day)
    next_month = (today.replace(day=1) + timedelta(days=32)).replace(day=4)
    next_month_date = next_month.isoformat()
    next_month_changes = [c for c in base_projection[next_month_date]["changes"]
                   if c["category"] == "Salery"]
    assert len(next_month_changes) == 1, "Should have salary entry for next month 4th"
    assert next_month_changes[0]["amount"] == -7348.21, "Next month salary should use full target amount"
    assert next_month_changes[0]["reason"] == "Future Month Target", "Next month should be marked as Future Month Target"
</file>

<file path="packages/mathapi/app/tests/README.md">
# MathAPI Test Suite

This project has a focused test suite for prediction functionality.

##  Test Structure

```
app/tests/
 unit/           # Unit tests (no external dependencies)
     test_prediction_api.py  # Prediction algorithm tests
     README.md              # This file
```

##  Test Categories

### Unit Tests (`app/tests/unit/`)

-  **No external dependencies**
-  **Fast and reliable**
-  **Run in CI/CD**
-  **Mock all external calls**

**Contains:**

- Prediction API algorithm tests
- Balance calculation tests
- Category spending logic tests
- Date handling tests

##  Running Tests

### For Development

```bash
cd packages/mathapi

# All unit tests
pytest app/tests/unit/ -v

# All tests (same as unit tests)
pytest -v

# Specific test file
pytest app/tests/unit/test_prediction_api.py -v
```

### For CI/CD

```bash
cd packages/mathapi

# Unit tests (used in GitHub Actions)
pytest app/tests/unit/ -v
```

##  CI/CD Configuration

**GitHub Actions** (`.github/workflows/dev-workflow.yml`):

-  Runs **unit tests**
-  Uses: `pytest app/tests/unit/ -v`

##  Test Markers

Tests are marked with pytest markers:

```python
@pytest.mark.unit          # Unit test (mocked dependencies)
@pytest.mark.slow         # Slow test (excluded from quick runs)
```

**Using markers:**

```bash
# Unit tests only
pytest -m unit

# Fast tests only
pytest -m "not slow"
```

##  Test Coverage

Unit tests cover:

-  Prediction algorithm logic
-  Balance calculation functions
-  Category spending patterns
-  Date handling and edge cases
-  Error scenarios

## Troubleshooting

### Import Errors

Make sure you're in the `packages/mathapi` directory.

### Test Discovery Issues

Check if `__init__.py` files exist in test directories.

##  Future Extensions

- [ ] Performance benchmarking tests for prediction algorithms
- [ ] Memory usage tests for large datasets
- [ ] Edge case testing for extreme date ranges
</file>

<file path="packages/mathapi/app/accounts_api.py">
from datetime import datetime, timedelta
from dotenv import load_dotenv
from app.budget_api import get_objectid_for_budget, convert_objectid_to_str
from app.db import get_DB
import logging

# Load environment variables from .env file
load_dotenv()

def get_accounts_for_budget(budget_id):
    query = {
        "budgetId": budget_id
    }
    # Execute the query and retrieve categories from localcategories
    accounts = get_DB().localaccounts.find(query)
    account_list = []
    for account in accounts:
        account_list.append(convert_objectid_to_str(account))
    return account_list
</file>

<file path="packages/mathapi/app/budget_api.py">
from app.db import get_DB
from bson import ObjectId

def convert_objectid_to_str(doc):
    """Recursively converts ObjectId fields in a document to strings."""
    for key, value in doc.items():
        if isinstance(value, ObjectId):
            doc[key] = str(value)
        elif isinstance(value, dict):
            convert_objectid_to_str(value)
    return doc

def get_objectid_for_budget(budget_uuid):
    """
    Fetches the ObjectId for a given budget UUID in the localBudgets collection.

    Args:
        uuid (str): The UUID of the budget.

    Returns:
        ObjectId or None: The ObjectId associated with the budget UUID, or None if not found.
    """
    budget = get_DB().localbudgets.find_one({"uuid": budget_uuid})
    return budget["_id"] if budget else None
</file>

<file path="packages/mathapi/app/db.py">
# MongoDB connection
import os
from pymongo import MongoClient
import logging
from dotenv import load_dotenv

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

MONGODB_URI = os.getenv("MONGODB_URI")
logger.info(f"Connecting to MongoDB with URI: {MONGODB_URI}")

client = MongoClient(MONGODB_URI)
db = client["test"]  # Replace with the actual database name

def get_DB():
    return db
</file>

<file path="packages/mathapi/app/models.py">
from pymongo import MongoClient
from bson.objectid import ObjectId
import os
from dotenv import load_dotenv
import logging

load_dotenv()

# Setup logging
logger = logging.getLogger(__name__)

try:
    client = MongoClient(os.getenv('MONGODB_URI'))
    db = client.get_default_database()
    logger.info("Successfully connected to MongoDB")
except Exception as e:
    logger.error(f"Failed to connect to MongoDB: {str(e)}")
    raise

def get_user_by_auth_id(auth_id):
    """Get user from MongoDB by Auth0 ID."""
    try:
        return db.users.find_one({"authId": auth_id})
    except Exception as e:
        logger.error(f"Error fetching user {auth_id}: {str(e)}")
        return None

def get_user_from_request(request):
    """Get user from request context."""
    try:
        logger.info("Auth payload from request: %s", request.auth['payload'])
        auth_id = request.auth['payload']['sub']
        logger.info("Found auth_id: %s", auth_id)
        
        if not auth_id:
            logger.warning("No auth_id found in request")
            return None
        
        user = get_user_by_auth_id(auth_id)
        if not user:
            logger.warning(f"No user found for auth_id {auth_id}")
            return None
            
        logger.info("Found user: %s", user)
        return user
    except Exception as e:
        logger.error(f"Error getting user from request: {str(e)}")
        return None

def get_budget(budget_uuid, user):
    """Get budget by UUID and verify it belongs to user."""
    try:
        logger.info(f"Looking for budget with uuid: {budget_uuid}")
        logger.info(f"User data: {user}")
        
        budget = db.localbudgets.find_one({"uuid": budget_uuid})
        if not budget:
            logger.warning(f"Budget with uuid {budget_uuid} not found in database")
            return None
            
        logger.info(f"Found budget: {budget}")
        
        # Verify budget belongs to user by checking if user._id is in the users array
        user_id = user.get('_id')
        budget_users = budget.get('users', [])
        logger.info(f"Checking if user {user_id} is in budget users: {budget_users}")
        
        if not any(str(uid) == str(user_id) for uid in budget_users):
            logger.warning(f"Budget {budget_uuid} does not belong to user {user_id}")
            return None
            
        return budget
    except Exception as e:
        logger.error(f"Error fetching budget {budget_uuid}: {str(e)}")
        return None
</file>

<file path="packages/mathapi/app/ynab_api.py">
import os
import requests

from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Fetch the YNAB access token and base URL
YNAB_ACCESS_TOKEN = os.getenv("YNAB_ACCESS_TOKEN")
YNAB_BASE_URL = os.getenv("YNAB_BASE_URL")

def fetch(method, path, body=None):
    """Performs an HTTP request to the YNAB API with the specified method and path."""

    # Define the full URL by combining the base URL and path
    url = f"{YNAB_BASE_URL}{path}"
    headers = {
        "Authorization": f"Bearer {YNAB_ACCESS_TOKEN}"
    }

    try:
        # Send the request using the specified HTTP method
        print(f"Fetching data from {url} using method: {method}")
        response = requests.request(method, url, headers=headers, json=body)
        response.raise_for_status()  # Raise an HTTPError for bad responses

        # Return the parsed JSON response
        return response.json()

    except requests.exceptions.HTTPError as http_err:
        print(f"HTTP error occurred: {http_err}")
        return {"error": f"HTTP error occurred: {http_err}"}
    except Exception as err:
        print(f"An error occurred: {err}")
        return {"error": "An unexpected error occurred"}

def get_scheduled_transactions(budget_id):
    """Fetches scheduled transactions for a given budget ID from the YNAB API."""

    if not budget_id:
        raise ValueError("A budget ID is required")

    # Define the path for scheduled transactions and use the fetch function
    path = f"budgets/{budget_id}/scheduled_transactions"
    result = fetch("GET", path)

    # Extract only the scheduled transactions data if no error occurred
    if "error" not in result:
        return result.get("data", {}).get("scheduled_transactions", [])
    else:
        return result

def get_uncategorized_transactions(budget_id):
    """Fetch uncategorized transactions for a given budget ID."""
    if not budget_id:
        raise ValueError("A budget ID is required")

    # Define the path for uncategorized transactions
    path = f"budgets/{budget_id}/transactions?type=uncategorized"
    result = fetch("GET", path)
    # filter out transfers with Payee name "Transfer :"
    return [transaction for transaction in result.get("data", {}).get("transactions", []) if not transaction["payee_name"].startswith("Transfer :")]

def get_unapproved_transactions(budget_id):
    """Fetch unapproved transactions for a given budget ID."""
    if not budget_id:
        raise ValueError("A budget ID is required")

    # Get all transactions and filter for unapproved ones
    path = f"budgets/{budget_id}/transactions"
    result = fetch("GET", path)
    all_transactions = result.get("data", {}).get("transactions", [])

    # Filter for unapproved transactions (excluding transfers)
    unapproved = []
    for transaction in all_transactions:
        # Handle None payee_name safely
        payee_name = transaction.get("payee_name") or ""

        if payee_name.startswith("Transfer :"):
            continue  # Skip transfers

        # Check if transaction needs approval
        is_approved = transaction.get("approved", True)  # Default to True if not specified

        if not is_approved:
            unapproved.append(transaction)

    return unapproved
</file>

<file path="packages/mathapi/.env.example">
# Server configuration
FLASK_APP=app.py
FLASK_ENV=development
PORT=5000

# MongoDB configuration (for caching calculations)
MONGODB_URI=mongodb://localhost:27017/budget-ai

# Auth0 configuration
AUTH0_DOMAIN=vandenit.eu.auth0.com
AUTH0_AUDIENCE=https://vandenit.eu.auth0.com/api/v2/

# API Service configuration
API_SERVICE_URL=http://localhost:4000

# CORS
CORS_ORIGINS=http://localhost:3000,https://your-production-domain.com
</file>

<file path="packages/web/app/api/auth/token/route.ts">
import { getSession } from "@auth0/nextjs-auth0";
import { NextResponse } from "next/server";

export async function GET() {
    const session = await getSession();
    if (!session?.accessToken) {
        return new NextResponse(null, { status: 401 });
    }
    return NextResponse.json({ accessToken: session.accessToken });
}
</file>

<file path="packages/web/app/api/transaction/transaction.client.ts">
import "server-only";
import { apiGet, apiFetch } from "../client";
import { TransactionsWithCategories } from "common-ts";

export const getFilteredTransactionsWithCategories = async (
  budgetUuid: string,
  month?: string,
  dayOfMonth?: string
): Promise<TransactionsWithCategories> =>
  apiGet(
    `budgets/${budgetUuid}/transactions?month=${
      month ? month : ""
    }&dayOfMonth=${dayOfMonth ? dayOfMonth : ""}`
  );

/**
 * Approve a single transaction
 */
export const approveSingleTransaction = async (
  budgetId: string,
  transactionId: string
) => {
  return apiFetch(`budgets/${budgetId}/transactions/approve-single`, {
    method: "POST",
    body: JSON.stringify({ transaction_id: transactionId }),
    headers: {
      "Content-Type": "application/json",
    },
  });
};

/**
 * Approve all unapproved transactions
 */
export const approveAllTransactions = async (budgetId: string) => {
  return apiFetch(`budgets/${budgetId}/transactions/approve-all`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
  });
};
</file>

<file path="packages/web/app/api/ai-suggestions.server.ts">
"use server";
import { apiFetch } from "./client";

/**
 * Get uncategorized transactions from Node.js API
 */
export const getUncategorizedTransactions = async (budgetId: string) => {
  return apiFetch(`budgets/${budgetId}/uncategorized-transactions`);
};

/**
 * Get unapproved transactions from Node.js API
 */
export const getUnapprovedTransactions = async (budgetId: string) => {
  return apiFetch(`budgets/${budgetId}/unapproved-transactions`);
};

/**
 * Get cached AI suggestions from Node.js API
 */
export const getCachedSuggestions = async (budgetId: string) => {
  return apiFetch(`budgets/${budgetId}/ai-suggestions/cached`);
};

/**
 * Get AI suggestions for specific transactions (progressive loading)
 */
export const getSuggestionsAsync = async (
  budgetId: string,
  transactionIds: string[]
) => {
  return apiFetch(`budgets/${budgetId}/ai-suggestions/suggestions-async`, {
    method: "POST",
    body: JSON.stringify({
      transaction_ids: transactionIds,
    }),
    headers: {
      "Content-Type": "application/json",
    },
  });
};

/**
 * Get AI suggestion for a single transaction
 */
export const getSingleSuggestion = async (
  budgetId: string,
  transactionId: string,
  transaction?: any
) => {
  const body: any = { transaction_id: transactionId };
  if (transaction) {
    body.transaction = transaction;
  }

  return apiFetch(`budgets/${budgetId}/ai-suggestions/suggest-single`, {
    method: "POST",
    body: JSON.stringify(body),
    headers: {
      "Content-Type": "application/json",
    },
  });
};

/**
 * Suggest categories for all uncategorized transactions
 */
export const suggestCategories = async (budgetId: string) =>
  apiFetch(`budgets/${budgetId}/ai-suggestions/suggest-categories`);

/**
 * Apply category for a single transaction
 */
export const applySingleCategory = async (
  budgetId: string,
  transactionId: string,
  categoryName: string,
  isManualChange: boolean = false
) => {
  return apiFetch(`budgets/${budgetId}/ai-suggestions/apply-single`, {
    method: "POST",
    body: JSON.stringify({
      transaction_id: transactionId,
      category_name: categoryName,
      is_manual_change: isManualChange,
    }),
    headers: {
      "Content-Type": "application/json",
    },
  });
};

/**
 * Apply categories for multiple transactions
 */
export const applyCategories = async (budgetId: string, transactions: any[]) =>
  apiFetch(`budgets/${budgetId}/ai-suggestions/apply-categories`, {
    method: "POST",
    body: JSON.stringify({ transactions }),
    headers: {
      "Content-Type": "application/json",
    },
  });

/**
 * Apply all categories for uncategorized transactions
 */
export const applyAllCategories = async (budgetId: string) =>
  apiFetch(`budgets/${budgetId}/ai-suggestions/apply-all-categories`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
  });
</file>

<file path="packages/web/app/api/categories.client.ts">
import { Category } from "common-ts";
import { getBudget, getBudgetOverviewForUser } from "./budget/budget.client";

export const getCategories = async (budgetId: string): Promise<Category[]> => {
    // todo : provide real catogories api
    const budget = await getBudgetOverviewForUser(budgetId);
    if (!budget) {
        throw new Error('Failed to fetch categories');
    }
    return budget.categories;
};
</file>

<file path="packages/web/app/api/math.server.ts">
import { getToken } from "./client";
import { handleServerApiResponse } from "./utils.server";

const mathApiFetch = async (
  path: string,
  options: RequestInit = {},
  accesToken?: string
) => {
  try {
    const token = await getToken(accesToken);
    const apiBaseUrl = process.env.MATH_API_URL || "http://localhost:5000";
    const apiUrl = new URL(path, apiBaseUrl).toString();
    const response = await fetch(apiUrl, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Math API error! status: ${response.status}, message: ${errorText}`
      );
    }

    return handleServerApiResponse(apiUrl, response);
  } catch (error) {
    console.error(`Error calling math API ${path}:`, error);
    throw error;
  }
};

/**
 * Get balance prediction data from Python Math API
 * This is the only endpoint that remains in the Python API
 */
export const getPrediction = async (
  budgetId: string,
  daysAhead: number = 180
) =>
  mathApiFetch(
    `balance-prediction/data?budget_id=${budgetId}&days_ahead=${daysAhead}`
  );
</file>

<file path="packages/web/app/api/utils.server.ts">
import { redirect } from 'next/navigation';
import { headers } from 'next/headers';

// Server-side unauthorized handler
export const handleServerUnauthorized = () => {
    const headersList = headers();
    const path = headersList.get('x-pathname') || '/';
    redirect('/api/defauth/login?returnTo=' + encodeURIComponent(path));
};

// Server-side API response handler
export const handleServerApiResponse = async (apiUrl: string, response: Response) => {
    if (response.status === 401) {
        handleServerUnauthorized();
        return null;
    }

    if (!response.ok) {
        throw new Error(`API call failed: ${response.status} for ${apiUrl}`);
    }

    return response.json();
};
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/CategoryChangesForm.tsx">
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { format } from 'date-fns';
import { CalendarIcon, Plus, Trash2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import { ChangeEvent, forwardRef } from 'react';

interface CategoryOption {
    uuid: string;
    name: string;
}

interface CategoryChange {
    categoryUuid: string;
    startDate?: string;
    endDate?: string;
    targetAmount: number;
}

interface CategoryChangesFormProps {
    categories: CategoryOption[];
    initialChanges?: CategoryChange[];
    onSubmit: (changes: CategoryChange[]) => void;
    onCancel: () => void;
}

const DatePickerButton = forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
    ({ className, ...props }, ref) => (
        <Button
            ref={ref}
            variant="outline"
            className={cn("w-full justify-start text-left font-normal", className)}
            {...props}
        />
    )
);
DatePickerButton.displayName = "DatePickerButton";

export function CategoryChangesForm({ categories, initialChanges = [], onSubmit, onCancel }: CategoryChangesFormProps) {
    const [changes, setChanges] = useState<CategoryChange[]>(initialChanges);

    const addChange = () => {
        setChanges([...changes, {
            categoryUuid: '',
            targetAmount: 0
        }]);
    };

    const removeChange = (index: number) => {
        setChanges(changes.filter((_, i) => i !== index));
    };

    const updateChange = (index: number, field: keyof CategoryChange, value: any) => {
        const newChanges = [...changes];
        newChanges[index] = { ...newChanges[index], [field]: value };
        setChanges(newChanges);
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        onSubmit(changes);
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-4">
                {changes.map((change, index) => (
                    <div key={index} className="p-4 border rounded-lg space-y-4">
                        <div className="flex justify-between items-center">
                            <h3 className="font-medium">Category Change {index + 1}</h3>
                            <Button
                                type="button"
                                variant="ghost"
                                size="icon"
                                onClick={() => removeChange(index)}
                            >
                                <Trash2 className="h-4 w-4" />
                            </Button>
                        </div>

                        <div>
                            <Label htmlFor={`category-${index}`}>Category</Label>
                            <Select
                                value={change.categoryUuid}
                                onValueChange={(value) => updateChange(index, 'categoryUuid', value)}
                            >
                                <SelectTrigger>
                                    <SelectValue placeholder="Select a category" />
                                </SelectTrigger>
                                <SelectContent>
                                    {categories.map((category) => (
                                        <SelectItem key={category.uuid} value={category.uuid}>
                                            {category.name}
                                        </SelectItem>
                                    ))}
                                </SelectContent>
                            </Select>
                        </div>

                        <div>
                            <Label htmlFor={`targetAmount-${index}`}>Target Amount ()</Label>
                            <Input
                                id={`targetAmount-${index}`}
                                type="number"
                                step="0.01"
                                min="0"
                                value={change.targetAmount}
                                onChange={(e) => updateChange(index, 'targetAmount', parseFloat(e.target.value))}
                                placeholder="200"
                                required
                                inputMode="decimal"
                            />
                        </div>

                        <div className="grid grid-cols-2 gap-4">
                            <div className="flex flex-col space-y-2">
                                <Label>Start Date</Label>
                                <Popover>
                                    <PopoverTrigger asChild>
                                        <DatePickerButton className={!change.startDate ? "text-muted-foreground" : ""}>
                                            <CalendarIcon className="mr-2 h-4 w-4" />
                                            {change.startDate ? format(new Date(change.startDate), "PPP") : <span>Pick a date</span>}
                                        </DatePickerButton>
                                    </PopoverTrigger>
                                    <PopoverContent className="w-auto p-0" align="start">
                                        <Calendar
                                            mode="single"
                                            selected={change.startDate ? new Date(change.startDate) : undefined}
                                            onSelect={(date) => date && updateChange(index, 'startDate', date.toISOString())}
                                            initialFocus
                                        />
                                    </PopoverContent>
                                </Popover>
                            </div>
                            <div className="flex flex-col space-y-2">
                                <Label>End Date</Label>
                                <Popover>
                                    <PopoverTrigger asChild>
                                        <DatePickerButton className={!change.endDate ? "text-muted-foreground" : ""}>
                                            <CalendarIcon className="mr-2 h-4 w-4" />
                                            {change.endDate ? format(new Date(change.endDate), "PPP") : <span>Pick a date</span>}
                                        </DatePickerButton>
                                    </PopoverTrigger>
                                    <PopoverContent className="w-auto p-0" align="start">
                                        <Calendar
                                            mode="single"
                                            selected={change.endDate ? new Date(change.endDate) : undefined}
                                            onSelect={(date) => date && updateChange(index, 'endDate', date.toISOString())}
                                            disabled={(date) =>
                                                change.startDate ? date < new Date(change.startDate) : false
                                            }
                                            initialFocus
                                        />
                                    </PopoverContent>
                                </Popover>
                            </div>
                        </div>
                    </div>
                ))}
            </div>

            <Button type="button" variant="outline" onClick={addChange} className="w-full">
                <Plus className="h-4 w-4 mr-2" />
                Add Category Change
            </Button>

            <div className="flex justify-end space-x-2">
                <Button type="button" variant="outline" onClick={onCancel}>
                    Cancel
                </Button>
                <Button type="submit">
                    Save Changes
                </Button>
            </div>
        </form>
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/transactions/actions.ts">
"use server";

import { revalidatePath } from "next/cache";
import { applySingleCategory } from "../../../api/ai-suggestions.server";

export interface CategoryUpdateResult {
  success: boolean;
  error?: string;
  transactionId?: string;
  categoryName?: string;
  message?: string;
}

export async function updateTransactionCategory(
  budgetId: string,
  transactionId: string,
  categoryName: string,
  isManualChange: boolean = true
): Promise<CategoryUpdateResult> {
  try {
    // Validate required fields
    if (!budgetId || !transactionId || !categoryName) {
      return {
        success: false,
        error: "Missing required fields: budgetId, transactionId, categoryName",
      };
    }

    // Call the server-side function
    const result = await applySingleCategory(
      budgetId,
      transactionId,
      categoryName,
      isManualChange
    );

    if (result.success) {
      // Revalidate the transactions page to show updated data
      revalidatePath(`/budgets/${budgetId}/transactions`);

      return {
        success: true,
        transactionId,
        categoryName,
        message: result.message || `Applied '${categoryName}' to transaction`,
      };
    } else {
      return {
        success: false,
        error: result.error || "Failed to update category",
      };
    }
  } catch (error) {
    console.error("Error updating transaction category:", error);

    return {
      success: false,
      error: error instanceof Error ? error.message : "Internal server error",
    };
  }
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/TransactionsDataSection.tsx">
import { Category } from 'common-ts';
import TransactionsPageWithTabs from './TransactionsPageWithTabs';
import { getUncategorizedTransactions } from '../../../api/ai-suggestions.server';
import { getUnapprovedTransactions } from './actions';

interface TransactionsDataSectionProps {
    budgetUuid: string;
    categories: Category[];
}

interface FormattedTransaction {
    transaction_id: string;
    payee_name: string;
    clean_payee_name?: string;
    amount: number;
    date: string;
    memo?: string;
    suggested_category_name: string | null;
    loading_suggestion: boolean;
    cached: boolean;
}

export default async function TransactionsDataSection({ budgetUuid, categories }: TransactionsDataSectionProps) {
    try {
        // Get uncategorized transactions (with cached suggestions) and unapproved transactions in parallel
        const [uncategorizedTransactions, unapprovedTransactions] = await Promise.all([
            getUncategorizedTransactions(budgetUuid),
            getUnapprovedTransactions(budgetUuid)
        ]);

        // Transform Node.js response to match frontend expectations
        const formattedUncategorizedTransactions: FormattedTransaction[] = uncategorizedTransactions.map((tx: any) => ({
            transaction_id: tx.transaction_id,
            payee_name: tx.payee_name,
            clean_payee_name: tx.clean_payee_name,
            amount: tx.amount,
            date: tx.date,
            memo: tx.memo,
            suggested_category_name: tx.ai_suggested_category || null,
            loading_suggestion: !tx.ai_suggested_category, // Need to load if no cached suggestion
            cached: !!tx.ai_suggested_category
        }));

        const cachedCount = formattedUncategorizedTransactions.filter((tx: FormattedTransaction) => tx.cached).length;

        console.log(` Loaded transactions page with ${formattedUncategorizedTransactions.length} uncategorized and ${unapprovedTransactions.length} unapproved transactions`);
        console.log(` ${cachedCount} cached suggestions available`);

        return (
            <TransactionsPageWithTabs
                budgetUuid={budgetUuid}
                categories={categories}
                uncategorizedTransactions={formattedUncategorizedTransactions}
                unapprovedTransactions={unapprovedTransactions}
            />
        );
    } catch (error) {
        console.error('Error loading transactions:', error);
        return (
            <div className="p-4">
                <h2 className="text-xl font-bold mb-4 text-red-600">Error Loading Transactions</h2>
                <p className="text-gray-600">
                    Failed to load transactions. Please try again.
                </p>
                <p className="text-sm text-gray-500 mt-2">
                    Error: {error instanceof Error ? error.message : 'Unknown error'}
                </p>
            </div>
        );
    }
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/UnapprovedTransactionsList.tsx">
"use client";

import { useState } from 'react';
import { Category } from 'common-ts';
import { UnapprovedTransaction } from './UnapprovedTransactionsContent';
import { groupByDateGeneric, calculateTotalsGeneric } from '../../../components/transactions-page/utils';
import { TransactionCard, BaseTransaction } from '../../../components/transactions-page/transaction-card';
import { TransactionDateGroup } from '../../../components/transactions-page/transaction-date-group';
import { TransactionFilters, FilterType, SortType, unapprovedFilters, unapprovedSortOptions } from '../../../components/transactions-page/transaction-filters';
import { BadgeType } from '../../../components/transactions-page/transaction-badge';

interface Props {
    transactions: UnapprovedTransaction[];
    categories: Category[];
    approvingTransactions: Set<string>;
    onApproveSingle: (transactionId: string) => Promise<void>;
    onCategorizeAndApprove: (transactionId: string, categoryName: string) => Promise<void>;
}

// Create a compatible transaction type for the card component
interface UnapprovedTransactionForCard extends BaseTransaction {
    transaction_id: string;
    category_name?: string;
}

export default function UnapprovedTransactionsList({
    transactions,
    categories,
    approvingTransactions,
    onApproveSingle,
    onCategorizeAndApprove
}: Props) {
    const [editingTransaction, setEditingTransaction] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const [activeFilter, setActiveFilter] = useState<FilterType>('all');
    const [sortBy, setSortBy] = useState<SortType>('uncategorized_first');

    // Helper functions
    const getBadgeType = (transaction: UnapprovedTransaction): BadgeType => {
        if (transaction.category_name) return 'approved';
        return 'pending-approval';
    };

    const getVariant = (transaction: UnapprovedTransaction) => {
        if (!transaction.category_name) return 'attention';
        return 'success';
    };

    // Filter and search logic
    const getFilteredAndSortedTransactions = () => {
        let filtered = transactions;

        // Apply search filter
        if (searchTerm) {
            filtered = filtered.filter(tx =>
                tx.payee_name.toLowerCase().includes(searchTerm.toLowerCase())
            );
        }

        // Apply category filter
        switch (activeFilter) {
            case 'categorized':
                filtered = filtered.filter(tx => tx.category_name);
                break;
            case 'uncategorized':
                filtered = filtered.filter(tx => !tx.category_name);
                break;
            case 'all':
            default:
                break;
        }

        // Apply sorting
        switch (sortBy) {
            case 'uncategorized_first':
                filtered.sort((a, b) => {
                    const aUncategorized = !a.category_name;
                    const bUncategorized = !b.category_name;
                    if (aUncategorized === bUncategorized) {
                        return new Date(b.date).getTime() - new Date(a.date).getTime();
                    }
                    return aUncategorized ? -1 : 1;
                });
                break;
            case 'amount_desc':
                filtered.sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount));
                break;
            case 'date_newest':
                filtered.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
                break;
            case 'payee_name':
                filtered.sort((a, b) => a.payee_name.localeCompare(b.payee_name));
                break;
        }

        return filtered;
    };

    // Event handlers
    const handleCategoryEdit = (transactionId: string) => {
        setEditingTransaction(transactionId);
    };

    const handleCategorySave = async (transactionId: string, newCategoryId: string) => {
        const selectedCategory = categories.find(c => c._id === newCategoryId);
        if (selectedCategory) {
            await onCategorizeAndApprove(transactionId, selectedCategory.name);
        }
        setEditingTransaction(null);
    };

    const handleApprove = async (transactionId: string) => {
        await onApproveSingle(transactionId);
    };

    // Prepare data
    const filteredTransactions = getFilteredAndSortedTransactions();
    const groupedTransactions = groupByDateGeneric(filteredTransactions);

    // Convert transactions to format compatible with TransactionCard
    const convertToCardFormat = (transaction: UnapprovedTransaction): UnapprovedTransactionForCard => ({
        ...transaction,
        cleanPayeeName: transaction.clean_payee_name,
        memo: transaction.memo || `Transaction ID: ${transaction.transaction_id}`
    });

    // Count statistics for filter badges
    const categorizedCount = transactions.filter(tx => tx.category_name).length;
    const uncategorizedCount = transactions.filter(tx => !tx.category_name).length;

    // Prepare filter options with counts
    const getFilterCount = (filterValue: string) => {
        switch (filterValue) {
            case 'all': return transactions.length;
            case 'categorized': return categorizedCount;
            case 'uncategorized': return uncategorizedCount;
            default: return 0;
        }
    };

    const filterOptions = unapprovedFilters.map(option => ({
        ...option,
        count: getFilterCount(option.value)
    }));

    return (
        <div className="space-y-4">
            {/* Filters */}
            <TransactionFilters
                searchTerm={searchTerm}
                onSearchChange={setSearchTerm}
                searchPlaceholder="Search by payee name..."
                activeFilter={activeFilter}
                onFilterChange={setActiveFilter}
                filterOptions={filterOptions}
                sortBy={sortBy}
                onSortChange={setSortBy}
                sortOptions={unapprovedSortOptions}
                totalCount={transactions.length}
                filteredCount={filteredTransactions.length}
            />

            {/* Results */}
            {filteredTransactions.length === 0 ? (
                <div className="card bg-base-100 shadow-lg">
                    <div className="card-body text-center py-12">
                        <div className="text-6xl mb-4"></div>
                        <h3 className="text-xl font-bold mb-2">No results found</h3>
                        <p className="text-gray-600">
                            {searchTerm || activeFilter !== 'all'
                                ? 'Try adjusting your search or filters.'
                                : 'No transactions available.'
                            }
                        </p>
                        {(searchTerm || activeFilter !== 'all') && (
                            <button
                                className="btn btn-outline btn-sm mt-4"
                                onClick={() => {
                                    setSearchTerm('');
                                    setActiveFilter('all');
                                }}
                            >
                                Clear all filters
                            </button>
                        )}
                    </div>
                </div>
            ) : (
                Object.entries(groupedTransactions)
                    .sort(([a], [b]) => new Date(b).getTime() - new Date(a).getTime())
                    .map(([date, dayTransactions]) => (
                        <TransactionDateGroup
                            key={date}
                            date={date}
                            transactions={dayTransactions}
                            defaultOpen={true}
                            showTotals={true}
                            showTransactionCount={true}
                            customTotals={calculateTotalsGeneric(dayTransactions)}
                        >
                            {dayTransactions.map((transaction) => {
                                const cardTransaction = convertToCardFormat(transaction);
                                const isApproving = approvingTransactions.has(transaction.transaction_id);
                                const isEditing = editingTransaction === transaction.transaction_id;

                                return (
                                    <div key={transaction.transaction_id}>
                                        <TransactionCard
                                            transaction={cardTransaction}
                                            categoryName={transaction.category_name || undefined}
                                            statusBadge={{
                                                type: getBadgeType(transaction)
                                            }}
                                            showCategory={true}
                                            showActions={true}
                                            showMemo={true}
                                            onEdit={() => handleCategoryEdit(transaction.transaction_id)}
                                            onApply={transaction.category_name ? () => handleApprove(transaction.transaction_id) : undefined}
                                            isApplying={isApproving}
                                            isEditing={isEditing}
                                            variant={getVariant(transaction)}
                                        />

                                        {/* Category editing dropdown */}
                                        {isEditing && (
                                            <div className="mt-2 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
                                                <div className="flex items-center gap-2">
                                                    <span className="text-sm font-medium">Select category to approve:</span>
                                                    <select
                                                        className="select select-bordered select-sm flex-1 max-w-xs"
                                                        defaultValue=""
                                                        onChange={(e) => {
                                                            if (e.target.value) {
                                                                handleCategorySave(transaction.transaction_id, e.target.value);
                                                            }
                                                        }}
                                                    >
                                                        <option value="" disabled>Choose category...</option>
                                                        {categories.map((category) => (
                                                            <option key={category._id} value={category._id}>
                                                                {category.name}
                                                            </option>
                                                        ))}
                                                    </select>
                                                    <button
                                                        className="btn btn-ghost btn-sm"
                                                        onClick={() => setEditingTransaction(null)}
                                                        title="Cancel"
                                                    >
                                                        
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </TransactionDateGroup>
                    ))
            )}
        </div>
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/UncategorisedTransactionsList.tsx">
"use client";

import { useState } from 'react';
import { Category } from 'common-ts';
import { SuggestedTransaction } from './UncategorisedTransactionsContent';
import { groupByDateGeneric, calculateTotalsGeneric } from '../../../components/transactions-page/utils';
import { TransactionCard, BaseTransaction } from '../../../components/transactions-page/transaction-card';
import { TransactionDateGroup } from '../../../components/transactions-page/transaction-date-group';
import { TransactionFilters, FilterType, SortType, uncategorizedFilters, uncategorizedSortOptions } from '../../../components/transactions-page/transaction-filters';
import { BadgeType } from '../../../components/transactions-page/transaction-badge';

interface Props {
    transactions: SuggestedTransaction[];
    categories: Category[];
    manuallyModified: Set<string>;
    applyingTransactions: Set<string>;
    onCategoryChange: (transactionId: string, newCategoryName: string) => void;
    onRemoveTransaction: (transactionId: string) => void;
    onApplySingleCategory: (transactionId: string, categoryName: string) => Promise<void>;
    onApplyManualCategory: (transactionId: string, categoryName: string) => Promise<void>;
}

// Create a compatible transaction type for the card component
interface SuggestedTransactionForCard extends BaseTransaction {
    transaction_id: string;
    suggested_category_name?: string | null;
    loading_suggestion?: boolean;
    cached?: boolean;
}

export default function UncategorisedTransactionsList({
    transactions,
    categories,
    manuallyModified,
    applyingTransactions,
    onCategoryChange,
    onRemoveTransaction,
    onApplySingleCategory,
    onApplyManualCategory
}: Props) {
    const [editingTransaction, setEditingTransaction] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const [activeFilter, setActiveFilter] = useState<FilterType>('all');
    const [sortBy, setSortBy] = useState<SortType>('needs_attention_first');

    // Helper functions
    const getBadgeType = (transaction: SuggestedTransaction): BadgeType => {
        const isManuallyModified = manuallyModified.has(transaction.transaction_id);
        const isLoading = transaction.loading_suggestion || false;
        const isCached = transaction.cached || false;
        const isUncategorized = transaction.suggested_category_name === 'Uncategorized';

        if (isManuallyModified) return 'manual-edit';
        if (isLoading) return 'loading';
        if (isCached) return 'ai-cached';
        if (isUncategorized) return 'ai-uncategorized';
        if (transaction.suggested_category_name) return 'ai-generated';
        return 'no-suggestion';
    };

    const getVariant = (transaction: SuggestedTransaction) => {
        const isManuallyModified = manuallyModified.has(transaction.transaction_id);
        const isUncategorized = transaction.suggested_category_name === 'Uncategorized';

        if (isUncategorized) return 'attention';
        if (isManuallyModified) return 'modified';
        return 'default';
    };

    // Filter and search logic
    const getFilteredAndSortedTransactions = () => {
        let filtered = transactions;

        // Apply search filter
        if (searchTerm) {
            filtered = filtered.filter(tx =>
                tx.payee_name.toLowerCase().includes(searchTerm.toLowerCase())
            );
        }

        // Apply category filter
        switch (activeFilter) {
            case 'uncategorized':
                filtered = filtered.filter(tx => tx.suggested_category_name === 'Uncategorized');
                break;
            case 'manual_edit':
                filtered = filtered.filter(tx => manuallyModified.has(tx.transaction_id));
                break;
            case 'ai_suggestions':
                filtered = filtered.filter(tx =>
                    tx.suggested_category_name &&
                    tx.suggested_category_name !== 'Uncategorized' &&
                    !manuallyModified.has(tx.transaction_id)
                );
                break;
            case 'all':
            default:
                break;
        }

        // Apply sorting
        switch (sortBy) {
            case 'needs_attention_first':
                filtered.sort((a, b) => {
                    const aNeedsAttention = a.suggested_category_name === 'Uncategorized';
                    const bNeedsAttention = b.suggested_category_name === 'Uncategorized';
                    if (aNeedsAttention === bNeedsAttention) {
                        return new Date(b.date).getTime() - new Date(a.date).getTime();
                    }
                    return aNeedsAttention ? -1 : 1;
                });
                break;
            case 'amount_desc':
                filtered.sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount));
                break;
            case 'date_newest':
                filtered.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
                break;
            case 'payee_name':
                filtered.sort((a, b) => a.payee_name.localeCompare(b.payee_name));
                break;
        }

        return filtered;
    };

    // Event handlers
    const handleCategoryEdit = (transactionId: string) => {
        setEditingTransaction(transactionId);
    };

    const handleCategorySave = async (transactionId: string, newCategoryId: string) => {
        const selectedCategory = categories.find(c => c._id === newCategoryId);
        if (selectedCategory) {
            onCategoryChange(transactionId, selectedCategory.name);

            // Auto-switch filters if needed
            const transaction = transactions.find(t => t.transaction_id === transactionId);
            if (transaction && activeFilter !== 'all' && activeFilter !== 'manual_edit') {
                const shouldSwitchToAll =
                    (activeFilter === 'uncategorized' && selectedCategory.name !== 'Uncategorized') ||
                    (activeFilter === 'ai_suggestions' && selectedCategory.name === 'Uncategorized');

                if (shouldSwitchToAll) {
                    setActiveFilter('all');
                }
            }
        }
        setEditingTransaction(null);
    };

    const handleApplyClick = async (transactionId: string, categoryName: string) => {
        const isManuallyModified = manuallyModified.has(transactionId);

        if (isManuallyModified) {
            await onApplyManualCategory(transactionId, categoryName);
        } else {
            await onApplySingleCategory(transactionId, categoryName);
        }
    };

    // Prepare data
    const filteredTransactions = getFilteredAndSortedTransactions();
    const groupedTransactions = groupByDateGeneric(filteredTransactions);

    // Convert transactions to format compatible with TransactionCard
    const convertToCardFormat = (transaction: SuggestedTransaction): SuggestedTransactionForCard => ({
        ...transaction,
        cleanPayeeName: transaction.clean_payee_name,
        memo: transaction.memo || `Transaction ID: ${transaction.transaction_id}`
    });

    // Count statistics for filter badges
    const uncategorizedCount = transactions.filter(tx => tx.suggested_category_name === 'Uncategorized').length;
    const manualEditCount = manuallyModified.size;
    const aiSuggestionsCount = transactions.filter(tx =>
        tx.suggested_category_name &&
        tx.suggested_category_name !== 'Uncategorized' &&
        !manuallyModified.has(tx.transaction_id)
    ).length;

    // Prepare filter options with counts
    const getFilterCount = (filterValue: string) => {
        switch (filterValue) {
            case 'all': return transactions.length;
            case 'uncategorized': return uncategorizedCount;
            case 'manual_edit': return manualEditCount;
            case 'ai_suggestions': return aiSuggestionsCount;
            default: return 0;
        }
    };

    const filterOptions = uncategorizedFilters.map(option => ({
        ...option,
        count: getFilterCount(option.value)
    }));

    return (
        <div className="space-y-4">
            {/* Filters */}
            <TransactionFilters
                searchTerm={searchTerm}
                onSearchChange={setSearchTerm}
                searchPlaceholder="Search by payee name..."
                activeFilter={activeFilter}
                onFilterChange={setActiveFilter}
                filterOptions={filterOptions}
                sortBy={sortBy}
                onSortChange={setSortBy}
                sortOptions={uncategorizedSortOptions}
                totalCount={transactions.length}
                filteredCount={filteredTransactions.length}
            />

            {/* Results */}
            {filteredTransactions.length === 0 ? (
                <div className="card bg-base-100 shadow-lg">
                    <div className="card-body text-center py-12">
                        <div className="text-6xl mb-4"></div>
                        <h3 className="text-xl font-bold mb-2">No results found</h3>
                        <p className="text-gray-600">
                            {searchTerm || activeFilter !== 'all'
                                ? 'Try adjusting your search or filters.'
                                : 'No transactions available.'
                            }
                        </p>
                        {(searchTerm || activeFilter !== 'all') && (
                            <button
                                className="btn btn-outline btn-sm mt-4"
                                onClick={() => {
                                    setSearchTerm('');
                                    setActiveFilter('all');
                                }}
                            >
                                Clear all filters
                            </button>
                        )}
                    </div>
                </div>
            ) : (
                Object.entries(groupedTransactions).map(([date, dayTransactions]) => (
                    <TransactionDateGroup
                        key={date}
                        date={date}
                        transactions={dayTransactions}
                        defaultOpen={true}
                        showTotals={true}
                        showTransactionCount={true}
                        customTotals={calculateTotalsGeneric(dayTransactions)}
                    >
                        {dayTransactions.map((transaction) => {
                            const cardTransaction = convertToCardFormat(transaction);
                            const isApplying = applyingTransactions.has(transaction.transaction_id);
                            const isEditing = editingTransaction === transaction.transaction_id;

                            return (
                                <div key={transaction.transaction_id}>
                                    <TransactionCard
                                        transaction={cardTransaction}
                                        categoryName={transaction.suggested_category_name || undefined}
                                        categoryBadgeProps={{
                                            isManuallyModified: manuallyModified.has(transaction.transaction_id),
                                            isUncategorized: transaction.suggested_category_name === 'Uncategorized',
                                            isCached: transaction.cached || false
                                        }}
                                        statusBadge={{
                                            type: getBadgeType(transaction)
                                        }}
                                        showCategory={true}
                                        showActions={true}
                                        showMemo={true}
                                        onEdit={() => handleCategoryEdit(transaction.transaction_id)}
                                        onRemove={() => onRemoveTransaction(transaction.transaction_id)}
                                        onApply={() => handleApplyClick(transaction.transaction_id, transaction.suggested_category_name!)}
                                        isApplying={isApplying}
                                        isEditing={isEditing}
                                        variant={getVariant(transaction)}
                                    />

                                    {/* Category editing dropdown */}
                                    {isEditing && (
                                        <div className="mt-2 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
                                            <div className="flex items-center gap-2">
                                                <span className="text-sm font-medium">Select category:</span>
                                                <select
                                                    className="select select-bordered select-sm flex-1 max-w-xs"
                                                    defaultValue={categories.find(c => c.name === transaction.suggested_category_name)?._id || ''}
                                                    onChange={(e) => {
                                                        if (e.target.value) {
                                                            handleCategorySave(transaction.transaction_id, e.target.value);
                                                        }
                                                    }}
                                                >
                                                    <option value="">Select category</option>
                                                    {categories.map((category) => (
                                                        <option key={category._id} value={category._id}>
                                                            {category.name}
                                                        </option>
                                                    ))}
                                                </select>
                                                <button
                                                    className="btn btn-ghost btn-sm"
                                                    onClick={() => setEditingTransaction(null)}
                                                    title="Cancel"
                                                >
                                                    
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </TransactionDateGroup>
                ))
            )}
        </div>
    );
}
</file>

<file path="packages/web/app/components/transactions-page/transaction-filters.tsx">
import React from 'react';
import { FaSearch, FaSort, FaExclamationTriangle, FaPencilAlt, FaRobot, FaClock } from 'react-icons/fa';

// Filter types for different transaction views
export type FilterType = 'all' | 'uncategorized' | 'manual_edit' | 'ai_suggestions' | 'categorized' | 'pending';

export type SortType =
  | 'needs_attention_first'
  | 'amount_desc'
  | 'date_newest'
  | 'payee_name'
  | 'uncategorized_first';

interface FilterOption {
  value: FilterType;
  label: string;
  icon?: React.ReactNode;
  count?: number;
  variant?: 'primary' | 'warning' | 'info' | 'success' | 'error';
}

interface SortOption {
  value: SortType;
  label: string;
  emoji?: string;
}

interface TransactionFiltersProps {
  // Search
  searchTerm: string;
  onSearchChange: (term: string) => void;
  searchPlaceholder?: string;

  // Filters
  activeFilter: FilterType;
  onFilterChange: (filter: FilterType) => void;
  filterOptions: FilterOption[];

  // Sorting
  sortBy: SortType;
  onSortChange: (sort: SortType) => void;
  sortOptions: SortOption[];

  // Results info
  totalCount: number;
  filteredCount: number;

  // Styling
  className?: string;
}

export const TransactionFilters: React.FC<TransactionFiltersProps> = ({
  searchTerm,
  onSearchChange,
  searchPlaceholder = "Search transactions...",
  activeFilter,
  onFilterChange,
  filterOptions,
  sortBy,
  onSortChange,
  sortOptions,
  totalCount,
  filteredCount,
  className = ''
}) => {
  const getFilterButtonClass = (option: FilterOption) => {
    const baseClass = 'inline-flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200';
    const isActive = activeFilter === option.value;

    if (isActive) {
      switch (option.variant) {
        case 'warning': return `${baseClass} bg-amber-100 text-amber-800 border border-amber-200 dark:bg-amber-900/20 dark:text-amber-300 dark:border-amber-800`;
        case 'info': return `${baseClass} bg-blue-100 text-blue-800 border border-blue-200 dark:bg-blue-900/20 dark:text-blue-300 dark:border-blue-800`;
        case 'success': return `${baseClass} bg-emerald-100 text-emerald-800 border border-emerald-200 dark:bg-emerald-900/20 dark:text-emerald-300 dark:border-emerald-800`;
        case 'error': return `${baseClass} bg-red-100 text-red-800 border border-red-200 dark:bg-red-900/20 dark:text-red-300 dark:border-red-800`;
        default: return `${baseClass} bg-slate-100 text-slate-800 border border-slate-200 dark:bg-slate-800 dark:text-slate-200 dark:border-slate-700`;
      }
    } else {
      return `${baseClass} bg-white text-slate-600 border border-slate-200 hover:bg-slate-50 hover:text-slate-800 dark:bg-slate-900 dark:text-slate-400 dark:border-slate-700 dark:hover:bg-slate-800 dark:hover:text-slate-200`;
    }
  };

  return (
    <div className={`bg-white dark:bg-slate-900 rounded-xl shadow-sm border border-slate-200 dark:border-slate-700 ${className}`}>
      <div className="p-5">
        {/* Search and Controls Row */}
        <div className="flex flex-col lg:flex-row gap-4 items-start lg:items-center">

          {/* Search Input */}
          <div className="flex-1 w-full lg:max-w-md">
            <div className="relative">
              <FaSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
              <input
                type="text"
                placeholder={searchPlaceholder}
                className="input input-bordered w-full pl-10"
                value={searchTerm}
                onChange={(e) => onSearchChange(e.target.value)}
              />
            </div>
          </div>

          {/* Filter Buttons */}
          <div className="flex flex-wrap gap-2">
            {filterOptions.map((option) => (
              <button
                key={option.value}
                className={getFilterButtonClass(option)}
                onClick={() => onFilterChange(option.value)}
                title={option.label}
              >
                {option.icon}
                <span className="hidden sm:inline">
                  {option.label}
                </span>
                {option.count !== undefined && (
                  <span className="inline-flex items-center justify-center w-5 h-5 text-xs font-bold bg-white/80 text-slate-700 rounded-full dark:bg-slate-700/80 dark:text-slate-300">
                    {option.count}
                  </span>
                )}
              </button>
            ))}
          </div>

          {/* Sort Dropdown */}
          <div className="dropdown dropdown-end">
            <div tabIndex={0} role="button" className="btn btn-outline btn-sm gap-2">
              <FaSort />
              <span className="hidden sm:inline">Sort</span>
            </div>
            <ul tabIndex={0} className="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-64">
              {sortOptions.map((option) => (
                <li key={option.value}>
                  <button
                    className={sortBy === option.value ? 'menu-active' : ''}
                    onClick={() => onSortChange(option.value)}
                  >
                    {option.emoji && <span>{option.emoji}</span>}
                    {option.label}
                  </button>
                </li>
              ))}
            </ul>
          </div>
        </div>

        {/* Active Filters and Results Info */}
        {(searchTerm || activeFilter !== 'all') && (
          <div className="mt-3 flex flex-wrap gap-2 items-center">
            <span className="text-sm text-gray-600">Active filters:</span>

            {/* Search term badge */}
            {searchTerm && (
              <div className="inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium bg-slate-100 text-slate-700 border border-slate-200 dark:bg-slate-800 dark:text-slate-300 dark:border-slate-700">
                <FaSearch className="w-3 h-3" />
                &quot;{searchTerm}&quot;
                <button
                  className="ml-1 text-xs hover:text-red-500 transition-colors"
                  onClick={() => onSearchChange('')}
                  title="Clear search"
                >
                  
                </button>
              </div>
            )}

            {/* Active filter badge */}
            {activeFilter !== 'all' && (
              <div className="inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium bg-blue-100 text-blue-800 border border-blue-200 dark:bg-blue-900/20 dark:text-blue-300 dark:border-blue-800">
                {filterOptions.find(opt => opt.value === activeFilter)?.label ?? activeFilter}
                <button
                  className="ml-1 text-xs hover:text-red-500 transition-colors"
                  onClick={() => onFilterChange('all')}
                  title="Clear filter"
                >
                  
                </button>
              </div>
            )}

            {/* Results count */}
            <span className="text-sm text-gray-500">
              ({filteredCount} of {totalCount} transactions)
            </span>
          </div>
        )}
      </div>
    </div>
  );
};

// Predefined filter configurations for common use cases
export const uncategorizedFilters: FilterOption[] = [
  { value: 'all', label: 'All', variant: 'primary' },
  {
    value: 'uncategorized',
    label: 'Uncategorized',
    icon: <FaExclamationTriangle className="w-3 h-3" />,
    variant: 'warning'
  },
  {
    value: 'manual_edit',
    label: 'Manual',
    icon: <FaPencilAlt className="w-3 h-3" />,
    variant: 'info'
  },
  {
    value: 'ai_suggestions',
    label: 'AI suggestions',
    icon: <FaRobot className="w-3 h-3" />,
    variant: 'success'
  }
];

export const unapprovedFilters: FilterOption[] = [
  { value: 'all', label: 'All', variant: 'primary' },
  { value: 'categorized', label: 'Categorized', variant: 'success' },
  { value: 'uncategorized', label: 'Uncategorized', variant: 'warning' }
];

export const uncategorizedSortOptions: SortOption[] = [
  { value: 'needs_attention_first', label: 'Needs attention first', emoji: '' },
  { value: 'amount_desc', label: 'Amount (high  low)', emoji: '' },
  { value: 'date_newest', label: 'Date (newest  oldest)', emoji: '' },
  { value: 'payee_name', label: 'Payee (A-Z)', emoji: '' }
];

export const unapprovedSortOptions: SortOption[] = [
  { value: 'uncategorized_first', label: 'Uncategorized first', emoji: '' },
  { value: 'amount_desc', label: 'Amount (high  low)', emoji: '' },
  { value: 'date_newest', label: 'Date (newest  oldest)', emoji: '' },
  { value: 'payee_name', label: 'Payee (A-Z)', emoji: '' }
];
</file>

<file path="packages/web/app/components/transactions-page/transaction-list.tsx">
import { groupByDateGeneric } from "./utils";
import { Category, Transaction } from "common-ts";
import { TransactionCard, BaseTransaction } from "./transaction-card";
import { TransactionDateGroup } from "./transaction-date-group";
import { useCategoryUpdate } from "../../hooks/use-category-update";
import { useState } from "react";

// Create a compatible transaction type for the card component
interface TransactionForCard extends BaseTransaction {
  uuid: string;
  categoryId: string | undefined | null;
  payeeName: string;
  cleanPayeeName: string;
}

export const TransactionList = ({
  transactions,
  categories,
  budgetUuid,
  enableCategoryEdit = false
}: {
  transactions: Transaction[];
  categories: Category[];
  budgetUuid?: string;
  enableCategoryEdit?: boolean;
}) => {
  const [updatedTransactions, setUpdatedTransactions] = useState<Transaction[]>(transactions);

  const { updateCategory, isUpdatingTransaction } = useCategoryUpdate({
    budgetId: budgetUuid || '',
    onSuccess: (transactionId, categoryName) => {
      // Update the local state to reflect the category change
      setUpdatedTransactions(prev =>
        prev.map(t =>
          (t.uuid === transactionId)
            ? { ...t, categoryId: categories.find(c => c.name === categoryName)?._id || null }
            : t
        )
      );
    },
    onError: (error) => {
      console.error('Failed to update category:', error);
      // You could add toast notification here
    }
  });
  const getCategoryName = (categoryId: string | undefined | null, categories: Category[]) => {
    const category = categories.find((category) => category._id === categoryId);
    return category ? category.name : "Uncategorized";
  };

  const handleCategoryChange = async (transactionId: string, categoryId: string, categoryName: string) => {
    if (!budgetUuid) return;
    await updateCategory(transactionId, categoryId, categoryName, true);
  };

  // Use updated transactions for display
  const transactionsToDisplay = updatedTransactions.length > 0 ? updatedTransactions : transactions;

  // Convert transactions to format compatible with TransactionCard
  const transactionsForCard: TransactionForCard[] = transactionsToDisplay.map(transaction => ({
    uuid: transaction.uuid,
    amount: transaction.amount,
    payee_name: transaction.payeeName,
    payeeName: transaction.payeeName,
    cleanPayeeName: transaction.cleanPayeeName,
    date: transaction.date,
    memo: transaction.memo,
    categoryId: transaction.categoryId,
    id: transaction.uuid // Add id field for compatibility
  }));

  const groupedTransactions = groupByDateGeneric(transactionsForCard);

  return (
    <div className="space-y-4">
      {Object.entries(groupedTransactions).map(([date, dayTransactions]) => (
        <TransactionDateGroup
          key={date}
          date={date}
          transactions={dayTransactions}
          defaultOpen={true}
          showTotals={true}
          showTransactionCount={true}
        >
          {dayTransactions.map((transaction) => {
            const categoryName = getCategoryName(transaction.categoryId, categories);
            const categoryId = transaction.categoryId || undefined;
            const isUpdating = isUpdatingTransaction(transaction.uuid);

            return (
              <TransactionCard
                key={transaction.uuid}
                transaction={transaction}
                categoryName={categoryName}
                categoryId={categoryId}
                categories={categories}
                enableCategoryEdit={enableCategoryEdit && !!budgetUuid}
                onCategoryChange={handleCategoryChange}
                showCategory={true}
                showActions={false}
                showMemo={true}
                isEditing={isUpdating}
                variant={transaction.categoryId ? 'default' : 'attention'}
              />
            );
          })}
        </TransactionDateGroup>
      ))}
    </div>
  );
};
</file>

<file path="packages/web/app/layout.tsx">
import "./globals.css";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import BudgetNavigation from "./components/budget-navigation";
import { UserProvider } from "@auth0/nextjs-auth0/client";
import { getSession } from "@auth0/nextjs-auth0";
import { findBudgets } from "./api/budget/budget.client";
import { useEffect } from "react";
import { overrideConsoleLog } from "common-ts";
import { Toaster } from "@/components/ui/sonner";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Budget AI",
  description: "Your smart budget app",
};

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  overrideConsoleLog();

  const session = await getSession();
  const isLoggedIn: boolean = !!session?.user;
  const budgets = session && isLoggedIn ? await findBudgets() : [];
  return (
    <UserProvider>
      <html lang="en" data-theme="dark" className="dark">
        <body className="dark:bg-background dark:text-foreground">
          <BudgetNavigation budgets={budgets} loggedIn={isLoggedIn} />
          <main className="container mx-auto p-2">{children}</main>
          <Toaster />
        </body>
      </html>
    </UserProvider>
  );
}
</file>

<file path="packages/web/.env.example">
YNAB_CLIENT_ID=YOUR_YNAB_CLIENT_ID_HERE
YNAB_CLIENT_SECRET=YOUR_YNAB_CLIENT_SECRET_HERE
OPENAI_API_KEY=YOUR_OPENAI_API_KEY_HERE
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET=GENERATE_A_RANDOM_SECRET_HERE


# Auth0 configuration
AUTH0_SECRET=GENERATE_A_RANDOM_SECRET_HERE
AUTH0_BASE_URL=http://localhost:3000
AUTH0_ISSUER_BASE_URL='https://your-tenant.region.auth0.com'
AUTH0_CLIENT_ID='YOUR_AUTH0_CLIENT_ID'
AUTH0_CLIENT_SECRET='YOUR_AUTH0_CLIENT_SECRET'
AUTH0_AUDIENCE='https://your-tenant.region.auth0.com/api/v2/'
AUTH0_SCOPE='openid profile'
AUTH0_CALLBACK=api/defauth/callback

# Sync configuration (needs to be the same for web and api)
SYNC_SECRET=GENERATE_A_RANDOM_SYNC_SECRET_HERE

# API URL
API_URL=http://localhost:4000
MATH_API_URL=http://localhost:5000

# Sentry configuration
SENTRY_DISABLED=true
SENTRY_AUTH_TOKEN=YOUR_SENTRY_AUTH_TOKEN_HERE
</file>

<file path="packages/web/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {}

// Enable Sentry unless explicitly disabled
const isSentryEnabled = !process.env.SENTRY_DISABLED;

// Default config without Sentry
let config = nextConfig;

// Add Sentry if enabled
if (isSentryEnabled) {
  const { withSentryConfig } = require("@sentry/nextjs");
  config = withSentryConfig(
    nextConfig,
    {
      org: "vanden-it",
      project: "javascript-nextjs",
      silent: !process.env.CI,
      widenClientFileUpload: true,
      reactComponentAnnotation: {
        enabled: true,
      },
      tunnelRoute: "/monitoring",
      hideSourceMaps: true,
      disableLogger: true,
      automaticVercelMonitors: true,
    }
  );
}

module.exports = config;
</file>

<file path="packages/web/vitest.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './app'),
    },
  },
})
</file>

<file path="docs/new features/category-simulations.md">
# simulation improvements
The simulations can be entered from the /predictions web view

# 1. Get rid of hardcoded json files. 
- Store simulations in new mongodb collection connected to the active budget

# 2. category simulations
- support possibility to simulate a category and have the ability to specify a time range. Eg: in April I want to simulate a target amount of 200eur for category restaurants

# main requirements
- easy UX. easy to activate/deactivate compare categories

# Implementation Design (Quick MVP)

## Data Model v1

```typescript
// MongoDB Schema
interface Simulation {
  _id: ObjectId;           
  budgetId: ObjectId;      
  name: string;
  isActive: boolean;
  categoryChanges: {
    categoryId: ObjectId;    
    startDate: Date;
    endDate: Date;
    targetAmount: number;
  }[];
}
```

## API Endpoints v1

```typescript
// SimulationController endpoints
GET    /api/simulations?budgetId=xxx    // List all simulations for budget
POST   /api/simulations                 // Create new simulation
PUT    /api/simulations/:id/active      // Toggle simulation active state

// Request/Response examples:
interface CreateSimulationRequest {
  budgetId: string;
  name: string;
  categoryChanges: {
    categoryId: string;
    startDate: string;     // ISO date string
    endDate: string;       // ISO date string
    targetAmount: number;
  }[];
}

interface SimulationResponse {
  id: string;
  name: string;
  isActive: boolean;
  categoryChanges: {
    categoryId: string;
    startDate: string;
    endDate: string;
    targetAmount: number;
  }[];
}
```

## UI Mockup v1

```
+------------------------------------------------------------------+
|                      Balance Prediction                            |
+------------------------------------------------------------------+
| [+ New Simulation]                                                |
+------------------------------------------------------------------+
|                                                                    |
| SIMULATIONS                  [Interactive Line Chart]              |
|  Current Balance           (Existing chart)                      |
|  Less Restaurants                                               |
|                                                                    |
| [+ Category Change]                                               |
| Category: [Restaurants ]                                         |
| Target Amount: [200] EUR                                          |
| Period: [Apr 2024 ] to [Jun 2024 ]                            |
+------------------------------------------------------------------+
```

## Quick Implementation Steps

1. **Backend (Today)**
   - Create basic MongoDB collection
   - Add simple CRUD endpoints
   - Basic validation

2. **Math API (Today)**
   - Add MongoDB connection
   - Modify prediction to include category target amounts
   - Simple test case

3. **Frontend (Today)**
   - Add simulation toggle to existing chart
   - Simple form to create category simulation
   - Show impact on chart

## Test Plan v1
1. Create a simulation with reduced restaurant expenses
2. Verify it appears in predictions chart
3. Toggle simulation on/off
4. Verify amounts are correctly adjusted


## Extended Data Model

```typescript
// MongoDB Schema
interface Simulation {
  _id: ObjectId;           // Internal MongoDB id
  publicId: string;        // UUID v4 for API exposure
  budgetId: ObjectId;      // Internal reference
  budgetPublicId: string;  // Public budget identifier
  name: string;
  description?: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  transactions: TransactionSimulation[];
  categoryChanges: CategorySimulation[];
}

interface TransactionSimulation {
  _id: ObjectId;
  publicId: string;
  date: Date;
  amount: number;
  description: string;
  categoryId?: ObjectId;
  categoryPublicId?: string;
  recurringType?: 'once' | 'monthly' | 'yearly';
  recurringEndDate?: Date;
}

interface CategorySimulation {
  _id: ObjectId;
  publicId: string;
  categoryId: ObjectId;
  categoryPublicId: string;
  startDate: Date;
  endDate: Date;
  targetAmount: number;
  recurringType?: 'once' | 'monthly' | 'yearly';
}
```
</file>

<file path="kube/dev/mathapi-deployment.yml.template">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: budget-mathapi-app
  namespace: dev
spec:
  replicas: 1
  selector:
    matchLabels:
      app: budget-mathapi
  template:
    metadata:
      labels:
        app: budget-mathapi
    spec:
      containers:
        - name: budget-mathapi
          image: filipvdb321/budget-mathapi:${IMAGE_TAG}
          ports:
            - containerPort: 5000
          envFrom:
            - configMapRef:
                name: budget-mathapi-dev-config
            - secretRef:
                name: mathapi-secrets
          readinessProbe:
            httpGet:
              path: /health
              port: 5000
            initialDelaySeconds: 10
            periodSeconds: 5
          livenessProbe:
            httpGet:
              path: /health
              port: 5000
            initialDelaySeconds: 15
            periodSeconds: 20
</file>

<file path="packages/api/src/controllers/aiSuggestionsController.test.ts">
import { describe, it, vi, expect, beforeEach, afterEach } from "vitest";
import { getUncategorizedTransactionsForBudget, getUnapprovedTransactionsForBudget } from "./aiSuggestionsController";
import { Response } from "express";

const createMockResponse = () => {
  const res: Partial<Response> = {};
  res.json = vi.fn().mockReturnValue(res);
  res.status = vi.fn().mockReturnValue(res);
  return res as Response;
};

const mocks = vi.hoisted(() => {
  return {
    getUserFromReq: vi.fn(),
    getBudget: vi.fn(),
    getYnabUncategorizedTransactions: vi.fn(),
    getYnabUnapprovedTransactions: vi.fn(),
    getCachedAISuggestionsBatch: vi.fn(),
    extractPayeeName: vi.fn(),
  };
});

vi.mock("./utils", () => ({
  getUserFromReq: mocks.getUserFromReq,
}));

vi.mock("../data/budget/budget.server", () => ({
  getBudget: mocks.getBudget,
}));

vi.mock("../data/ynab/ynab-api", () => ({
  getUncategorizedTransactions: mocks.getYnabUncategorizedTransactions,
  getUnapprovedTransactions: mocks.getYnabUnapprovedTransactions,
}));

vi.mock("../data/transaction/transaction.server", () => ({
  getCachedAISuggestionsBatch: mocks.getCachedAISuggestionsBatch,
}));

vi.mock("../data/transaction/utils", () => ({
  extractPayeeName: mocks.extractPayeeName,
}));

const mockUser = {
  _id: "user123",
  authId: "auth123",
  name: "Test User",
};

const mockBudget = {
  _id: "budget123",
  uuid: "budget-uuid-123",
  name: "Test Budget",
};

const mockYnabTransactions = [
  {
    id: "tx1",
    payee_name: "PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL 4YV22252VFQC6 1043588586390 PAYPAL",
    amount: -2500,
    date: "2024-01-15",
    memo: "Online purchase",
    category_name: null,
    category_id: null,
    approved: false,
  },
  {
    id: "tx2", 
    payee_name: "PARKING ALBERTINE 1112 BE1000 BRUXELLES Betaling met KBC-Debetkaart",
    amount: -350,
    date: "2024-01-14",
    memo: "Parking fee",
    category_name: "Transport",
    category_id: "cat123",
    approved: true,
  }
];

describe("aiSuggestionsController", () => {
  let res: Response;

  beforeEach(() => {
    res = createMockResponse();
    vi.clearAllMocks();
    
    // Setup default mocks
    mocks.getUserFromReq.mockResolvedValue(mockUser);
    mocks.getBudget.mockResolvedValue(mockBudget);
    mocks.extractPayeeName.mockImplementation((payeeName: string) => {
      // Mock the extractPayeeName logic
      if (payeeName?.includes("PayPal")) return "PayPal";
      if (payeeName?.includes("PARKING ALBERTINE")) return "PARKING ALBERTINE";
      return payeeName || "";
    });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe("getUncategorizedTransactionsForBudget", () => {
    it("should return uncategorized transactions with clean payee names", async () => {
      // Arrange
      const req: any = {
        params: { uuid: "budget-uuid-123" }
      };
      
      mocks.getYnabUncategorizedTransactions.mockResolvedValue(mockYnabTransactions);
      mocks.getCachedAISuggestionsBatch.mockResolvedValue({
        "tx1": "Shopping",
        // tx2 has no cached suggestion
      });

      // Act
      await getUncategorizedTransactionsForBudget(req, res);

      // Assert
      expect(res.json).toHaveBeenCalledWith([
        {
          transaction_id: "tx1",
          payee_name: "PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL 4YV22252VFQC6 1043588586390 PAYPAL",
          clean_payee_name: "PayPal",
          amount: -2500,
          date: "2024-01-15",
          memo: "Online purchase",
          category_name: null,
          category_id: null,
          approved: false,
          ai_suggested_category: "Shopping",
        },
        {
          transaction_id: "tx2",
          payee_name: "PARKING ALBERTINE 1112 BE1000 BRUXELLES Betaling met KBC-Debetkaart",
          clean_payee_name: "PARKING ALBERTINE",
          amount: -350,
          date: "2024-01-14",
          memo: "Parking fee",
          category_name: null,
          category_id: null,
          approved: true,
          ai_suggested_category: null,
        }
      ]);
    });

    it("should handle empty payee names gracefully", async () => {
      // Arrange
      const req: any = {
        params: { uuid: "budget-uuid-123" }
      };
      
      const transactionsWithEmptyPayee = [
        {
          id: "tx3",
          payee_name: null,
          amount: -1000,
          date: "2024-01-13",
          memo: "Unknown transaction",
          category_name: null,
          category_id: null,
          approved: false,
        }
      ];
      
      mocks.getYnabUncategorizedTransactions.mockResolvedValue(transactionsWithEmptyPayee);
      mocks.getCachedAISuggestionsBatch.mockResolvedValue({});

      // Act
      await getUncategorizedTransactionsForBudget(req, res);

      // Assert
      expect(res.json).toHaveBeenCalledWith([
        {
          transaction_id: "tx3",
          payee_name: "",
          clean_payee_name: "",
          amount: -1000,
          date: "2024-01-13",
          memo: "Unknown transaction",
          category_name: null,
          category_id: null,
          approved: false,
          ai_suggested_category: null,
        }
      ]);
    });

    it("should return 401 when user is not authenticated", async () => {
      // Arrange
      const req: any = {
        params: { uuid: "budget-uuid-123" }
      };
      
      mocks.getUserFromReq.mockResolvedValue(null);

      // Act
      await getUncategorizedTransactionsForBudget(req, res);

      // Assert
      expect(res.status).toHaveBeenCalledWith(401);
      expect(res.json).toHaveBeenCalledWith({ error: "Unauthorized" });
    });

    it("should return 404 when budget is not found", async () => {
      // Arrange
      const req: any = {
        params: { uuid: "nonexistent-budget" }
      };
      
      mocks.getBudget.mockResolvedValue(null);

      // Act
      await getUncategorizedTransactionsForBudget(req, res);

      // Assert
      expect(res.status).toHaveBeenCalledWith(404);
      expect(res.json).toHaveBeenCalledWith({ error: "Budget not found or access denied" });
    });

    it("should include memo field in uncategorized transactions response", async () => {
      // Arrange
      const req: any = {
        params: { uuid: "budget-uuid-123" }
      };

      const transactionsWithMemo = [
        {
          id: "tx1",
          payee_name: "Test Payee",
          amount: -1000,
          date: "2024-01-15",
          memo: "Purchase at store",
          category_name: null,
          category_id: null,
          approved: false,
        }
      ];

      mocks.getYnabUncategorizedTransactions.mockResolvedValue(transactionsWithMemo);
      mocks.getCachedAISuggestionsBatch.mockResolvedValue({});

      // Act
      await getUncategorizedTransactionsForBudget(req, res);

      // Assert
      expect(res.json).toHaveBeenCalledWith([
        expect.objectContaining({
          memo: "Purchase at store"
        })
      ]);
    });
  });

  describe("getUnapprovedTransactionsForBudget", () => {
    it("should return unapproved transactions with clean payee names", async () => {
      // Arrange
      const req: any = {
        params: { uuid: "budget-uuid-123" }
      };
      
      mocks.getYnabUnapprovedTransactions.mockResolvedValue(mockYnabTransactions);

      // Act
      await getUnapprovedTransactionsForBudget(req, res);

      // Assert
      expect(res.json).toHaveBeenCalledWith([
        {
          transaction_id: "tx1",
          payee_name: "PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL 4YV22252VFQC6 1043588586390 PAYPAL",
          clean_payee_name: "PayPal",
          amount: -2500,
          date: "2024-01-15",
          memo: "Online purchase",
          category_name: null,
          category_id: null,
          approved: false,
        },
        {
          transaction_id: "tx2",
          payee_name: "PARKING ALBERTINE 1112 BE1000 BRUXELLES Betaling met KBC-Debetkaart",
          clean_payee_name: "PARKING ALBERTINE",
          amount: -350,
          date: "2024-01-14",
          memo: "Parking fee",
          category_name: "Transport",
          category_id: "cat123",
          approved: true,
        }
      ]);
    });

    it("should call extractPayeeName for each transaction", async () => {
      // Arrange
      const req: any = {
        params: { uuid: "budget-uuid-123" }
      };
      
      mocks.getYnabUnapprovedTransactions.mockResolvedValue(mockYnabTransactions);

      // Act
      await getUnapprovedTransactionsForBudget(req, res);

      // Assert
      expect(mocks.extractPayeeName).toHaveBeenCalledTimes(2);
      expect(mocks.extractPayeeName).toHaveBeenCalledWith("PayPal (Europe) S.a r.l. et Cie, S. Domiciliring 1043588586390 PAYPAL 4YV22252VFQC6 1043588586390 PAYPAL");
      expect(mocks.extractPayeeName).toHaveBeenCalledWith("PARKING ALBERTINE 1112 BE1000 BRUXELLES Betaling met KBC-Debetkaart");
    });

    it("should include memo field in response", async () => {
      // Arrange
      const req: any = {
        params: { uuid: "budget-uuid-123" }
      };

      const transactionsWithMemo = [
        {
          id: "tx1",
          payee_name: "Test Payee",
          amount: -1000,
          date: "2024-01-15",
          memo: "Test memo content",
          category_name: null,
          category_id: null,
          approved: false,
        }
      ];

      mocks.getYnabUnapprovedTransactions.mockResolvedValue(transactionsWithMemo);

      // Act
      await getUnapprovedTransactionsForBudget(req, res);

      // Assert
      expect(res.json).toHaveBeenCalledWith([
        expect.objectContaining({
          memo: "Test memo content"
        })
      ]);
    });
  });
});
</file>

<file path="packages/api/src/controllers/aiSuggestionsController.ts">
import { Request, Response } from "express";
import { getUserFromReq } from "./utils";
import { getBudget } from "../data/budget/budget.server";
import {
  getCachedAISuggestionsBatch,
  getAllCachedAISuggestionsForBudget,
  storeAISuggestion,
  getCachedAISuggestion,
} from "../data/transaction/transaction.server";
import {
  getUncategorizedTransactions as getYnabUncategorizedTransactions,
  getUnapprovedTransactions as getYnabUnapprovedTransactions,
  getCategories,
  updateTransaction,
  updateTransactions,
} from "../data/ynab/ynab-api";
import { openAIService } from "../services/openai.service";
import { createPayeeMappingsService } from "../services/payeeMappings.service";
import { extractPayeeName } from "../data/transaction/utils";

/**
 * Get uncategorized transactions for a budget via YNAB API
 * Migrated from Python mathapi: GET /uncategorised-transactions
 */
export const getUncategorizedTransactionsForBudget = async (
  req: Request,
  res: Response
) => {
  try {
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    // Use YNAB API to get uncategorized transactions (like Python implementation)
    const transactions = await getYnabUncategorizedTransactions(
      budgetUuid,
      user
    );

    // Get cached AI suggestions for these transactions (like Python implementation)
    const transactionIds = transactions.map((tx) => tx.id);
    const cachedSuggestions = await getCachedAISuggestionsBatch(
      budget._id.toString(),
      transactionIds
    );

    // Transform to match Python API format with cached suggestions
    const formattedTransactions = transactions.map((transaction) => ({
      transaction_id: transaction.id,
      payee_name: transaction.payee_name || "",
      clean_payee_name: extractPayeeName(transaction.payee_name),
      amount: transaction.amount,
      date: transaction.date,
      memo: transaction.memo || "",
      category_name: null,
      category_id: null,
      approved: transaction.approved || false,
      ai_suggested_category: cachedSuggestions[transaction.id] || null,
    }));

    console.log(
      `Returned ${formattedTransactions.length} uncategorized transactions for budget ${budgetUuid}`
    );
    res.json(formattedTransactions);
  } catch (error) {
    console.error("Error fetching uncategorized transactions:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

/**
 * Get unapproved transactions for a budget via YNAB API
 * Migrated from Python mathapi: GET /unapproved-transactions
 */
export const getUnapprovedTransactionsForBudget = async (
  req: Request,
  res: Response
) => {
  try {
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    // Use YNAB API to get unapproved transactions (like Python implementation)
    const transactions = await getYnabUnapprovedTransactions(budgetUuid, user);

    // Transform to match Python API format
    const formattedTransactions = transactions.map((transaction) => ({
      transaction_id: transaction.id,
      payee_name: transaction.payee_name || "",
      clean_payee_name: extractPayeeName(transaction.payee_name),
      amount: transaction.amount,
      date: transaction.date,
      memo: transaction.memo || "",
      category_name: transaction.category_name || null,
      category_id: transaction.category_id || null,
      approved: transaction.approved || false,
    }));

    console.log(
      `Returned ${formattedTransactions.length} unapproved transactions for budget ${budgetUuid}`
    );
    res.json(formattedTransactions);
  } catch (error) {
    console.error("Error fetching unapproved transactions:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

/**
 * Get cached AI suggestions for a budget
 * Migrated from Python mathapi: GET /uncategorised-transactions/suggestions-cached
 */
export const getCachedSuggestionsForBudget = async (
  req: Request,
  res: Response
) => {
  try {
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    const suggestions = await getAllCachedAISuggestionsForBudget(
      budget._id.toString()
    );

    console.log(
      `Returned ${suggestions.length} cached suggestions for budget ${budgetUuid}`
    );
    res.json(suggestions);
  } catch (error) {
    console.error("Error fetching cached suggestions:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

/**
 * Get AI suggestion for a single transaction (real-time)
 * Migrated from Python mathapi: POST /uncategorised-transactions/suggest-single
 */
export const suggestSingleTransaction = async (req: Request, res: Response) => {
  try {
    console.log(
      ` suggestSingleTransaction called for budget ${req.params.uuid}`
    );
    console.log(` Request body:`, JSON.stringify(req.body, null, 2));

    const user = await getUserFromReq(req);
    if (!user) {
      console.log(" Unauthorized - no user found");
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      console.log(` Budget ${budgetUuid} not found or access denied`);
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    const { transaction_id, transaction } = req.body;
    console.log(
      ` Extracted from body: transaction_id=${transaction_id}, transaction=${
        transaction ? "provided" : "not provided"
      }`
    );
    console.log(` Full req.body keys:`, Object.keys(req.body || {}));

    if (!transaction_id) {
      console.log(" transaction_id is required but not provided");
      return res.status(400).json({ error: "transaction_id is required" });
    }

    const transactionId = transaction_id;
    const startTime = Date.now();

    // Check cache first
    const cachedSuggestion = await getCachedAISuggestion(
      budget._id.toString(),
      transactionId
    );

    if (cachedSuggestion) {
      return res.json({
        transaction_id: transactionId,
        suggested_category_name: cachedSuggestion,
        confidence: 0.8,
        cached: true,
        processing_time_ms: 0,
      });
    }

    // Check if OpenAI is available
    if (!openAIService.isAvailable()) {
      return res.status(503).json({
        error: "AI service not available - API key missing",
      });
    }

    // Get transaction data if not provided
    let transactionData = transaction;
    if (!transactionData) {
      // Get uncategorized transactions to find the specific transaction
      const uncategorizedTransactions = await getYnabUncategorizedTransactions(
        budgetUuid,
        user
      );

      const foundTransaction = uncategorizedTransactions.find(
        (tx) => tx.id === transactionId
      );
      if (!foundTransaction) {
        return res.status(404).json({ error: "Transaction not found" });
      }

      transactionData = {
        id: foundTransaction.id,
        payee_name: foundTransaction.payee_name || "",
        amount: foundTransaction.amount,
        date: foundTransaction.date,
        memo: foundTransaction.memo || "",
      };
    }

    // Get categories for this budget
    const categoriesData = await getCategories(budgetUuid, 0, user);
    const categories = categoriesData.categories;

    // Get payee mappings context
    const payeeMappingsService = createPayeeMappingsService(
      budget._id.toString()
    );
    const mappingsContext = await payeeMappingsService.getMappingsForPrompt();

    // Generate new suggestion using OpenAI
    const suggestedCategory = await openAIService.suggestCategory(
      transactionData,
      categories,
      mappingsContext
    );

    const processingTime = Date.now() - startTime;

    // Cache the new suggestion
    try {
      await storeAISuggestion(
        budget._id.toString(),
        transactionId,
        transactionData.payee_name || "",
        suggestedCategory,
        0.8
      );
    } catch (error) {
      console.warn(`Failed to cache suggestion for ${transactionId}:`, error);
    }

    res.json({
      transaction_id: transactionId,
      suggested_category_name: suggestedCategory,
      confidence: 0.8,
      cached: false,
      processing_time_ms: processingTime,
    });
  } catch (error) {
    console.error(" Error getting single suggestion:", error);
    console.error(
      " Error stack:",
      error instanceof Error ? error.stack : "No stack trace"
    );
    console.error(" Request details:", {
      budgetUuid: req.params.uuid,
      body: req.body,
      headers: req.headers,
    });
    res.status(500).json({
      error: "Internal server error",
      details: error instanceof Error ? error.message : "Unknown error",
    });
  }
};

/**
 * Get AI suggestions for multiple transactions asynchronously
 * Migrated from Python mathapi: POST /uncategorised-transactions/suggestions-async
 */
export const getSuggestionsAsync = async (req: Request, res: Response) => {
  try {
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    const { transaction_ids } = req.body;
    if (!transaction_ids || !Array.isArray(transaction_ids)) {
      return res.status(400).json({
        error: "transaction_ids required in request body",
      });
    }

    console.log(
      `Processing ${transaction_ids.length} transaction IDs for async suggestions`
    );

    // Check if OpenAI is available
    if (!openAIService.isAvailable()) {
      return res.status(503).json({
        error: "AI service not available - API key missing",
      });
    }

    // Get uncategorized transactions from YNAB
    const uncategorizedTransactions = await getYnabUncategorizedTransactions(
      budgetUuid,
      user
    );

    // Filter to only requested transactions
    const requestedTransactions = uncategorizedTransactions.filter((tx) =>
      transaction_ids.includes(tx.id)
    );

    if (requestedTransactions.length === 0) {
      return res.json({
        message: "No matching transactions found",
        processed: 0,
        cached: 0,
      });
    }

    // Get categories for this budget
    const categoriesData = await getCategories(budgetUuid, 0, user);
    const categories = categoriesData.categories;

    // Get payee mappings context
    const payeeMappingsService = createPayeeMappingsService(
      budget._id.toString()
    );
    const mappingsContext = await payeeMappingsService.getMappingsForPrompt();

    let processedCount = 0;
    let cachedCount = 0;

    // Process transactions in parallel (but limit concurrency)
    const batchSize = 5; // Process 5 at a time to avoid rate limits
    for (let i = 0; i < requestedTransactions.length; i += batchSize) {
      const batch = requestedTransactions.slice(i, i + batchSize);

      const promises = batch.map(async (transaction) => {
        try {
          // Check cache first
          const cachedSuggestion = await getCachedAISuggestion(
            budget._id.toString(),
            transaction.id
          );

          if (cachedSuggestion) {
            cachedCount++;
            return;
          }

          // Generate new suggestion
          const suggestedCategory = await openAIService.suggestCategory(
            {
              payee_name: transaction.payee_name || "",
              amount: transaction.amount,
              date: transaction.date,
            },
            categories,
            mappingsContext
          );

          // Store the suggestion
          await storeAISuggestion(
            budget._id.toString(),
            transaction.id,
            transaction.payee_name || "",
            suggestedCategory,
            0.8
          );

          processedCount++;
        } catch (error) {
          console.error(
            `Error processing transaction ${transaction.id}:`,
            error
          );
        }
      });

      await Promise.all(promises);
    }

    res.json({
      message: `Processed ${processedCount} transactions, ${cachedCount} from cache`,
      processed: processedCount,
      cached: cachedCount,
      total_requested: transaction_ids.length,
    });
  } catch (error) {
    console.error("Error getting async suggestions:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

/**
 * Apply category for a single transaction
 * Migrated from Python mathapi: POST /uncategorised-transactions/apply-single
 */
export const applySingleCategory = async (req: Request, res: Response) => {
  try {
    console.log(
      ` applySingleCategory - req.body keys:`,
      Object.keys(req.body || {})
    );

    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    const { transaction_id, category_name, is_manual_change } = req.body;
    if (!transaction_id || !category_name) {
      return res.status(400).json({
        error: "transaction_id and category_name are required",
      });
    }

    // Get categories to find the category ID
    const categoriesData = await getCategories(budgetUuid, 0, user);
    const category = categoriesData.categories.find(
      (cat) => cat.name === category_name
    );

    if (!category) {
      return res.status(400).json({
        error: `Category '${category_name}' not found`,
      });
    }

    // Update transaction in YNAB
    const updatedTransaction = await updateTransaction(
      budgetUuid,
      transaction_id,
      {
        category_id: category.id,
      },
      user
    );

    // Learn from manual changes (if specified)
    if (is_manual_change) {
      try {
        const payeeMappingsService = createPayeeMappingsService(
          budget._id.toString()
        );
        await payeeMappingsService.learnFromTransaction(
          updatedTransaction.payee_name || "",
          category_name,
          1.0 // High confidence for manual changes
        );
        console.log(
          `Learned from manual change: ${updatedTransaction.payee_name} -> ${category_name}`
        );
      } catch (error) {
        console.warn("Failed to learn from manual change:", error);
      }
    }

    res.json({
      message: "Transaction updated successfully",
      transaction_id: transaction_id,
      category_name: category_name,
      updated_transaction: {
        id: updatedTransaction.id,
        category_id: updatedTransaction.category_id,
        category_name: updatedTransaction.category_name,
        payee_name: updatedTransaction.payee_name,
      },
    });
  } catch (error) {
    console.error("Error applying single category:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

/**
 * Approve a single transaction
 * Migrated from Python mathapi: POST /transactions/approve-single
 */
export const approveSingleTransaction = async (req: Request, res: Response) => {
  try {
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    const { transaction_id } = req.body;
    if (!transaction_id) {
      return res.status(400).json({
        error: "transaction_id is required",
      });
    }

    // Update transaction to approved in YNAB
    const updatedTransaction = await updateTransaction(
      budgetUuid,
      transaction_id,
      {
        approved: true,
      },
      user
    );

    res.json({
      message: "Transaction approved successfully",
      transaction_id: transaction_id,
      updated_transaction: {
        id: updatedTransaction.id,
        approved: updatedTransaction.approved,
        payee_name: updatedTransaction.payee_name,
      },
    });
  } catch (error) {
    console.error("Error approving single transaction:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

/**
 * Approve all unapproved transactions
 * Migrated from Python mathapi: POST /transactions/approve-all
 */
export const approveAllTransactions = async (req: Request, res: Response) => {
  try {
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    // Get all unapproved transactions
    const unapprovedTransactions = await getYnabUnapprovedTransactions(
      budgetUuid,
      user
    );

    if (unapprovedTransactions.length === 0) {
      return res.json({
        message: "No unapproved transactions found",
        approved_count: 0,
      });
    }

    // Prepare transactions for bulk update
    const transactionsToUpdate = unapprovedTransactions.map((tx) => ({
      id: tx.id,
      approved: true,
    }));

    // Update all transactions in YNAB
    const updatedTransactions = await updateTransactions(
      budgetUuid,
      transactionsToUpdate,
      user
    );

    res.json({
      message: `Approved ${updatedTransactions.length} transactions successfully`,
      approved_count: updatedTransactions.length,
      updated_transactions: updatedTransactions.map((tx) => ({
        id: tx.id,
        approved: tx.approved,
        payee_name: tx.payee_name,
      })),
    });
  } catch (error) {
    console.error("Error approving all transactions:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

/**
 * Apply categories for multiple transactions
 * Migrated from Python mathapi: POST /uncategorised-transactions/apply-categories
 */
export const applyCategories = async (req: Request, res: Response) => {
  try {
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    const { transactions } = req.body;
    if (!transactions || !Array.isArray(transactions)) {
      return res.status(400).json({
        error: "transactions array is required",
      });
    }

    // Get categories to validate category names
    const categoriesData = await getCategories(budgetUuid, 0, user);
    const categories = categoriesData.categories;

    // Prepare transactions for bulk update
    const transactionsToUpdate = [];
    const payeeMappingsService = createPayeeMappingsService(
      budget._id.toString()
    );

    for (const transaction of transactions) {
      const { transaction_id, category_name, is_manual_change } = transaction;

      if (!transaction_id || !category_name) {
        continue; // Skip invalid transactions
      }

      // Find category ID
      const category = categories.find((cat) => cat.name === category_name);
      if (!category) {
        console.warn(
          `Category '${category_name}' not found for transaction ${transaction_id}`
        );
        continue;
      }

      transactionsToUpdate.push({
        id: transaction_id,
        category_id: category.id,
      });

      // Learn from manual changes
      if (is_manual_change) {
        try {
          await payeeMappingsService.learnFromTransaction(
            transaction.payee_name || "",
            category_name,
            1.0
          );
        } catch (error) {
          console.warn(
            `Failed to learn from transaction ${transaction_id}:`,
            error
          );
        }
      }
    }

    if (transactionsToUpdate.length === 0) {
      return res.json({
        message: "No valid transactions to update",
        updated_count: 0,
      });
    }

    // Update all transactions in YNAB
    const updatedTransactions = await updateTransactions(
      budgetUuid,
      transactionsToUpdate,
      user
    );

    res.json({
      message: `Updated ${updatedTransactions.length} transactions successfully`,
      updated_count: updatedTransactions.length,
      updated_transactions: updatedTransactions.map((tx) => ({
        id: tx.id,
        category_id: tx.category_id,
        category_name: tx.category_name,
        payee_name: tx.payee_name,
      })),
    });
  } catch (error) {
    console.error("Error applying categories:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

/**
 * Apply all categories for uncategorized transactions
 * Migrated from Python mathapi: POST /uncategorised-transactions/apply-all-categories
 */
export const applyAllCategories = async (req: Request, res: Response) => {
  try {
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    // Get uncategorized transactions
    const uncategorizedTransactions = await getYnabUncategorizedTransactions(
      budgetUuid,
      user
    );

    if (uncategorizedTransactions.length === 0) {
      return res.json({
        message: "No uncategorized transactions found",
        updated_count: 0,
      });
    }

    // Get cached AI suggestions for all transactions
    const transactionIds = uncategorizedTransactions.map((tx) => tx.id);
    const cachedSuggestions = await getCachedAISuggestionsBatch(
      budget._id.toString(),
      transactionIds
    );

    // Get categories
    const categoriesData = await getCategories(budgetUuid, 0, user);
    const categories = categoriesData.categories;

    // Prepare transactions for bulk update
    const transactionsToUpdate = [];
    const payeeMappingsService = createPayeeMappingsService(
      budget._id.toString()
    );

    for (const transaction of uncategorizedTransactions) {
      // Check if we have a cached suggestion
      const suggestedCategoryName = cachedSuggestions[transaction.id];

      if (!suggestedCategoryName) {
        continue; // Skip transactions without suggestions
      }

      // Find category ID
      const category = categories.find(
        (cat) => cat.name === suggestedCategoryName
      );
      if (!category) {
        console.warn(
          `Category '${suggestedCategoryName}' not found for transaction ${transaction.id}`
        );
        continue;
      }

      transactionsToUpdate.push({
        id: transaction.id,
        category_id: category.id,
      });

      // Learn from AI suggestions (lower confidence)
      try {
        await payeeMappingsService.learnFromTransaction(
          transaction.payee_name || "",
          suggestedCategoryName,
          0.8 // Lower confidence for AI suggestions
        );
      } catch (error) {
        console.warn(
          `Failed to learn from transaction ${transaction.id}:`,
          error
        );
      }
    }

    if (transactionsToUpdate.length === 0) {
      return res.json({
        message: "No transactions with cached suggestions found",
        updated_count: 0,
      });
    }

    // Update all transactions in YNAB
    const updatedTransactions = await updateTransactions(
      budgetUuid,
      transactionsToUpdate,
      user
    );

    res.json({
      message: `Applied categories to ${updatedTransactions.length} transactions successfully`,
      updated_count: updatedTransactions.length,
      updated_transactions: updatedTransactions.map((tx) => ({
        id: tx.id,
        category_id: tx.category_id,
        category_name: tx.category_name,
        payee_name: tx.payee_name,
      })),
    });
  } catch (error) {
    console.error("Error applying all categories:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

/**
 * Suggest categories for all uncategorized transactions
 * Migrated from Python mathapi: GET /uncategorised-transactions/suggest-categories
 */
export const suggestCategoriesForUncategorized = async (
  req: Request,
  res: Response
) => {
  try {
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const budgetUuid = req.params.uuid;
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res
        .status(404)
        .json({ error: "Budget not found or access denied" });
    }

    // Get uncategorized transactions from YNAB
    const uncategorizedTransactions = await getYnabUncategorizedTransactions(
      budgetUuid,
      user
    );

    if (uncategorizedTransactions.length === 0) {
      return res.json([]); // No uncategorized transactions found
    }

    // Get cached AI suggestions for these transactions
    const transactionIds = uncategorizedTransactions.map((tx) => tx.id);
    const cachedSuggestions = await getCachedAISuggestionsBatch(
      budget._id.toString(),
      transactionIds
    );

    // Get categories for AI suggestions
    const categoriesData = await getCategories(budgetUuid, 0, user);
    const categories = categoriesData.categories;

    // Prepare results and track new suggestions needed
    const suggestedTransactions = [];
    const transactionsNeedingSuggestions = [];
    const payeeMappingsService = createPayeeMappingsService(
      budget._id.toString()
    );

    for (const transaction of uncategorizedTransactions) {
      const transactionId = transaction.id;

      // Check if we have a cached suggestion
      const cachedSuggestion = cachedSuggestions[transactionId];

      if (cachedSuggestion) {
        // Use cached suggestion
        suggestedTransactions.push({
          transaction_id: transactionId,
          payee_name: transaction.payee_name || "",
          amount: transaction.amount,
          date: transaction.date,
          memo: transaction.memo || "",
          suggested_category_name: cachedSuggestion,
          cached: true,
        });
      } else {
        // Check payee mappings first (fast and free!)
        let suggestedCategory = null;
        try {
          suggestedCategory = await payeeMappingsService.getSuggestionForPayee(
            transaction.payee_name || ""
          );
          if (suggestedCategory) {
            console.log(
              ` Pre-mapped: '${transaction.payee_name}'  '${suggestedCategory}'`
            );
          }
        } catch (error) {
          console.warn(
            `Failed to check payee mapping for ${transactionId}:`,
            error
          );
        }

        if (suggestedCategory) {
          // Use payee mapping
          suggestedTransactions.push({
            transaction_id: transactionId,
            payee_name: transaction.payee_name || "",
            amount: transaction.amount,
            date: transaction.date,
            memo: transaction.memo || "",
            suggested_category_name: suggestedCategory,
            cached: false,
          });

          // Cache this suggestion for future use
          try {
            await storeAISuggestion(
              budget._id.toString(),
              transactionId,
              transaction.payee_name || "",
              suggestedCategory,
              0.9 // High confidence for payee mappings
            );
          } catch (error) {
            console.warn(
              `Failed to cache payee mapping suggestion for ${transactionId}:`,
              error
            );
          }
        } else {
          // Need AI suggestion
          transactionsNeedingSuggestions.push(transaction);
        }
      }
    }

    // Generate AI suggestions for remaining transactions
    const newSuggestions = [];
    for (const transaction of transactionsNeedingSuggestions) {
      try {
        console.log(`Generating AI suggestion for: ${transaction.payee_name}`);

        // Get mappings context for AI prompt
        const mappingsContext =
          await payeeMappingsService.getMappingsForPrompt();

        const suggestedCategory = await openAIService.suggestCategory(
          {
            payee_name: transaction.payee_name || "",
            amount: transaction.amount,
            date: transaction.date,
          },
          categories,
          mappingsContext
        );

        suggestedTransactions.push({
          transaction_id: transaction.id,
          payee_name: transaction.payee_name || "",
          amount: transaction.amount,
          date: transaction.date,
          memo: transaction.memo || "",
          suggested_category_name: suggestedCategory,
          cached: false,
        });

        // Cache the new suggestion
        newSuggestions.push({
          transactionId: transaction.id,
          payeeName: transaction.payee_name || "",
          suggestedCategory: suggestedCategory,
          confidence: 0.8,
        });
      } catch (error) {
        console.error(
          `Failed to generate suggestion for transaction ${transaction.id}:`,
          error
        );

        // Add error entry
        suggestedTransactions.push({
          transaction_id: transaction.id,
          payee_name: transaction.payee_name || "",
          amount: transaction.amount,
          date: transaction.date,
          memo: transaction.memo || "",
          suggested_category_name: "Error generating suggestion",
          cached: false,
        });
      }
    }

    // Batch cache new suggestions
    if (newSuggestions.length > 0) {
      try {
        let cachedCount = 0;
        for (const suggestion of newSuggestions) {
          const success = await storeAISuggestion(
            budget._id.toString(),
            suggestion.transactionId,
            suggestion.payeeName,
            suggestion.suggestedCategory,
            suggestion.confidence
          );
          if (success) cachedCount++;
        }
        console.log(`Cached ${cachedCount} new suggestions`);
      } catch (error) {
        console.warn("Failed to cache new suggestions:", error);
      }
    }

    const cachedCount = Object.keys(cachedSuggestions).length;
    console.log(
      `Returned ${suggestedTransactions.length} suggestions (${cachedCount} from cache, ${newSuggestions.length} new)`
    );

    res.json(suggestedTransactions);
  } catch (error) {
    console.error("Error suggesting categories:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};
</file>

<file path="packages/api/src/data/simulation/simulation.schema.ts">
import mongoose from "mongoose";
const { Schema } = mongoose;

export type SimulationType = {
    _id?: string;
    budgetId: mongoose.Schema.Types.ObjectId;
    name: string;
    isActive: boolean;
    categoryChanges: {
        categoryUuid: string;
        startDate?: Date;
        endDate?: Date;
        targetAmount: number;
    }[];
};

const categoryChangeSchema = new Schema({
    categoryUuid: { type: String, required: true },
    startDate: { type: Date, required: false },
    endDate: { type: Date, required: false },
    targetAmount: { type: Number, required: true }
});

const simulationSchema = new Schema({
    budgetId: { type: Schema.Types.ObjectId, required: true, ref: 'Budget' },
    name: { type: String, required: true },
    isActive: { type: Boolean, default: false },
    categoryChanges: [categoryChangeSchema]
}, {
    timestamps: true
});

export const Simulation = mongoose.models.Simulation || mongoose.model('Simulation', simulationSchema);
</file>

<file path="packages/api/src/data/simulation/simulation.server.test.ts">
import { describe, it, expect, vi, afterEach } from "vitest";
import { findSimulationsForBudget, createSimulation, toggleSimulation, updateSimulation } from "./simulation.server";
import { Simulation } from "./simulation.schema";
import { getBudget } from "../budget/budget.server";
import type { Budget } from "common-ts";
import type { UserType } from "../user/user.server";
import mongoose from "mongoose";

// Mock dependencies
vi.mock("../db", () => ({
    default: vi.fn().mockResolvedValue(undefined)
}));

vi.mock("../budget/budget.server", () => ({
    getBudget: vi.fn()
}));

// Mock the Simulation model
const mockFind = vi.fn();
const mockFindById = vi.fn();
const mockSave = vi.fn();

vi.mock("./simulation.schema", () => ({
    Simulation: function(data: any) {
        return {
            _id: "sim123",
            ...data,
            save: mockSave
        };
    }
}));

// Add static methods to the mocked Simulation
(Simulation as any).find = mockFind;
(Simulation as any).findById = mockFindById;

describe("simulation.server tests", () => {
    describe("findSimulationsForBudget", () => {
        it("should return simulations for the given budget", async () => {
            const mockSimulations = [
                { _id: "1", name: "Test Simulation 1" },
                { _id: "2", name: "Test Simulation 2" }
            ];

            // Mock Simulation.find
            mockFind.mockResolvedValue(mockSimulations);

            const result = await findSimulationsForBudget("budget123");

            expect(mockFind).toHaveBeenCalledWith({ budgetId: "budget123" });
            expect(result).toEqual(mockSimulations);
        });
    });

    describe("createSimulation", () => {
        it("should create a new simulation with the correct data", async () => {
            const mockBudget = {
                _id: "budget123",
                uuid: "budget-uuid-123",
                name: "Test Budget"
            } as Budget;

            const mockUser = {
                _id: "user123" as unknown as mongoose.Schema.Types.ObjectId,
                authId: "auth0|123",
                name: "Test User",
                createdAt: new Date(),
                updatedAt: new Date(),
                settings: {
                    preferredBudgetUuid: "budget-uuid-123"
                }
            } as UserType;

            const mockSimulation = {
                _id: "sim123",
                name: "Test Simulation",
                budgetId: "budget123",
                categoryChanges: [{
                    categoryUuid: "cat123",
                    targetAmount: 1000,
                    startDate: new Date("2024-01-01"),
                    endDate: new Date("2024-12-31")
                }]
            };

            // Mock getBudget
            vi.mocked(getBudget).mockResolvedValue(mockBudget);

            // Mock save method
            mockSave.mockResolvedValue(mockSimulation);

            const result = await createSimulation(
                mockBudget.uuid,
                mockUser,
                {
                    name: "Test Simulation",
                    categoryChanges: [
                        {
                            categoryUuid: "cat123",
                            startDate: new Date("2024-01-01"),
                            endDate: new Date("2024-12-31"),
                            targetAmount: 1000
                        }
                    ]
                }
            );

            expect(getBudget).toHaveBeenCalledWith(mockBudget.uuid, mockUser);
            expect(mockSave).toHaveBeenCalled();
            expect(result._id).toBe(mockSimulation._id);
            expect(result.name).toBe(mockSimulation.name);
            expect(result.budgetId).toBe(mockSimulation.budgetId);
            expect(result.categoryChanges).toEqual(mockSimulation.categoryChanges);
        });

        it("should throw error when budget is not found", async () => {
            const mockUser = {
                _id: "user123" as unknown as mongoose.Schema.Types.ObjectId,
                authId: "auth0|123",
                name: "Test User",
                createdAt: new Date(),
                updatedAt: new Date(),
                settings: {
                    preferredBudgetUuid: "budget-uuid-123"
                }
            } as UserType;

            // Mock getBudget to return null
            vi.mocked(getBudget).mockResolvedValue(null);

            await expect(createSimulation(
                "non-existent-uuid",
                mockUser,
                {
                    name: "Test Simulation",
                    categoryChanges: []
                }
            )).rejects.toThrow("Budget not found");
        });
    });

    describe("toggleSimulation", () => {
        it("should toggle the simulation active state", async () => {
            const mockSimulation = {
                _id: "sim123",
                name: "Test Simulation",
                isActive: false,
                save: vi.fn()
            };

            // Mock findById to return the simulation
            mockFindById.mockResolvedValue(mockSimulation);

            // Mock save to return the updated simulation
            mockSimulation.save.mockResolvedValue({
                ...mockSimulation,
                isActive: true
            });

            const result = await toggleSimulation("sim123");

            expect(mockFindById).toHaveBeenCalledWith("sim123");
            expect(mockSimulation.isActive).toBe(true);
            expect(mockSimulation.save).toHaveBeenCalled();
            expect(result.isActive).toBe(true);
        });

        it("should throw error when simulation is not found", async () => {
            // Mock findById to return null
            mockFindById.mockResolvedValue(null);

            await expect(toggleSimulation("non-existent-id"))
                .rejects.toThrow("Simulation not found");
        });
    });

    describe("updateSimulation", () => {
        it("should update an existing simulation with new data", async () => {
            const mockSimulation = {
                _id: "sim123",
                name: "Old Name",
                categoryChanges: [],
                save: vi.fn()
            };

            const updateData = {
                name: "Updated Name",
                categoryChanges: [
                    {
                        categoryUuid: "cat123",
                        startDate: new Date("2024-01-01"),
                        endDate: new Date("2024-12-31"),
                        targetAmount: 1500
                    }
                ]
            };

            // Mock findById to return the simulation
            mockFindById.mockResolvedValue(mockSimulation);

            // Mock save to return the updated simulation
            mockSimulation.save.mockResolvedValue({
                ...mockSimulation,
                ...updateData
            });

            const result = await updateSimulation("sim123", updateData);

            expect(mockFindById).toHaveBeenCalledWith("sim123");
            expect(mockSimulation.name).toBe(updateData.name);
            expect(mockSimulation.categoryChanges).toEqual(updateData.categoryChanges);
            expect(mockSimulation.save).toHaveBeenCalled();
            expect(result.name).toBe(updateData.name);
            expect(result.categoryChanges).toEqual(updateData.categoryChanges);
        });

        it("should throw error when simulation is not found", async () => {
            // Mock findById to return null
            mockFindById.mockResolvedValue(null);

            const updateData = {
                name: "Updated Name",
                categoryChanges: []
            };

            await expect(updateSimulation("non-existent-id", updateData))
                .rejects.toThrow("Simulation not found");
        });
    });

    afterEach(() => {
        vi.clearAllMocks();
    });
});
</file>

<file path="packages/api/src/routes/budgetRoutes.ts">
import { Router } from "express";
import {
  findBudgetsForUser,
  getBudgetForUser,
  handleGetBudgetOverviewForUser,
  getAccountsForBudget,
} from "../controllers/budgetController";
import { handleRequest } from "../controllers/utils";
import { getFilteredTransactionsWithCategories } from "../controllers/transactionController";
import {
  getUncategorizedTransactionsForBudget,
  getUnapprovedTransactionsForBudget,
  getCachedSuggestionsForBudget,
  suggestSingleTransaction,
  getSuggestionsAsync,
  applySingleCategory,
  approveSingleTransaction,
  approveAllTransactions,
  applyCategories,
  applyAllCategories,
  suggestCategoriesForUncategorized,
} from "../controllers/aiSuggestionsController";

const router = Router();
// get budgets
router.get("/", handleRequest(findBudgetsForUser));

// get budget by uuid
router.get("/:uuid", handleRequest(getBudgetForUser));

// budget data overview for user
router.get("/:uuid/overview", handleRequest(handleGetBudgetOverviewForUser));

// get accounts for a budget
router.get("/:uuid/accounts", handleRequest(getAccountsForBudget));

router.get(
  "/:uuid/transactions",
  handleRequest(getFilteredTransactionsWithCategories)
);

// AI Suggestions endpoints (migrated from Python mathapi)
router.get(
  "/:uuid/uncategorized-transactions",
  handleRequest(getUncategorizedTransactionsForBudget)
);

router.get(
  "/:uuid/unapproved-transactions",
  handleRequest(getUnapprovedTransactionsForBudget)
);

router.get(
  "/:uuid/ai-suggestions/cached",
  handleRequest(getCachedSuggestionsForBudget)
);

// Debug endpoint to test JSON parsing
router.post("/:uuid/debug-json", (req, res) => {
  console.log(" Debug endpoint - req.body:", req.body);
  console.log(" Debug endpoint - req.headers:", req.headers);
  console.log(" Debug endpoint - content-type:", req.headers["content-type"]);
  res.json({
    received_body: req.body,
    body_keys: Object.keys(req.body || {}),
    content_type: req.headers["content-type"],
  });
});

// OpenAI-powered AI suggestion endpoints
router.post(
  "/:uuid/ai-suggestions/suggest-single",
  handleRequest(suggestSingleTransaction)
);

router.post(
  "/:uuid/ai-suggestions/suggestions-async",
  handleRequest(getSuggestionsAsync)
);

// Transaction categorization and approval endpoints
router.post(
  "/:uuid/ai-suggestions/apply-single",
  handleRequest(applySingleCategory)
);

router.post(
  "/:uuid/transactions/approve-single",
  handleRequest(approveSingleTransaction)
);

router.post(
  "/:uuid/transactions/approve-all",
  handleRequest(approveAllTransactions)
);

// Bulk categorization endpoints
router.post(
  "/:uuid/ai-suggestions/apply-categories",
  handleRequest(applyCategories)
);

router.post(
  "/:uuid/ai-suggestions/apply-all-categories",
  handleRequest(applyAllCategories)
);

// Batch suggestion endpoint
router.get(
  "/:uuid/ai-suggestions/suggest-categories",
  handleRequest(suggestCategoriesForUncategorized)
);

export default router;
</file>

<file path="packages/common-ts/src/components/forms.tsx">
import React from 'react';

// Reusable form field components
export const FormField = ({
    label,
    required = false,
    children
}: {
    label: string;
    required?: boolean;
    children: React.ReactNode;
}) => (
    <div className="form-control">
        <label className="label">
            <span className="label-text">
                {label} {required && <span className="text-error">*</span>}
            </span>
        </label>
        {children}
    </div>
);

export const NumberInput = ({
    value,
    onChange,
    placeholder,
    required = false,
    min,
    max,
    step = "0.01"
}: {
    value: number;
    onChange: (value: number) => void;
    placeholder?: string;
    required?: boolean;
    min?: number;
    max?: number;
    step?: string;
}) => (
    <input
        type="number"
        step={step}
        min={min}
        max={max}
        value={value || ''}
        onChange={(e) => onChange(Number(e.target.value))}
        className="input w-full"
        placeholder={placeholder}
        required={required}
        inputMode="decimal"
    />
);

export const TextInput = ({
    value,
    onChange,
    placeholder,
    required = false
}: {
    value: string;
    onChange: (value: string) => void;
    placeholder?: string;
    required?: boolean;
}) => (
    <input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="input w-full"
        placeholder={placeholder}
        required={required}
    />
);

export const DateInput = ({
    value,
    onChange,
    required = false
}: {
    value: string;
    onChange: (value: string) => void;
    required?: boolean;
}) => (
    <input
        type="date"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="input w-full"
        required={required}
    />
);

export const SelectInput = ({
    value,
    onChange,
    options,
    placeholder,
    required = false
}: {
    value: string;
    onChange: (value: string) => void;
    options: { value: string; label: string }[];
    placeholder?: string;
    required?: boolean;
}) => (
    <select
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="select w-full"
        required={required}
    >
        {placeholder && <option value="">{placeholder}</option>}
        {options.map((option) => (
            <option key={option.value} value={option.value}>
                {option.label}
            </option>
        ))}
    </select>
);
</file>

<file path="packages/common-ts/package.json">
{
    "name": "common-ts",
    "version": "1.0.0",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": {
        "build": "rimraf dist && rollup --config",
        "test": "vitest"
    },
    "dependencies": {
        "ramda": "^0.29.1"
    },
    "devDependencies": {
        "@types/ramda": "^0.29.9",
        "rimraf": "^3.0.2",
        "rollup": "^2.79.2",
        "rollup-plugin-typescript2": "^0.31.1",
        "typescript": "^5.4.5",
        "vitest": "^3.2.4"
    }
}
</file>

<file path="packages/mathapi/app/simulations/no_salary_cost_simulation.json">
[
    {
        "date": "2025-03-02",
        "amount": "7348.21",
        "reason": "Simulation: no salary",
        "category": "Salary"
    },
    {
        "date": "2025-04-02",
        "amount": "7348.21",
        "reason": "Simulation: no salary",
        "category": "Salary"
    }
]
</file>

<file path="packages/mathapi/app/tests/__init__.py">

</file>

<file path="packages/mathapi/app/categories_api.py">
from datetime import datetime, timedelta
from dotenv import load_dotenv
from app.budget_api import get_objectid_for_budget, convert_objectid_to_str
from app.db import get_DB
import logging

# Load environment variables from .env file
load_dotenv()

def get_categories_for_budget(budget_id):
    query = {
        "budgetId": budget_id
    }
    # Execute the query and retrieve categories from localcategories
    categories = get_DB().localcategories.find(query)
    categories_list = []
    for category in categories:
        categories_list.append(convert_objectid_to_str(category))
    return categories_list
</file>

<file path="packages/web/app/api/scheduledTransactions.client.ts">
import { apiGet, apiPut, apiDelete, apiPost } from "./client";

export type ScheduledTransactionUpdate = {
  amount?: number;
  categoryId?: string;
  date?: string;
  payeeName?: string;
  memo?: string;
  accountId?: string;
};

export type ScheduledTransactionCreate = {
  amount: number;
  categoryId: string;
  date: string;
  payeeName?: string;
  memo?: string;
  accountId: string;
};

/**
 * Get scheduled transactions for a budget from Node.js API
 */
export const getScheduledTransactions = async (budgetUuid: string) => {
  return apiGet(`budgets/${budgetUuid}/scheduled-transactions`);
};

export const createScheduledTransaction = async (
  budgetUuid: string,
  transactionData: ScheduledTransactionCreate
) => {
  return apiPost(
    `budgets/${budgetUuid}/scheduled-transactions`,
    transactionData
  );
};

export const updateScheduledTransaction = async (
  budgetUuid: string,
  transactionId: string,
  updates: ScheduledTransactionUpdate
) => {
  return apiPut(
    `budgets/${budgetUuid}/scheduled-transactions/${transactionId}`,
    updates
  );
};

export const deleteScheduledTransaction = async (
  budgetUuid: string,
  transactionId: string
) => {
  return apiDelete(
    `budgets/${budgetUuid}/scheduled-transactions/${transactionId}`
  );
};
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/EditTransactionDialog.tsx">
"use client";

import { useState, useEffect } from 'react';
import { FiX } from 'react-icons/fi';
import { Category, FormField, NumberInput, TextInput, DateInput, SelectInput, AmountInput, withoutInflowCategoryFilter } from 'common-ts';
import { ScheduledTransactionUpdate, ScheduledTransactionCreate } from '../../../api/scheduledTransactions.client';
import { Account } from '../../../api/accounts.server';

type TransactionData = {
    amount: number;
    categoryId: string;
    date: string;
    payeeName?: string;
    memo?: string;
    accountId?: string;
};

type Props = {
    isOpen: boolean;
    onClose: () => void;
    onSave?: (updates: ScheduledTransactionUpdate) => Promise<void>;
    onCreate?: (data: ScheduledTransactionCreate) => Promise<void>;
    categories: Category[];
    accounts: Account[];
    budgetUuid: string;
    transaction?: TransactionData;
    mode?: 'edit' | 'create';
};

// Custom hook for form state management
const useTransactionForm = (transaction?: TransactionData, mode: 'edit' | 'create' = 'edit') => {
    // Initialize with transaction data or defaults
    const initialData = mode === 'edit' && transaction ? {
        amount: transaction.amount,
        categoryId: transaction.categoryId,
        date: transaction.date,
        payeeName: transaction.payeeName || '',
        memo: transaction.memo || '',
        accountId: transaction.accountId || '',
    } : {
        amount: 0,
        categoryId: '',
        date: new Date().toISOString().split('T')[0],
        payeeName: '',
        memo: '',
        accountId: '',
    };

    const [formData, setFormData] = useState<TransactionData>(initialData);

    const updateField = (field: keyof TransactionData, value: string | number) => {
        setFormData(prev => ({ ...prev, [field]: value }));
    };

    const resetForm = () => {
        setFormData(initialData);
    };

    return { formData, updateField, resetForm };
};

export const EditTransactionDialog = ({ isOpen, onClose, onSave, onCreate, categories, accounts, budgetUuid, transaction, mode = 'edit' }: Props) => {
    const { formData, updateField, resetForm } = useTransactionForm(transaction, mode);
    const [isSaving, setIsSaving] = useState(false);
    const [error, setError] = useState('');

    // Set first account as default for create mode when dialog opens
    useEffect(() => {
        if (isOpen && mode === 'create' && accounts.length > 0 && !formData.accountId) {
            updateField('accountId', accounts[0].uuid);
        }
        if (isOpen) {
            setError('');
        }
    }, [isOpen, mode, accounts, formData.accountId, updateField]);

    const validateForm = (): string | null => {
        if (!formData.amount || !formData.categoryId || !formData.date) {
            return 'Please fill in all required fields';
        }
        if (mode === 'create' && !formData.accountId) {
            return 'Please select an account';
        }
        return null;
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        setIsSaving(true);

        try {
            const validationError = validateForm();
            if (validationError) {
                setError(validationError);
                return;
            }

            if (mode === 'create' && onCreate) {
                await onCreate({
                    amount: formData.amount,
                    categoryId: formData.categoryId,
                    date: formData.date,
                    payeeName: formData.payeeName || undefined,
                    memo: formData.memo || undefined,
                    accountId: formData.accountId!,
                });
            } else if (mode === 'edit' && onSave) {
                await onSave({
                    amount: formData.amount,
                    categoryId: formData.categoryId,
                    date: formData.date,
                    payeeName: formData.payeeName,
                    memo: formData.memo,
                    accountId: formData.accountId,
                });
            } else {
                setError('Invalid operation mode');
                return;
            }
            onClose();
        } catch (err) {
            setError(mode === 'create' ? 'Failed to create transaction' : 'Failed to save changes');
        } finally {
            setIsSaving(false);
        }
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-base-100 rounded-lg w-full max-w-md relative max-h-[90vh] flex flex-col">
                <div className="flex justify-between items-center p-6 pb-4 border-b border-base-200">
                    <h3 className="text-lg font-bold">
                        {mode === 'create' ? 'Add Scheduled Transaction' : 'Edit Transaction'}
                    </h3>
                    <button
                        onClick={onClose}
                        className="btn btn-ghost btn-sm"
                        type="button"
                    >
                        <FiX className="h-5 w-5" />
                    </button>
                </div>

                <div className="flex-1 overflow-y-auto p-6 pt-4">
                <form id="transaction-form" onSubmit={handleSubmit} className="space-y-4">
                    <FormField label="Amount" required>
                        <AmountInput
                            value={formData.amount}
                            onChange={(value) => updateField('amount', value)}
                            placeholder="0.00"
                            required
                            showToggle={true}
                        />
                    </FormField>

                    <FormField label="Category" required>
                        <SelectInput
                            value={formData.categoryId}
                            onChange={(value) => updateField('categoryId', value)}
                            options={categories
                                .filter(withoutInflowCategoryFilter)
                                .map(cat => ({ value: cat.uuid, label: cat.name }))
                            }
                            placeholder="Select a category"
                            required
                        />
                    </FormField>

                    <FormField label="Date" required>
                        <DateInput
                            value={formData.date}
                            onChange={(value) => updateField('date', value)}
                            required
                        />
                    </FormField>

                    <FormField label="Account" required={mode === 'create'}>
                        <SelectInput
                            value={formData.accountId || ''}
                            onChange={(value) => updateField('accountId', value)}
                            options={accounts.map(acc => ({ value: acc.uuid, label: acc.name }))}
                            placeholder="Select an account"
                            required={mode === 'create'}
                        />
                    </FormField>

                    <FormField label="Payee">
                        <TextInput
                            value={formData.payeeName || ''}
                            onChange={(value) => updateField('payeeName', value)}
                            placeholder="Enter payee name"
                        />
                    </FormField>

                    <FormField label="Memo">
                        <TextInput
                            value={formData.memo || ''}
                            onChange={(value) => updateField('memo', value)}
                            placeholder="Enter memo"
                        />
                    </FormField>

                    {error && (
                        <div className="alert alert-error">
                            <span>{error}</span>
                        </div>
                    )}
                </form>
                </div>

                <div className="border-t border-base-200 p-6 pt-4">
                    <div className="flex justify-end gap-2">
                        <button
                            type="button"
                            onClick={onClose}
                            className="btn btn-ghost"
                            disabled={isSaving}
                        >
                            Cancel
                        </button>
                        <button
                            type="submit"
                            form="transaction-form"
                            className="btn btn-primary"
                            disabled={isSaving}
                        >
                            {isSaving
                                ? (mode === 'create' ? 'Creating...' : 'Saving...')
                                : (mode === 'create' ? 'Create Transaction' : 'Save Changes')
                            }
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/actions.ts">
"use server";

import { revalidatePath } from "next/cache";
import {
  applyCategories as applyCategoriesApi,
  applyAllCategories as applyAllCategoriesApi,
  getSuggestionsAsync as getSuggestionsAsyncApi,
  getSingleSuggestion as getSingleSuggestionApi,
  applySingleCategory as applySingleCategoryApi,
  getUnapprovedTransactions as getUnapprovedTransactionsApi,
} from "../../../api/ai-suggestions.server";

import {
  approveSingleTransaction as approveSingleTransactionApi,
  approveAllTransactions as approveAllTransactionsApi,
} from "../../../api/transaction/transaction.client";

export async function applyCategories(budgetId: string, transactions: any[]) {
  try {
    const result = await applyCategoriesApi(budgetId, transactions);

    // Invalidate the cache for the uncategorised page
    revalidatePath(`/budgets/${budgetId}/uncategorised`);

    return result;
  } catch (error) {
    console.error("Error applying categories:", error);
    throw error;
  }
}

export async function applyAllCategories(budgetId: string) {
  try {
    const result = await applyAllCategoriesApi(budgetId);

    // Invalidate the cache for the uncategorised page
    revalidatePath(`/budgets/${budgetId}/uncategorised`);

    return result;
  } catch (error) {
    console.error("Error applying all categories:", error);
    throw error;
  }
}

export async function getSuggestionsAsync(
  budgetId: string,
  transactionIds: string[]
) {
  try {
    return await getSuggestionsAsyncApi(budgetId, transactionIds);
  } catch (error) {
    console.error("Error getting async suggestions:", error);
    throw error;
  }
}

export async function getSingleSuggestion(
  budgetId: string,
  transactionId: string,
  transaction?: any
) {
  try {
    return await getSingleSuggestionApi(budgetId, transactionId, transaction);
  } catch (error) {
    console.error("Error getting single suggestion:", error);
    throw error;
  }
}

export async function applySingleCategory(
  budgetId: string,
  transactionId: string,
  categoryName: string,
  isManualChange: boolean = false
) {
  try {
    const result = await applySingleCategoryApi(
      budgetId,
      transactionId,
      categoryName,
      isManualChange
    );

    // Invalidate the cache for the uncategorised page
    revalidatePath(`/budgets/${budgetId}/uncategorised`);

    return result;
  } catch (error) {
    console.error("Error applying single category:", error);
    throw error;
  }
}

export async function approveSingleTransaction(
  budgetId: string,
  transactionId: string
) {
  try {
    const result = await approveSingleTransactionApi(budgetId, transactionId);

    // Invalidate the cache for the uncategorised page
    revalidatePath(`/budgets/${budgetId}/uncategorised`);

    return result;
  } catch (error) {
    console.error("Error approving single transaction:", error);
    throw error;
  }
}

export async function approveAllTransactions(budgetId: string) {
  try {
    const result = await approveAllTransactionsApi(budgetId);

    // Invalidate the cache for the uncategorised page
    revalidatePath(`/budgets/${budgetId}/uncategorised`);

    return result;
  } catch (error) {
    console.error("Error approving all transactions:", error);
    throw error;
  }
}

export async function getUnapprovedTransactions(budgetId: string) {
  try {
    return await getUnapprovedTransactionsApi(budgetId);
  } catch (error) {
    console.error("Error getting unapproved transactions:", error);
    throw error;
  }
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/page.tsx">
import { Suspense } from 'react';
import { getCategories } from '../../../api/categories.client';
import BudgetSubNavigation from '../../../components/budget-sub-navigation';
import Loading from '../../../components/Loading';
import TransactionsDataSection from './TransactionsDataSection';

interface PageProps {
    params: {
        budgetUuid: string;
    };
}

export default async function UncategorisedTransactionsPage({ params }: PageProps) {
    const budgetUuid = params.budgetUuid;

    // Fetch categories immediately (fast operation)
    const categories = await getCategories(budgetUuid);

    return (
        <>
            <BudgetSubNavigation budgetUuid={budgetUuid} />
            <div className="container mx-auto p-4">
                <h1 className="text-3xl font-bold mb-6 dark:text-white">Transactions</h1>

                <Suspense fallback={<Loading />}>
                    <TransactionsDataSection
                        budgetUuid={budgetUuid}
                        categories={categories}
                    />
                </Suspense>
            </div>
        </>
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/TransactionsPageWithTabs.tsx">
"use client";

import React, { useState } from 'react';
import { Category } from 'common-ts';
import UncategorisedTransactionsContent from './UncategorisedTransactionsContent';
import UnapprovedTransactionsContent from './UnapprovedTransactionsContent';
import { SuggestedTransaction } from './UncategorisedTransactionsContent';

interface UnapprovedTransaction {
    transaction_id: string;
    payee_name: string;
    clean_payee_name?: string;
    amount: number;
    date: string;
    memo: string;
    category_name?: string;
    category_id?: string;
    approved: boolean;
}

interface Props {
    budgetUuid: string;
    categories: Category[];
    uncategorizedTransactions: SuggestedTransaction[];
    unapprovedTransactions: UnapprovedTransaction[];
}

type TabType = 'uncategorized' | 'unapproved';

export default function TransactionsPageWithTabs({
    budgetUuid,
    categories,
    uncategorizedTransactions,
    unapprovedTransactions
}: Props) {
    const [activeTab, setActiveTab] = useState<TabType>('uncategorized');

    const uncategorizedCount = uncategorizedTransactions.length;
    const unapprovedCount = unapprovedTransactions.length;
    return (
        <div className="space-y-6">
            {/* Tab Navigation */}
            <div className="bg-white dark:bg-slate-900 rounded-xl shadow-sm border border-slate-200 dark:border-slate-700 p-2">
                <div className="flex gap-2">
                    <button
                        className={`inline-flex items-center gap-3 px-6 py-3 text-sm font-medium rounded-lg transition-all duration-200 relative ${activeTab === 'uncategorized'
                            ? 'bg-blue-100 text-blue-800 border border-blue-200 dark:bg-blue-900/20 dark:text-blue-300 dark:border-blue-800 shadow-sm'
                            : 'text-slate-600 hover:text-slate-800 hover:bg-slate-50 dark:text-slate-400 dark:hover:text-slate-200 dark:hover:bg-slate-800'
                            }`}
                        onClick={() => setActiveTab('uncategorized')}
                    >
                        <span className="text-lg"></span>
                        <span>Uncategorized</span>
                        {uncategorizedCount > 0 && (
                            <span className="inline-flex items-center justify-center w-5 h-5 text-xs font-bold bg-red-100 text-red-800 rounded-full dark:bg-red-900/20 dark:text-red-300">
                                {uncategorizedCount}
                            </span>
                        )}

                        {/* Active indicator */}
                        {activeTab === 'uncategorized' && (
                            <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-8 h-0.5 bg-blue-500 rounded-full"></div>
                        )}
                    </button>

                    <button
                        className={`inline-flex items-center gap-3 px-6 py-3 text-sm font-medium rounded-lg transition-all duration-200 relative ${activeTab === 'unapproved'
                            ? 'bg-blue-100 text-blue-800 border border-blue-200 dark:bg-blue-900/20 dark:text-blue-300 dark:border-blue-800 shadow-sm'
                            : 'text-slate-600 hover:text-slate-800 hover:bg-slate-50 dark:text-slate-400 dark:hover:text-slate-200 dark:hover:bg-slate-800'
                            }`}
                        onClick={() => setActiveTab('unapproved')}
                    >
                        <span className="text-lg"></span>
                        <span>Unapproved</span>
                        {unapprovedCount > 0 && (
                            <span className="inline-flex items-center justify-center w-5 h-5 text-xs font-bold bg-amber-100 text-amber-800 rounded-full dark:bg-amber-900/20 dark:text-amber-300">
                                {unapprovedCount}
                            </span>
                        )}

                        {/* Active indicator */}
                        {activeTab === 'unapproved' && (
                            <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-8 h-0.5 bg-blue-500 rounded-full"></div>
                        )}
                    </button>
                </div>
            </div>

            {/* Tab Content */}
            <div >
                {activeTab === 'uncategorized' && (
                    <UncategorisedTransactionsContent
                        budgetUuid={budgetUuid}
                        categories={categories}
                        initialTransactions={uncategorizedTransactions}
                    />
                )}

                {activeTab === 'unapproved' && (
                    <UnapprovedTransactionsContent
                        budgetUuid={budgetUuid}
                        categories={categories}
                        initialTransactions={unapprovedTransactions}
                    />
                )}
            </div>
        </div>
    );
}
</file>

<file path="packages/web/app/components/budget-page/index.tsx">
import Link from "next/link";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import Loading from "../Loading";
import MonthSummaryBlock from "./month-summary-block";
import CurrentMonth from "./current-month";

import YnabLoginPage from "../ynab-login-page";
import { getBudget, getBudgetOverviewForUser } from "../../api/budget/budget.client";
import { savePreferredBudget } from "../../api/user/user.client";
import type { PredictionData } from '@/app/budgets/[budgetUuid]/predictions/prediction-data.server';
import { getPrediction } from "../../api/math.server";

export default function BudgetPage({ budgetUuid }: { budgetUuid: string }) {
  return (
    <>
      <Suspense fallback={<Loading />}>
        <BudgetInfo budgetUuid={budgetUuid} />
      </Suspense>
    </>
  );
}

async function BudgetInfo({ budgetUuid: budgetUuid }: { budgetUuid: string }) {
  savePreferredBudget(budgetUuid);
  const budget = await getBudget(budgetUuid);
  if (!budget) {
    return <YnabLoginPage />;
  }
  const { monthPercentage, monthSummaries, categories, monthTotal, forecast } = await getBudgetOverviewForUser(budgetUuid);

  // Fetch prediction data
  let predictionData: PredictionData | undefined;
  try {
    predictionData = await getPrediction(budgetUuid);
  } catch (error) {
    console.error('Error fetching prediction data:', error);
  }

  const aiResponse = { response: "AI response" };

  if (monthSummaries.length === 0) {
    return <YnabLoginPage />;
  }

  const currentMonth = monthSummaries.find((month) => month.isCurrentMonth);
  return (
    <>
      <h1 className="text-center">{budget.name}</h1>
      {currentMonth && (
        <div className="mb-4 -mx-2">
          <CurrentMonth
            budgetUuid={budgetUuid}
            monthSummary={currentMonth}
            categories={categories}
            monthPercentage={monthPercentage}
            monthTotal={monthTotal}
            forecast={forecast}
            predictionData={predictionData}
          />
        </div>
      )}
      <div className="flex flex-wrap mb-4 -mx-2">
        {monthSummaries
          .filter((month) => !month.isCurrentMonth)
          .map((month) => (
            <MonthSummaryBlock
              budgetUuid={budgetUuid}
              month={month}
              categories={categories}
              key={month.month}
            />
          ))}
      </div>
    </>
  );
}
</file>

<file path="packages/web/app/components/transactions-page/transaction-card.tsx">
import React, { useState } from 'react';
import { Category } from 'common-ts';
import { TransactionAmount } from './transaction-amount';
import { TransactionBadge, CategoryBadge, BadgeType } from './transaction-badge';
import { CategoryEditor } from './category-editor';
import { FaEdit, FaTrash, FaCheck } from 'react-icons/fa';
import { PayeeTooltip } from './payee-tooltip';

// Base transaction interface that all transaction types should extend
export interface BaseTransaction {
  amount: number;
  payee_name?: string;
  payeeName?: string;
  cleanPayeeName?: string;
  date: string;
  memo?: string;
  id?: string;
  transaction_id?: string;
}

// Props for the transaction card component
interface TransactionCardProps<T extends BaseTransaction> {
  transaction: T;

  // Display options
  showCategory?: boolean;
  showActions?: boolean;
  showMemo?: boolean;
  enableCategoryEdit?: boolean;

  // Category information
  categoryName?: string;
  categoryId?: string;
  categories?: Category[];
  categoryBadgeProps?: {
    isManuallyModified?: boolean;
    isUncategorized?: boolean;
    isCached?: boolean;
  };

  // Status badges
  statusBadge?: {
    type: BadgeType;
    text?: string;
  };

  // Actions
  onEdit?: () => void;
  onRemove?: () => void;
  onApply?: () => void;
  onCategoryChange?: (transactionId: string, categoryId: string, categoryName: string) => Promise<void>;

  // Loading states
  isApplying?: boolean;
  isEditing?: boolean;

  // Styling
  className?: string;
  variant?: 'default' | 'attention' | 'modified' | 'success';
}

export function TransactionCard<T extends BaseTransaction>({
  transaction,
  showCategory = true,
  showActions = false,
  showMemo = true,
  enableCategoryEdit = false,
  categoryName,
  categoryId,
  categories = [],
  categoryBadgeProps,
  statusBadge,
  onEdit,
  onRemove,
  onApply,
  onCategoryChange,
  isApplying = false,
  isEditing = false,
  className = '',
  variant = 'default'
}: TransactionCardProps<T>) {

  const getVariantClasses = () => {
    switch (variant) {
      case 'attention':
        return 'bg-gradient-to-r from-red-50 to-rose-50 border-red-200 dark:from-red-900/10 dark:to-rose-900/10 dark:border-red-800 border-l-4 border-l-red-500 shadow-sm';
      case 'modified':
        return 'bg-gradient-to-r from-amber-50 to-orange-50 border-amber-200 dark:from-amber-900/10 dark:to-orange-900/10 dark:border-amber-800 shadow-sm';
      case 'success':
        return 'bg-gradient-to-r from-emerald-50 to-green-50 border-emerald-200 dark:from-emerald-900/10 dark:to-green-900/10 dark:border-emerald-800 shadow-sm';
      default:
        return 'bg-white border-slate-200 dark:bg-slate-900 dark:border-slate-700 shadow-sm hover:shadow-md transition-shadow duration-200';
    }
  };

  // Get clean payee name for display - prefer clean name if available
  const payeeName = transaction.cleanPayeeName ||
    transaction.payee_name ||
    transaction.payeeName ||
    'Unknown Payee';

  return (
    <div
      className={`flex flex-col lg:flex-row justify-between items-start lg:items-center p-4 rounded-lg border gap-4 ${getVariantClasses()} ${className}`}
    >
      {/* Left section - Payee and badges */}
      <div className="flex-1 min-w-0">
        <div className="flex flex-col sm:flex-row sm:items-center gap-2 mb-2">
          <PayeeTooltip
            cleanPayeeName={payeeName}
            fullPayeeName={transaction.payee_name || transaction.payeeName}
            className="flex-1 min-w-0"
          />

          {/* Status badge */}
          {statusBadge && (
            <TransactionBadge
              type={statusBadge.type}
              text={statusBadge.text}
              className="flex-shrink-0"
            />
          )}
        </div>

        {/*  memo */}
        {showMemo && transaction.memo && (
          <div className="text-sm text-gray-500 dark:text-gray-400 truncate">
            {transaction.memo}
          </div>
        )}
        {/* transaction id*/}
        {transaction.id && (
          <div className="text-sm text-gray-500 dark:text-gray-400 truncate">
            {transaction.id}
          </div>
        )}
      </div>

      {/* Right section - Category, Amount, Actions */}
      <div className="flex flex-col sm:flex-row items-start sm:items-center gap-4 w-full lg:w-auto">

        {/* Category section */}
        {showCategory && (
          <div className="flex items-center gap-2 min-w-0">
            <span className="text-sm font-medium whitespace-nowrap">Category:</span>
            {enableCategoryEdit && categories.length > 0 && onCategoryChange ? (
              <CategoryEditor
                currentCategoryName={categoryName}
                currentCategoryId={categoryId}
                categories={categories}
                onSave={async (categoryId, categoryName) => {
                  const transactionId = transaction.id || transaction.transaction_id;
                  if (transactionId) {
                    await onCategoryChange(transactionId, categoryId, categoryName);
                  }
                }}
                isLoading={isEditing}
                size="sm"
                className="flex-shrink-0"
              />
            ) : isEditing ? (
              <div className="flex items-center gap-2">
                <span className="loading loading-dots loading-sm"></span>
                <span className="text-sm text-gray-500">Editing...</span>
              </div>
            ) : categoryName ? (
              <CategoryBadge
                categoryName={categoryName}
                {...categoryBadgeProps}
                className="flex-shrink-0"
              />
            ) : (
              <TransactionBadge
                type="no-suggestion"
                className="flex-shrink-0"
              />
            )}
          </div>
        )}

        {/* Amount */}
        <div className="text-right flex-shrink-0">
          <TransactionAmount amount={transaction.amount} />
        </div>

        {/* Actions */}
        {showActions && (
          <div className="flex gap-2 flex-shrink-0">
            {onEdit && (
              <button
                className="btn btn-ghost btn-sm"
                onClick={onEdit}
                title="Edit category"
                disabled={isApplying}
              >
                <FaEdit />
              </button>
            )}

            {onApply && categoryName && (
              <button
                className="btn btn-success btn-sm gap-1"
                onClick={onApply}
                disabled={isApplying}
                title="Apply category"
              >
                {isApplying ? (
                  <>
                    <span className="loading loading-spinner loading-xs"></span>
                    Applying...
                  </>
                ) : (
                  <>
                    <FaCheck className="w-3 h-3" />
                    Apply
                  </>
                )}
              </button>
            )}

            {onRemove && (
              <button
                className="btn btn-error btn-sm"
                onClick={onRemove}
                title="Remove from list"
                disabled={isApplying}
              >
                <FaTrash />
              </button>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="packages/web/app/components/budget-navigation.tsx">
"use client";
import Link from "next/link";
import { SignOut } from "./login";
import { useParams, usePathname } from "next/navigation";
import { Budget } from "common-ts";

type Props = {
  budgets: Budget[];
  loggedIn: boolean;
};

const BudgetNavigation = ({ budgets, loggedIn }: Props) => {
  const signOut = loggedIn ? <SignOut /> : "";
  const params = useParams();
  const pathname = usePathname();
  const currentBudgetId = params ? params.budgetUuid : "";

  // Extract the sub-route from current pathname to preserve it when switching budgets
  const getSubRoute = () => {
    if (!pathname || pathname === "/") return "";

    // Match patterns like /budgets/[uuid]/subpath
    const match = pathname.match(/^\/budgets\/[^\/]+\/(.+)$/);
    return match ? `/${match[1]}` : "";
  };

  const getBudgetHref = (budgetUuid: string) => {
    const subRoute = getSubRoute();
    return `/budgets/${budgetUuid}${subRoute}`;
  };

  const getActiveClass = (budgetId: string) =>
    `link ${currentBudgetId === budgetId ? "menu-active" : ""}`;
  return (
    <div className="navbar bg-base-100">
      <div className="navbar-start">
        <div className="dropdown">
          <label tabIndex={0} className="btn btn-ghost lg:hidden">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              className="h-5 w-5"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M4 6h16M4 12h8m-8 6h16"
              />
            </svg>
          </label>
          <ul
            tabIndex={0}
            className="menu menu-sm dropdown-content mt-3 z-[1] p-2 shadow bg-base-100 rounded-box w-52"
          >
            {budgets.map((budget) => (
              <li className="mr-6" key={budget.uuid}>
                <Link
                  className={getActiveClass(budget.uuid)}
                  href={getBudgetHref(budget.uuid)}
                >
                  {budget.name}
                </Link>
              </li>
            ))}
          </ul>
        </div>
        <Link href="/" className="btn btn-ghost normal-case text-xl">
          Budget AI
        </Link>
      </div>
      <div className="navbar-center hidden lg:flex">
        <ul className="menu menu-horizontal px-1 w-full">
          {budgets.map((budget) => (
            <li className="mr-6" key={budget.uuid}>
              <Link
                className={getActiveClass(budget.uuid)}
                href={getBudgetHref(budget.uuid)}
              >
                {budget.name}
              </Link>
            </li>
          ))}
        </ul>
      </div>

      <div className="navbar-end">{signOut}</div>
    </div>
  );
};

export default BudgetNavigation;
</file>

<file path="packages/web/app/globals.css">
@import "tailwindcss";
@plugin "daisyui";

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;

    /* Chart colors */
    --chart-1: oklch(0.646 0.222 41.116);
    --chart-2: oklch(0.6 0.118 184.704);
    --chart-3: oklch(0.398 0.07 227.392);
    --chart-4: oklch(0.828 0.189 84.429);
    --chart-5: oklch(0.769 0.188 70.08);
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;

    /* Chart colors for dark mode */
    --chart-1: oklch(0.488 0.243 264.376);
    --chart-2: oklch(0.696 0.17 162.48);
    --chart-3: oklch(0.769 0.188 70.08);
    --chart-4: oklch(0.627 0.265 303.9);
    --chart-5: oklch(0.645 0.246 16.439);
  }
}

@layer base {
  * {
    border-color: hsl(var(--border));
  }
  body {
    background-color: hsl(var(--background));
    color: hsl(var(--foreground));
  }
}

/* DaisyUI dark theme overrides */
[data-theme="dark"] {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}

[data-theme="dark"] .btn {
  color: hsl(var(--foreground));
}

[data-theme="dark"] .bg-base-200 {
  background-color: hsl(var(--card));
  color: hsl(var(--card-foreground));
}
</file>

<file path="packages/web/app/page.tsx">
import { redirect } from "next/navigation";
import BudgetPage from "./components/budget-page";
import BudgetSubNavigation from "./components/budget-sub-navigation";
import {
  getLoggedInUserPreferredBudgetId as getLoggedInUserPreferredBudgetUuid,
  isYnabTokenExpired
} from "./api/user/user.client";
import { findBudgets } from "./api/budget/budget.client";

export default async function Home() {
  const ynabTokenExpired = await isYnabTokenExpired();
  if (ynabTokenExpired) {
    redirect("/ynablogin");
  }
  const budgets = await findBudgets();
  if (budgets.length === 0) {
    //   redirect("/login");
  }
  const preferredBudget = await getLoggedInUserPreferredBudgetUuid();
  const budgetUuid = preferredBudget || budgets[0]?.uuid;
  if (!budgetUuid) {
    return <div>No budgets found</div>;
  }
  return (
    <>
      <BudgetSubNavigation budgetUuid={budgetUuid} />
      <BudgetPage budgetUuid={budgetUuid} />
    </>
  );
}
</file>

<file path="packages/web/components/charts/prediction-chart.tsx">
"use client";

import React, { useState } from "react";
import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
    TimeScale
} from "chart.js";
import { Line } from "react-chartjs-2";
import { Category } from "common-ts";
import 'chartjs-adapter-date-fns';
import { enUS } from 'date-fns/locale';
import type { PredictionData } from '@/app/budgets/[budgetUuid]/predictions/prediction-data.server';
import type { TimeRange } from '@/app/budgets/[budgetUuid]/predictions/constants';
import { TIME_RANGES } from '@/app/budgets/[budgetUuid]/predictions/constants';

ChartJS.register(
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
    TimeScale
);

type Props = {
    predictionData: PredictionData;
    categories: Category[];
    variant?: 'overview' | 'detail';
    selectedTimeRange?: TimeRange;
};

export const PredictionChart = ({
    predictionData,
    categories,
    variant = 'overview',
    selectedTimeRange = '3m',
}: Props) => {
    // Function to generate a color based on index
    const getSimulationColor = (index: number) => {
        const colors = [
            "rgb(75, 192, 192)",  // cyan for actual balance
            "rgb(255, 99, 132)",  // red
            "rgb(54, 162, 235)",  // blue
            "rgb(255, 206, 86)",  // yellow
            "rgb(153, 102, 255)", // purple
            "rgb(255, 159, 64)"   // orange
        ];
        return colors[index % colors.length];
    };

    // Collect all unique dates from all simulations
    const allDates = new Set<string>();
    Object.values(predictionData).forEach(simulation => {
        Object.keys(simulation).forEach(date => allDates.add(date));
    });
    const sortedDates = Array.from(allDates).sort();

    // Filter dates based on selected time range
    const now = new Date();
    const timeRangeInMonths = TIME_RANGES[selectedTimeRange].days / 30;

    const endDate = new Date(now);
    endDate.setMonth(now.getMonth() + timeRangeInMonths);

    const filteredDates = sortedDates.filter(date => {
        const dateObj = new Date(date);
        return dateObj >= now && dateObj <= endDate;
    });

    const datasets = Object.entries(predictionData).map(([simulationName, simulationData], index) => {
        const displayName = simulationName === "Actual Balance"
            ? "Current Balance"
            : simulationName.replace(".json", "").split("_").map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(" ");

        const color = getSimulationColor(simulationName === "Actual Balance" ? 0 : index + 1);

        const dataPoints = filteredDates
            .filter(date => {
                const data = simulationData[date];
                return data && data.balance_diff !== 0;
            })
            .map(date => ({
                x: new Date(date),
                y: simulationData[date].balance
            }));

        return {
            label: displayName,
            data: dataPoints,
            borderColor: color,
            backgroundColor: 'transparent',
            borderWidth: variant === 'detail' ? 2 : 1.5,
            tension: 0.1,
            pointRadius: 2,
            pointHoverRadius: 4,
            datalabels: {
                display: false
            }
        };
    });

    // Bereken de y-as limieten
    const allValues = datasets.flatMap(d => d.data.map(p => (p as { x: Date; y: number }).y));
    const minValue = Math.min(...allValues);
    const maxValue = Math.max(...allValues);
    const yAxisPadding = Math.max(Math.abs(minValue), Math.abs(maxValue)) * (variant === 'detail' ? 0.05 : 0.1);

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
            mode: 'nearest' as const,
            axis: 'x' as const,
            intersect: false
        },
        plugins: {
            legend: {
                position: "top" as const,
                labels: {
                    font: {
                        size: variant === 'detail' ? 12 : 10
                    },
                    // Better mobile legend layout
                    boxWidth: variant === 'detail' ? 12 : 10,
                    padding: variant === 'detail' ? 15 : 10,
                    usePointStyle: true
                }
            },
            title: {
                display: true,
                text: "Balance Prediction",
                font: {
                    size: variant === 'detail' ? 20 : 16
                },
                padding: {
                    top: 10,
                    bottom: variant === 'detail' ? 20 : 15
                }
            },
            tooltip: {
                callbacks: {
                    title: function (tooltipItems: any) {
                        const date = new Date(tooltipItems[0].raw.x);
                        return `Date: ${date.toLocaleDateString('en-US', {
                            day: '2-digit',
                            month: 'long',
                            year: 'numeric'
                        })}`;
                    },
                    label: function (context: any) {
                        const data = context.raw;
                        const lines = [];

                        // Add balance
                        lines.push(`Balance: ${data.y.toFixed(2)}`);

                        // Find the simulation data
                        const simulationName = context.dataset.label;
                        const simulationKey = Object.keys(predictionData).find(key =>
                            key === simulationName ||
                            (key.endsWith('.json') && key.replace('.json', '') === simulationName) ||
                            (simulationName === "Current Balance" && key === "Actual Balance")
                        );

                        if (!simulationKey) return lines;

                        const simulation = predictionData[simulationKey];
                        if (!simulation) return lines;

                        const dateStr = data.x.toISOString().split('T')[0];
                        const dayData = simulation[dateStr];
                        if (!dayData) return lines;

                        // Add balance difference if available
                        if (dayData.balance_diff && dayData.balance_diff !== 0) {
                            const sign = dayData.balance_diff >= 0 ? '+' : '';
                            lines.push(`Change: ${sign}${dayData.balance_diff.toFixed(2)}`);
                        }

                        // Add changes
                        if (dayData.changes && dayData.changes.length > 0) {
                            lines.push('Changes:');
                            dayData.changes.forEach(change => {
                                if (change.amount === 0) return;
                                const sign = change.amount >= 0 ? '+' : '';
                                const category = categories.find(c => c.uuid === change.category)?.name || change.category;
                                let line = `  ${sign}${change.amount.toFixed(2)} - ${category}`;
                                if (change.reason) line += ` (${change.reason})`;
                                if (change.is_simulation) line += ' [Simulation]';
                                lines.push(line);
                            });
                        }

                        return lines;
                    }
                }
            }
        },
        scales: {
            x: {
                type: 'time' as const,
                display: true,
                title: {
                    display: false
                },
                adapters: {
                    date: {
                        locale: enUS
                    }
                },
                time: {
                    unit: 'day' as const,
                    displayFormats: {
                        day: 'd MMM'
                    }
                },
                ticks: {
                    maxRotation: 0,
                    minRotation: 0,
                    autoSkip: true,
                    // Responsive tick limits based on screen size
                    maxTicksLimit: variant === 'detail' ? 8 : 4,
                    align: 'start',
                    font: {
                        size: variant === 'detail' ? 11 : 10
                    },
                    display: variant === 'detail'
                }
            },
            y: {
                type: 'linear' as const,
                display: true,
                title: {
                    display: false
                },
                position: 'left' as const,
                beginAtZero: false,
                ticks: {
                    callback: function (tickValue: string | number): string {
                        return `${Number(tickValue).toFixed(0)}`;
                    },
                    // Responsive tick limits for mobile
                    maxTicksLimit: variant === 'detail' ? 8 : 6,
                    font: {
                        size: variant === 'detail' ? 11 : 10
                    }
                },
                grid: {
                    color: 'rgba(200, 200, 200, 0.2)'
                },
                suggestedMin: minValue - yAxisPadding,
                suggestedMax: maxValue + yAxisPadding
            }
        }
    } as const;

    const chartData = {
        datasets
    };

    return (
        <div className="space-y-4">
            {/* Responsive chart height - smaller on mobile */}
            <div className={variant === 'detail'
                ? 'h-[300px] sm:h-[400px] lg:h-[500px]'
                : 'h-[250px] sm:h-[350px]'
            }>
                <Line options={chartOptions} data={chartData} />
            </div>
        </div>
    );
};
</file>

<file path="packages/web/tailwind.config.ts">
import { type Config } from "tailwindcss";

const config: Config = {
  darkMode: "class",
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;
</file>

<file path="packages/web/tsconfig.json">
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "baseUrl": ".",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"],
      "common-ts": ["../common-ts/dist"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "vitest.config.ts",
    "vitest.setup.ts"
  ]
}
</file>

<file path="docker-compose.yml">
services:
  web:
    build:
      context: .
      dockerfile: packages/web/Dockerfile
    ports:
      - "3000:3000"
    env_file:
      - ./packages/web/.env
    environment:
      NODE_ENV: development
      API_URL: http://api:4000
      MATH_API_URL: http://mathapi:5000
      SENTRY_DISABLED: "true"
    depends_on:
      - api
      - mathapi
    networks:
      - default
  api:
    build:
      context: .
      dockerfile: packages/api/Dockerfile
      args:
        SENTRY_DISABLED: "true"
    ports:
      - "4000:4000"
    environment:
      NODE_ENV: development
      SENTRY_DISABLED: "true"
    env_file:
      - ./packages/api/.env
    networks:
      - default

  mathapi:
    build:
      context: .
      dockerfile: packages/mathapi/Dockerfile
    ports:
      - "5000:5000"
    environment:
      PYTHONPATH: /app
      FLASK_APP: app/app.py
      FLASK_ENV: development
      FLASK_DEBUG: 1
      CORS_ORIGINS: http://localhost:3000
      API_SERVICE_URL: http://api:4000
    env_file:
      - ./packages/mathapi/.env
    networks:
      - default
networks:
  default:
    driver: bridge
</file>

<file path="kubectl-dev.md">
# connect to prometheus

```
kubectl port-forward -n monitoring deploy/prometheus-server 9090
```

connect to:

http://localhost:9090

## login to pod

kubectl get pods -n dev
kubectl exec -it budget-web-app-c4874449d-kdw8v -n dev -- /bin/sh
kubectl exec -it budget-api-app-5d9f9dc8b9-gxjdt -n dev -- /bin/sh

## get logs

##tail -f on all pods

```
for pod in $(kubectl get pods -n dev -o jsonpath='{.items[*].metadata.name}'); do
  kubectl logs -f $pod -n dev &
done
wait

```

## list services

kubectl get services -n dev
kubectl get pods -n dev

kubectl describe pod budget-web-app -n dev
kubectl describe pod budget-api-app -n dev

kubectl logs -f budget-api-app-5d9689f479-wvbsh -n dev

kubectl logs -l app=budget-web-app -n dev --tail=100
kubectl logs -l app=budget-api-app -n dev --tail=100

```
## stop web


## stop all pods
kubectl -n dev scale deployment budget-web-app --replicas=0
## start again
kubectl -n dev scale deployment budget-web-app --replicas=1
## restart dev

```

kubectl -n dev rollout restart deployment budget-web-app
kubectl -n dev rollout restart deployment budget-api-app

-- stop dev

```

## kubernetes events

```

kubectl describe pod budget-api-app -n dev

```

# re-apply dev config

```

kubectl apply -f ./kube/config/dev

```

# getting dev config

```

kubectl get configmap budget-web-dev-config -n dev -o yaml

```

# deploying dev secrets

```

kubectl delete secret budget-web-dev-secrets -n dev
kubectl delete secret budget-api-dev-secrets -n dev

kubectl create secret generic budget-web-dev-secrets \
--from-env-file=.dev-web-secrets.env \
--namespace=dev

kubectl create secret generic budget-api-dev-secrets \
--from-env-file=.dev-api-secrets.env \
--namespace=dev

kubectl create secret generic mathapi-secrets \
--from-env-file=.dev-mathapi-secrets.env \
--namespace=dev

kubectl create secret generic mathapi-secrets \
--from-env-file=.dev-mathapi-secrets.env \
--namespace=dev

```

# get all secrets

```

kubectl get secret budget-api-dev-secrets -n dev -o yaml

```

# get pariticular decoded secret

## eg mongodb

```

kubectl get secret budget-web-dev-secrets -n dev -o jsonpath="{.data.MONGODB_URI}" | base64 --decode
kubectl get secret budget-web-dev-secrets -n dev -o jsonpath="{.data.AUTH0_CLIENT_SECRET}" | base64 --decode

```

The Prometheus PushGateway can be accessed via port 9091 on the following DNS name from within your cluster:
prometheus-prometheus-pushgateway.monitoring.svc.cluster.local

Get the PushGateway URL by running these commands in the same shell:

```
  export POD_NAME=$(kubectl get pods --namespace monitoring -l "app=prometheus-pushgateway,component=pushgateway" -o jsonpath="{.items[0].metadata.name}")
  kubectl --namespace monitoring port-forward $POD_NAME 9091
```

# Create secrets for mathapi
kubectl create secret generic mathapi-secrets \
--from-env-file=.dev-mathapi-secrets.env \
--namespace=dev
</file>

<file path="package.json">
{
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "prebuild": "npm run build --workspace common-ts",
    "build": "npm run build:web && npm run build:api",
    "build:web": "npm run build --workspace web",
    "build:api": "npm run build --workspace api",
    "postbuild": "echo Build completed successfully!",
    "dev": "concurrently \"npm run dev:web\" \"npm run dev:api\" \"npm run dev:mathapi\"",
    "dev:web": "npm run dev --workspace web",
    "dev:api": "npm run dev --workspace api",
    "dev:mathapi": "cd packages/mathapi && export FLASK_APP=app/app.py && export FLASK_ENV=development && flask run"
  },
  "dependencies": {
    "concurrently": "^8.2.2",
    "next": "^14.2.23"
  },
  "devDependencies": {
    "shadcn": "^2.4.0-canary.11"
  }
}
</file>

<file path="readme.md">
# Budget AI

##  About this project

Budget AI is a modern, intelligent budgeting application that goes beyond traditional tools like YNAB. It provides clear visual analysis of your spending patterns and leverages AI to support your financial decisions.

### Why Budget AI?
-  Detailed insights into your monthly spending patterns
-  Predictive analysis for your monthly budgets
-  Historical trends per spending category
-  AI-driven budget advice (in development)

##  Key Features

- Seamless YNAB integration for data synchronization
- Advanced spending pattern visualizations
- User-friendly interface with modern design
- Secure authentication via Auth0
- AI-powered budget predictions and analysis

##  Privacy & Security

Privacy is paramount at Budget AI. We are currently implementing end-to-end encryption to ensure the highest level of data protection. Public release will follow once this crucial security feature is implemented.

##  Architecture

Budget AI is built using a microservices architecture, consisting of several independent services:

### Web Frontend
- Next.js application with DaisyUI and Tailwind CSS
- Authentication via NextJS-Auth0
- YNAB connection through dedicated auth endpoints
- Runs on port 3000

### Backend API
- Express.js application
- MongoDB caching for optimal performance
- Automated YNAB synchronization
- Runs on port 4000

### Math API
- Specialized service for mathematical calculations and financial analysis
- Handles complex budget calculations and statistical analysis
- Built with Flask and NumPy/Pandas for efficient numerical computations
- Provides endpoints for:
  - Budget forecasting and trend analysis
  - Spending pattern calculations
  - Statistical anomaly detection
  - Financial metric computations
- Caches computation results in MongoDB for performance
- Runs on port 5000

### Common TypeScript
- Shared TypeScript library
- Contains common types and utilities
- Used across web and API services

##  Roadmap

Development priorities:
1. End-to-end encryption implementation
2. Integration of AI prediction module
3. Expansion of analytical capabilities

##  Development Setup

### Requirements
- Node.js 20+ (for local development)
- Python 3.8+ (for Math API development)
- Docker and Docker Compose (optional, for containerized development)

### Environment Setup

Each service requires specific environment variables to function properly. We provide example files (`.env.example`) for each service that you can use as a template.

1. Copy the example environment files:
```bash
cp packages/web/.env.example packages/web/.env
cp packages/api/.env.example packages/api/.env
cp packages/mathapi/.env.example packages/mathapi/.env
```

2. Configure the environment variables in each `.env` file:

#### Web Frontend (.env)
- YNAB Integration:
  - `YNAB_CLIENT_ID`: Your YNAB OAuth client ID
  - `YNAB_CLIENT_SECRET`: Your YNAB OAuth client secret
- Authentication:
  - `NEXTAUTH_URL`: Your application URL (default: "http://localhost:3000")
  - `NEXTAUTH_SECRET`: Random secret for NextAuth (generate a secure random string)
  - `AUTH0_*`: Auth0 configuration (obtain from your Auth0 dashboard)
- API Integration:
  - `API_URL`: Backend API URL (default: http://localhost:4000)
- OpenAI:
  - `OPENAI_API_KEY`: Your OpenAI API key
- Monitoring:
  - `SENTRY_DISABLED`: Set to true for local development
  - `SENTRY_AUTH_TOKEN`: Your Sentry auth token (if monitoring enabled)

#### Backend API (.env)
- Server:
  - `PORT`: API server port (default: 4000)
  - `NODE_ENV`: Environment (development/production)
- Database:
  - `MONGODB_URI`: Your MongoDB connection string
- Authentication:
  - `AUTH0_ISSUER_BASE_URL`: Your Auth0 domain
  - `AUTH0_AUDIENCE`: Your Auth0 API identifier
- YNAB:
  - `YNAB_API_KEY`: Your YNAB API key
- OpenAI:
  - `OPENAI_API_KEY`: Your OpenAI API key

#### Math API (.env)
- Server:
  - `FLASK_APP`: Main application file (default: app/app.py)
  - `FLASK_ENV`: Environment (development/production)
  - `PORT`: Math API server port (default: 5000)
- Database:
  - `MONGODB_URI`: Your MongoDB connection string (for caching calculations)
- Authentication:
  - `AUTH0_ISSUER_BASE_URL`: Your Auth0 domain
  - `AUTH0_AUDIENCE`: Your Auth0 API identifier
- Integration:
  - `API_SERVICE_URL`: Backend API URL (default: http://localhost:4000)

3. Where to get the credentials:
- YNAB: Create an application at https://app.ynab.com/settings/developer
- Auth0: Set up an application and API in your Auth0 dashboard
- OpenAI: Get your API key from https://platform.openai.com/account/api-keys
- MongoDB: Set up a database and get connection details from your MongoDB provider
- Sentry: Get credentials from your Sentry dashboard (optional for development)

### Installation

1. Install dependencies:
```bash
npm install
```

2. Start all services in development mode:
```bash
npm run dev
```

This will concurrently start all services:
- Web Frontend (http://localhost:3000)
- Backend API (http://localhost:4000)
- Math API (http://localhost:5000)

Alternatively, you can start services individually:
```bash
npm run dev:web    # Start only the web frontend
npm run dev:api    # Start only the backend API
npm run dev:mathapi # Start only the math API
```

#### Using Docker (alternative)
```bash
# Build and start all services
docker-compose up --build

# Start specific services
docker-compose up web api
```

### Available Services
- Web UI: http://localhost:3000
- API: http://localhost:4000
- Math API: http://localhost:5000

##  Contributing

Suggestions and ideas are welcome! Feel free to reach out if you'd like to contribute to the development of Budget AI.
</file>

<file path="packages/api/src/routes/scheduledTransactions.ts">
import { Router } from "express";
import * as scheduledTransactionController from "../controllers/scheduledTransactionController";
import { handleRequest } from "../controllers/utils";

const router = Router();

// Get scheduled transactions for a budget
router.get(
  "/:uuid/scheduled-transactions",
  handleRequest(scheduledTransactionController.getScheduledTransactions)
);

// Create a new scheduled transaction
router.post(
  "/:uuid/scheduled-transactions",
  handleRequest(scheduledTransactionController.create)
);

// Update a scheduled transaction
router.put(
  "/:uuid/scheduled-transactions/:transactionId",
  handleRequest(scheduledTransactionController.update)
);

// Delete a scheduled transaction
router.delete(
  "/:uuid/scheduled-transactions/:transactionId",
  handleRequest(scheduledTransactionController.remove)
);

export default router;
</file>

<file path="packages/api/package.json">
{
  "name": "api",
  "version": "1.0.0",
  "description": "the budget-ai main api",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc && npm run sentry:sourcemaps",
    "start": "ts-node src/index.ts",
    "dev": "npx ts-node-dev --respawn --transpile-only src/index.ts",
    "test": "vitest",
    "sentry:sourcemaps": "sentry-cli sourcemaps inject --org vanden-it --project budget-ai-api ./dist && sentry-cli sourcemaps upload --org vanden-it --project budget-ai-api ./dist"
  },
  "dependencies": {
    "@sentry/cli": "^2.38.2",
    "@sentry/node": "^8.37.1",
    "@sentry/profiling-node": "^8.37.1",
    "common-ts": "*",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.20.0",
    "express-jwt": "^8.4.1",
    "express-oauth2-jwt-bearer": "^1.6.0",
    "jwks-rsa": "^3.1.0",
    "lodash": "^4.17.21",
    "moment": "^2.29.4",
    "mongodb": "^6.3.0",
    "mongoose": "^8.9.5",
    "openai": "^4.104.0",
    "path-to-regexp": "^0.1.12",
    "prom-client": "^15.1.2",
    "ramda": "^0.29.1",
    "ynab": "^2.0.0"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.12",
    "@types/lodash": "^4.17.13",
    "@types/node": "^20.12.12",
    "@types/ramda": "^0.29.9",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="packages/mathapi/pytest.ini">
[pytest]
# Disable deprecation warnings
filterwarnings =
    ignore::DeprecationWarning
    ignore::RuntimeWarning

# Configure test output and coverage
addopts = 
    --verbosity=2
    --no-header 
    --tb=short 
    --cov=app
    --cov-report=html
    --cov-report=term-missing

# Test paths (only unit tests remain)
testpaths =
    app/tests/unit

# Test markers (for categorization)
markers =
    unit: Pure unit tests (fast, no external dependencies)
    slow: Slow tests (excluded from quick runs)

# CI Configuration:
# - Run unit tests: pytest app/tests/unit/
# - Run all tests: pytest
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/UnapprovedTransactionsContent.tsx">
"use client";

import React, { useState, useEffect } from 'react';
import { Category } from 'common-ts';
import UnapprovedTransactionsList from './UnapprovedTransactionsList';
import UnapprovedStats from './UnapprovedStats';
import { approveSingleTransaction, approveAllTransactions, applySingleCategory } from './actions';

export interface UnapprovedTransaction {
    transaction_id: string;
    payee_name: string;
    clean_payee_name?: string;
    amount: number;
    date: string;
    memo: string;
    category_name?: string;
    category_id?: string;
    approved: boolean;
}

interface Props {
    budgetUuid: string;
    categories: Category[];
    initialTransactions: UnapprovedTransaction[];
}

export default function UnapprovedTransactionsContent({
    budgetUuid,
    categories,
    initialTransactions
}: Props) {
    const [unapprovedTransactions, setUnapprovedTransactions] = useState<UnapprovedTransaction[]>(initialTransactions);
    const [isApproving, setIsApproving] = useState(false);
    const [approvingTransactions, setApprovingTransactions] = useState<Set<string>>(new Set());
    const [lastApproveResult, setLastApproveResult] = useState<any>(null);

    //  Sync local state with server data when it changes (after revalidatePath)
    useEffect(() => {
        console.log(' Server data changed, syncing unapproved transactions...');
        setUnapprovedTransactions(initialTransactions);

        //  Clear approving states when server data refreshes (transactions are gone)
        setApprovingTransactions(new Set());
        setIsApproving(false);
    }, [initialTransactions]);

    const handleApproveAll = async () => {
        setIsApproving(true);

        //  Show all transactions as approving during Approve All
        const allTransactionIds = unapprovedTransactions.map(tx => tx.transaction_id);
        setApprovingTransactions(new Set(allTransactionIds));

        try {
            const result = await approveAllTransactions(budgetUuid);
            setLastApproveResult(result);

            // Server data will refresh via revalidatePath - no need to manually update state
            // Server data will refresh via revalidatePath - no need to manually update state
        } catch (error) {
            console.error('Error approving all transactions:', error);
            setLastApproveResult({ error: 'Failed to approve all transactions' });
            //  Only clear loading on error - success will be cleared by server refresh
            setIsApproving(false);
            setApprovingTransactions(new Set());
        }
        //  Don't clear loading states on success - let server refresh handle it
    };

    const handleApproveSingle = async (transactionId: string) => {
        // Add to approving set
        setApprovingTransactions(prev => new Set([...prev, transactionId]));

        try {
            const result = await approveSingleTransaction(budgetUuid, transactionId);

            if (result.success) {
                // Show success message - server data will refresh via revalidatePath
                // Show success message - server data will refresh via revalidatePath
                setLastApproveResult({
                    message: ` Transaction approved`,
                    approved_count: 1
                });

                console.log(` Successfully approved transaction ${transactionId}`);
            }
        } catch (error) {
            console.error('Error approving single transaction:', error);
            setLastApproveResult({
                error: `Failed to approve transaction: ${error}`
            });
            //  Only clear loading on error - success will be cleared by server refresh
            setApprovingTransactions(prev => {
                const newSet = new Set(prev);
                newSet.delete(transactionId);
                return newSet;
            });
        }
        //  Don't clear loading state on success - let server refresh handle it
    };

    const handleCategorizeAndApprove = async (transactionId: string, categoryName: string) => {
        // Add to approving set
        setApprovingTransactions(prev => new Set([...prev, transactionId]));

        try {
            // Use the existing applySingleCategory which does categorization + approval + learning
            const result = await applySingleCategory(budgetUuid, transactionId, categoryName);

            if (result.success) {
                // Show success message - server data will refresh via revalidatePath
                // Show success message - server data will refresh via revalidatePath
                setLastApproveResult({
                    message: ` Applied '${categoryName}' and approved transaction`,
                    approved_count: 1
                });

                console.log(` Successfully categorized and approved transaction ${transactionId}`);
            }
        } catch (error) {
            console.error('Error categorizing and approving transaction:', error);
            setLastApproveResult({
                error: `Failed to categorize and approve transaction: ${error}`
            });
            //  Only clear loading on error - success will be cleared by server refresh
            setApprovingTransactions(prev => {
                const newSet = new Set(prev);
                newSet.delete(transactionId);
                return newSet;
            });
        }
        //  Don't clear loading state on success - let server refresh handle it
    };

    const totalCount = unapprovedTransactions.length;
    const categorizedCount = unapprovedTransactions.filter(tx => tx.category_name).length;
    const uncategorizedCount = totalCount - categorizedCount;

    return (
        <div className="space-y-6">
            {/* Stats and Actions */}
            <UnapprovedStats
                totalTransactions={totalCount}
                categorizedCount={categorizedCount}
                uncategorizedCount={uncategorizedCount}
                onApproveAll={handleApproveAll}
                isApproving={isApproving}
                lastResult={lastApproveResult}
            />

            {/* Results Alert */}
            {lastApproveResult && (
                <div className={`alert ${lastApproveResult.error ? 'alert-error' : 'alert-success'}`}>
                    <span>
                        {lastApproveResult.error
                            ? lastApproveResult.error
                            : lastApproveResult.message
                                ? lastApproveResult.message
                                : `Successfully approved ${lastApproveResult.approved_count} transaction${lastApproveResult.approved_count !== 1 ? 's' : ''}!`
                        }
                    </span>
                </div>
            )}

            {/* Transactions List */}
            {unapprovedTransactions.length === 0 ? (
                <div className="text-center py-12">
                    <div className="text-6xl mb-4"></div>
                    <h2 className="text-2xl font-bold mb-2">All transactions are approved!</h2>
                    <p className="text-gray-600">No unapproved transactions found.</p>
                </div>
            ) : (
                <UnapprovedTransactionsList
                    transactions={unapprovedTransactions}
                    categories={categories}
                    approvingTransactions={approvingTransactions}
                    onApproveSingle={handleApproveSingle}
                    onCategorizeAndApprove={handleCategorizeAndApprove}
                />
            )}
        </div>
    );
}
</file>

<file path="packages/api/src/controllers/scheduledTransactionController.ts">
import { Request, Response } from "express";
import * as ynabService from "../data/ynab/ynab.server";
import { UserType } from "../data/user/user.server";
import { getBudgetFromReq } from "./budgetController";
import { getUserFromReq } from "./utils";
import { getBudget } from "../data/budget/budget.server";

type RequestWithUser = Request & { user: UserType };

/**
 * Get scheduled transactions for a budget
 */
export const getScheduledTransactions = async (req: Request, res: Response) => {
  const user = await getUserFromReq(req);
  if (!user) {
    throw new Error("no user found");
  }

  const budget = await getBudget(req.params.uuid, user);
  if (!budget) {
    throw new Error(`budget ${req.params.uuid} does not belong to user`);
  }

  const scheduledTransactions = await ynabService.getScheduledTransactions(
    user,
    budget.uuid
  );

  res.json(scheduledTransactions);
};

export const create = async (req: Request, res: Response) => {
  const user = await getUserFromReq(req);
  if (!user) {
    throw new Error("no user found");
  }

  const budget = await getBudget(req.params.uuid, user);
  if (!budget) {
    throw new Error(`budget ${req.params.uuid} does not belong to user`);
  }

  const { amount, categoryId, date, payeeName, memo, accountId } = req.body;

  // Validate required fields
  if (!amount || !categoryId || !date || !accountId) {
    throw new Error("Missing required fields: amount, categoryId, date, accountId");
  }

  // Validate data types and formats
  if (typeof amount !== 'number' || isNaN(amount)) {
    throw new Error("Amount must be a valid number");
  }

  if (typeof categoryId !== 'string' || categoryId.trim().length === 0) {
    throw new Error("Category ID must be a non-empty string");
  }

  if (typeof accountId !== 'string' || accountId.trim().length === 0) {
    throw new Error("Account ID must be a non-empty string");
  }

  // Validate date format (YYYY-MM-DD)
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateRegex.test(date)) {
    throw new Error("Date must be in YYYY-MM-DD format");
  }

  // Validate optional fields
  if (payeeName && typeof payeeName !== 'string') {
    throw new Error("Payee name must be a string");
  }

  if (memo && typeof memo !== 'string') {
    throw new Error("Memo must be a string");
  }

  // Sanitize string inputs
  const sanitizedData = {
    amount: Number(amount),
    categoryId: categoryId.trim(),
    date: date.trim(),
    payeeName: payeeName ? payeeName.trim() : undefined,
    memo: memo ? memo.trim() : undefined,
    accountId: accountId.trim()
  };

  const result = await ynabService.createScheduledTransaction(
    user,
    budget.uuid,
    sanitizedData
  );

  res.status(201).json(result);
};

export const update = async (req: Request, res: Response) => {
  const { transactionId } = req.params;
  const updates = req.body;
  const user = await getUserFromReq(req);
  if (!user) {
    throw new Error("no user found");
  }
  const budget = await getBudget(req.params.uuid, user);
  if (!budget) {
    throw new Error(`budget ${req.params.uuid} does not belong to user`);
  }

  const result = await ynabService.updateScheduledTransaction(
    user,
    budget.uuid,
    transactionId,
    updates
  );
  res.json(result);
};

export const remove = async (req: RequestWithUser, res: Response) => {
  const { transactionId } = req.params;

  const user = await getUserFromReq(req);
  if (!user) {
    throw new Error("no user found");
  }
  const budget = await getBudget(req.params.uuid, user);
  if (!budget) {
    throw new Error(`budget ${req.params.uuid} does not belong to user`);
  }
  await ynabService.deleteScheduledTransaction(
    user,
    budget.uuid,
    transactionId
  );
  res.json({ success: true });
};
</file>

<file path="packages/api/src/data/simulation/simulation.server.ts">
import { Simulation } from "./simulation.schema";
import { UserType } from "../user/user.server";
import { getBudget } from "../budget/budget.server";
import connectDb from "../db";

export type CreateSimulationInput = {
    name: string;
    categoryChanges: {
        categoryUuid: string;
        startDate?: Date;
        endDate?: Date;
        targetAmount: number;
    }[];
};

export type UpdateSimulationInput = {
    name: string;
    categoryChanges: {
        categoryUuid: string;
        startDate?: Date;
        endDate?: Date;
        targetAmount: number;
    }[];
};

export const findSimulationsForBudget = async (budgetId: string) => {
    connectDb();
    return Simulation.find({ budgetId });
};

export const createSimulation = async (budgetUuid: string, user: UserType, data: CreateSimulationInput) => {
    connectDb();
    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
        throw new Error('Budget not found');
    }

    const simulation = new Simulation({
        budgetId: budget._id,
        name: data.name,
        categoryChanges: data.categoryChanges
    });

    await simulation.save();
    return simulation;
};

export const updateSimulation = async (id: string, data: UpdateSimulationInput) => {
    connectDb();
    const simulation = await Simulation.findById(id);
    if (!simulation) {
        throw new Error('Simulation not found');
    }

    simulation.name = data.name;
    simulation.categoryChanges = data.categoryChanges;
    await simulation.save();
    return simulation;
};

export const toggleSimulation = async (id: string) => {
    connectDb();
    const simulation = await Simulation.findById(id);
    if (!simulation) {
        throw new Error('Simulation not found');
    }

    simulation.isActive = !simulation.isActive;
    await simulation.save();
    return simulation;
};

export const deleteSimulation = async (id: string) => {
    connectDb();
    const simulation = await Simulation.findByIdAndDelete(id);
    if (!simulation) {
        throw new Error('Simulation not found');
    }
    return simulation;
};
</file>

<file path="packages/api/src/index.ts">
const { auth } = require("express-oauth2-jwt-bearer");
require("./instrument.ts");
const Sentry = require("@sentry/node");
import express from "express";
import cors from "cors";
import register from "./metrics";
require("dotenv").config();

import budgetRoutes from "./routes/budgetRoutes";
import userRoutes from "./routes/userRoutes";
import syncRoutes from "./routes/syncRoutes";
import simulationRoutes from "./routes/simulation.routes";
import scheduledTransactionRoutes from "./routes/scheduledTransactions";
import { overrideConsoleLog } from "common-ts";

overrideConsoleLog();

const app = express();

// Authorization middleware. When used, the Access Token must
// exist and be verified against the Auth0 JSON Web Key Set.
const checkJwt = auth({
  audience:
    process.env.AUTH0_AUDIENCE || "https://vandenit.eu.auth0.com/api/v2/",
  issuerBaseURL: `https://vandenit.eu.auth0.com`,
});

// Middleware
app.use(cors());
app.use(express.json());

// Health check endpoint
app.get("/health", (_req, res) => {
  res.json({ status: "ok", service: "budget-ai-api" });
});

// routes
app.use("/budgets", checkJwt, budgetRoutes);

app.use("/users", checkJwt, userRoutes);

app.use("/sync", syncRoutes);

// Add simulation routes
app.use("/simulations", checkJwt, simulationRoutes);

// Add scheduled transaction routes
app.use("/budgets", checkJwt, scheduledTransactionRoutes);

// The error handler must be registered before any other error middleware and after all controllers
Sentry.setupExpressErrorHandler(app);

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

// Add the /metrics endpoint
app.get("/metrics", async (_req, res) => {
  res.setHeader("Content-Type", register.contentType);
  res.send(await register.metrics());
});
</file>

<file path="packages/web/app/budgets/[budgetUuid]/uncategorised/UncategorisedTransactionsContent.tsx">
"use client";

import React, { useState, useEffect, useRef } from 'react';
import { Category } from 'common-ts';
import { applyCategories, applyAllCategories, getSuggestionsAsync, getSingleSuggestion, applySingleCategory } from './actions';
import UncategorisedTransactionsList from './UncategorisedTransactionsList';
import UncategorisedStats from './UncategorisedStats';

export interface SuggestedTransaction {
    transaction_id: string;
    payee_name: string;
    clean_payee_name?: string;
    amount: number;
    date: string;
    memo?: string;
    suggested_category_name: string | null;
    loading_suggestion?: boolean;
    cached?: boolean;
}

interface Props {
    budgetUuid: string;
    categories: Category[];
    initialTransactions: SuggestedTransaction[];
}

export default function UncategorisedTransactionsContent({
    budgetUuid,
    categories,
    initialTransactions
}: Props) {
    //  Hybrid approach: local state for AI suggestions, but sync with server data
    const [suggestedTransactions, setSuggestedTransactions] = useState<SuggestedTransaction[]>(initialTransactions);
    const [manuallyModified, setManuallyModified] = useState<Set<string>>(new Set());
    const [isApplying, setIsApplying] = useState(false);
    const [applyingTransactions, setApplyingTransactions] = useState<Set<string>>(new Set());
    const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);
    const [lastApplyResult, setLastApplyResult] = useState<any>(null);
    const hasLoadedSuggestions = useRef(false);
    const manuallyModifiedRef = useRef(manuallyModified);

    //  Sync local state with server data when it changes (after revalidatePath)
    useEffect(() => {
        console.log(' Server data changed, syncing local state...');
        setSuggestedTransactions(initialTransactions);
        // Reset AI loading state when server data changes
        hasLoadedSuggestions.current = false;

        //  Clear applying states when server data refreshes (transactions are gone)
        setApplyingTransactions(new Set());
        setIsApplying(false);
    }, [initialTransactions]);

    // Keep ref in sync with state
    useEffect(() => {
        manuallyModifiedRef.current = manuallyModified;
    }, [manuallyModified]);

    // Load missing AI suggestions with concurrent processing
    useEffect(() => {
        if (hasLoadedSuggestions.current) return; // Prevent multiple loads

        const loadMissingSuggestionsWithConcurrency = async () => {
            // Find transactions that need AI suggestions
            const transactionsNeedingSuggestions = initialTransactions.filter(
                tx => tx.loading_suggestion && !tx.suggested_category_name
            );

            if (transactionsNeedingSuggestions.length === 0) {
                hasLoadedSuggestions.current = true;
                return;
            }

            console.log(` Loading AI suggestions for ${transactionsNeedingSuggestions.length} transactions with concurrent processing...`);
            setIsLoadingSuggestions(true);

            // Configuration for concurrent processing
            const MAX_CONCURRENT = 10; // Max concurrent calls
            let activePromises = 0;
            let processedCount = 0;
            let successCount = 0;
            let errorCount = 0;

            // Process single transaction
            const processSingleTransaction = async (transaction: SuggestedTransaction) => {
                try {
                    const result = await getSingleSuggestion(budgetUuid, transaction.transaction_id, {
                        id: transaction.transaction_id,
                        payee_name: transaction.payee_name,
                        amount: transaction.amount,
                        date: transaction.date
                    });

                    // Double-check if this transaction was manually modified during the AI call
                    // Use the most current state by checking both ref AND current component state
                    setSuggestedTransactions(prev => {
                        const currentTransaction = prev.find(tx => tx.transaction_id === transaction.transaction_id);
                        const isCurrentlyManuallyModified = manuallyModifiedRef.current.has(transaction.transaction_id);

                        // Additional safety: check if the transaction still exists and hasn't been removed
                        if (!currentTransaction) {
                            console.log(` Transaction ${transaction.transaction_id} no longer exists, skipping AI suggestion`);
                            return prev; // No changes
                        }

                        if (isCurrentlyManuallyModified) {
                            console.log(` Skipping AI suggestion for manually modified transaction: ${transaction.payee_name}`);
                            // Just update loading state but keep the manual category
                            return prev.map(tx =>
                                tx.transaction_id === transaction.transaction_id
                                    ? {
                                        ...tx,
                                        loading_suggestion: false,
                                        cached: result.cached
                                    }
                                    : tx
                            );
                        } else {
                            console.log(` Applying AI suggestion for: ${transaction.payee_name}  ${result.suggested_category_name}`);
                            // Apply AI suggestion only if not manually modified
                            return prev.map(tx =>
                                tx.transaction_id === transaction.transaction_id
                                    ? {
                                        ...tx,
                                        suggested_category_name: result.suggested_category_name,
                                        loading_suggestion: false,
                                        cached: result.cached
                                    }
                                    : tx
                            );
                        }
                    });

                    successCount++;
                    console.log(` ${result.cached ? '(cached)' : `(${result.processing_time_ms}ms)`} ${transaction.payee_name}  ${result.suggested_category_name}`);

                } catch (error) {
                    console.error(` Failed to get suggestion for ${transaction.payee_name}:`, error);

                    // Mark this transaction as failed
                    setSuggestedTransactions(prev =>
                        prev.map(tx =>
                            tx.transaction_id === transaction.transaction_id
                                ? { ...tx, loading_suggestion: false }
                                : tx
                        )
                    );
                    errorCount++;
                } finally {
                    activePromises--;
                    processedCount++;

                    // Log progress
                    console.log(` Progress: ${processedCount}/${transactionsNeedingSuggestions.length} (${successCount} success, ${errorCount} errors, ${activePromises} active)`);
                }
            };

            // Queue processing with concurrency limit
            let currentIndex = 0;

            const processNext = async () => {
                while (currentIndex < transactionsNeedingSuggestions.length && activePromises < MAX_CONCURRENT) {
                    const transaction = transactionsNeedingSuggestions[currentIndex];
                    currentIndex++;
                    activePromises++;

                    // Start processing (don't await here to allow concurrency)
                    processSingleTransaction(transaction).then(() => {
                        // Start next transaction if available
                        if (currentIndex < transactionsNeedingSuggestions.length) {
                            processNext();
                        }
                    });
                }
            };

            // Start initial batch
            await processNext();

            // Wait for all to complete
            const checkCompletion = () => {
                return new Promise<void>((resolve) => {
                    const checkInterval = setInterval(() => {
                        if (processedCount >= transactionsNeedingSuggestions.length) {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                });
            };

            await checkCompletion();

            console.log(` Completed loading ${transactionsNeedingSuggestions.length} suggestions (${successCount} success, ${errorCount} errors)`);
            setIsLoadingSuggestions(false);
            hasLoadedSuggestions.current = true;
        };

        loadMissingSuggestionsWithConcurrency();
    }, [budgetUuid, initialTransactions]);

    const handleApplyAllSuggestions = async () => {
        setIsApplying(true);

        //  Show all transactions as applying during Apply All
        const allTransactionIds = suggestedTransactions.map(tx => tx.transaction_id);
        setApplyingTransactions(new Set(allTransactionIds));

        try {
            // Apply all categories (both AI suggestions and manual changes)
            // The endpoint will automatically handle cached suggestions and manual changes
            const result = await applyAllCategories(budgetUuid);
            setLastApplyResult(result);

            // Show success message - server data will refresh via revalidatePath
            // Show success message - server data will refresh via revalidatePath
            if (result.updated_transactions && result.updated_transactions.length > 0) {
                // Clear manual modifications for applied transactions
                // Clear manual modifications for applied transactions
                const appliedTransactionIds = result.updated_transactions.map((r: any) => r.transaction_id);
                setManuallyModified(prev => {
                    const newSet = new Set(prev);
                    appliedTransactionIds.forEach((id: string) => newSet.delete(id));
                    return newSet;
                });
            }
        } catch (error) {
            console.error('Error applying suggestions:', error);
            setLastApplyResult({ error: 'Failed to apply suggestions' });
            //  Only clear loading on error - success will be cleared by server refresh
            setIsApplying(false);
            setApplyingTransactions(new Set());
        }
        //  Don't clear loading states on success - let server refresh handle it
    };

    const handleApplyAISuggestionsOnly = async () => {
        setIsApplying(true);

        //  Show all transactions as applying during Apply AI Only
        const allTransactionIds = suggestedTransactions.map(tx => tx.transaction_id);
        setApplyingTransactions(new Set(allTransactionIds));

        try {
            // Get transactions with manual changes marked
            const transactionsWithManualFlags = suggestedTransactions.map(tx => ({
                transaction_id: tx.transaction_id,
                category_name: tx.suggested_category_name,
                is_manual_change: manuallyModified.has(tx.transaction_id)
            }));

            const result = await applyCategories(budgetUuid, transactionsWithManualFlags);
            setLastApplyResult(result);

            // Show success message - server data will refresh via revalidatePath
            // Show success message - server data will refresh via revalidatePath
            if (result.length > 0) {
                // Clear manual modifications for applied transactions
                // Clear manual modifications for applied transactions
                const appliedTransactionIds = result.map((r: any) => r.transaction_id);
                setManuallyModified(prev => {
                    const newSet = new Set(prev);
                    appliedTransactionIds.forEach((id: string) => newSet.delete(id));
                    return newSet;
                });
            }
        } catch (error) {
            console.error('Error applying AI suggestions:', error);
            setLastApplyResult({ error: 'Failed to apply AI suggestions' });
            //  Only clear loading on error - success will be cleared by server refresh
            setIsApplying(false);
            setApplyingTransactions(new Set());
        }
        //  Don't clear loading states on success - let server refresh handle it
    };

    const handleManualCategoryChange = (transactionId: string, newCategoryName: string) => {
        setSuggestedTransactions(prev =>
            prev.map(transaction =>
                transaction.transaction_id === transactionId
                    ? { ...transaction, suggested_category_name: newCategoryName }
                    : transaction
            )
        );
        // Mark this transaction as manually modified
        setManuallyModified(prev => new Set([...prev, transactionId]));
    };

    const handleRemoveTransaction = (transactionId: string) => {
        setSuggestedTransactions(prev =>
            prev.filter(t => t.transaction_id !== transactionId)
        );
        // Remove from manually modified set if present
        setManuallyModified(prev => {
            const newSet = new Set(prev);
            newSet.delete(transactionId);
            return newSet;
        });
    };

    const handleApplySingleCategory = async (transactionId: string, categoryName: string) => {
        // Add to applying set
        setApplyingTransactions(prev => new Set([...prev, transactionId]));

        try {
            // Apply AI suggestion (not a manual change)
            const result = await applySingleCategory(budgetUuid, transactionId, categoryName, false);

            if (result.success) {
                // Remove from manually modified set if present
                setManuallyModified(prev => {
                    const newSet = new Set(prev);
                    newSet.delete(transactionId);
                    return newSet;
                });

                // Show success message - server data will refresh via revalidatePath
                // Show success message - server data will refresh via revalidatePath
                setLastApplyResult({
                    message: ` Applied '${categoryName}' to transaction`,
                    applied_count: 1
                });

                console.log(` Successfully applied AI suggestion '${categoryName}' to transaction ${transactionId}`);
            }
        } catch (error) {
            console.error('Error applying single category:', error);
            setLastApplyResult({
                error: `Failed to apply category: ${error}`
            });
            //  Only clear loading on error - success will be cleared by server refresh
            setApplyingTransactions(prev => {
                const newSet = new Set(prev);
                newSet.delete(transactionId);
                return newSet;
            });
        }
        //  Don't clear loading state on success - let server refresh handle it
    };

    const handleApplyManualCategory = async (transactionId: string, categoryName: string) => {
        // Add to applying set
        setApplyingTransactions(prev => new Set([...prev, transactionId]));

        try {
            // Apply manual change (with payee learning)
            const result = await applySingleCategory(budgetUuid, transactionId, categoryName, true);

            if (result.success) {
                // Remove from manually modified set if present
                setManuallyModified(prev => {
                    const newSet = new Set(prev);
                    newSet.delete(transactionId);
                    return newSet;
                });

                // Show success message with learning info - server data will refresh via revalidatePath
                // Show success message with learning info - server data will refresh via revalidatePath
                const learningInfo = result.learned_mapping ? ' (learned for future)' : '';
                setLastApplyResult({
                    message: ` Applied '${categoryName}' to transaction${learningInfo}`,
                    applied_count: 1
                });

                console.log(` Successfully applied manual category '${categoryName}' to transaction ${transactionId}${learningInfo}`);
            }
        } catch (error) {
            console.error('Error applying manual category:', error);
            setLastApplyResult({
                error: `Failed to apply manual category: ${error}`
            });
            //  Only clear loading on error - success will be cleared by server refresh
            setApplyingTransactions(prev => {
                const newSet = new Set(prev);
                newSet.delete(transactionId);
                return newSet;
            });
        }
        //  Don't clear loading state on success - let server refresh handle it
    };

    const manuallyModifiedCount = manuallyModified.size;
    const aiSuggestionsCount = suggestedTransactions.length - manuallyModifiedCount;

    return (
        <div className="space-y-6">
            {/* Stats and Actions */}
            <UncategorisedStats
                totalTransactions={suggestedTransactions.length}
                aiSuggestionsCount={aiSuggestionsCount}
                manuallyModifiedCount={manuallyModifiedCount}
                onApplyAll={handleApplyAllSuggestions}
                onApplyAIOnly={handleApplyAISuggestionsOnly}
                isApplying={isApplying}
                lastResult={lastApplyResult}
            />

            {/* AI Loading Alert */}
            {isLoadingSuggestions && (
                <div className="alert alert-info">
                    <span className="loading loading-spinner loading-sm"></span>
                    <span>Loading AI suggestions for uncategorized transactions...</span>
                </div>
            )}

            {/* Results Alert */}
            {lastApplyResult && (
                <div className={`alert ${lastApplyResult.error ? 'alert-error' : 'alert-success'}`}>
                    <span>
                        {lastApplyResult.error
                            ? lastApplyResult.error
                            : lastApplyResult.message
                                ? lastApplyResult.message
                                : lastApplyResult.updated_transactions
                                    ? `Successfully applied ${lastApplyResult.updated_transactions.length} suggestions! ${lastApplyResult.learned_mappings || 0} new patterns learned.`
                                    : `Successfully applied ${lastApplyResult.length} suggestions!`
                        }
                    </span>
                </div>
            )}

            {/* Transactions List */}
            {suggestedTransactions.length === 0 ? (
                <div className="text-center py-12">
                    <div className="text-6xl mb-4"></div>
                    <h2 className="text-2xl font-bold mb-2">All transactions are categorised!</h2>
                    <p className="text-gray-600">No uncategorised transactions found.</p>
                </div>
            ) : (
                <UncategorisedTransactionsList
                    transactions={suggestedTransactions}
                    categories={categories}
                    manuallyModified={manuallyModified}
                    applyingTransactions={applyingTransactions}
                    onCategoryChange={handleManualCategoryChange}
                    onRemoveTransaction={handleRemoveTransaction}
                    onApplySingleCategory={handleApplySingleCategory}
                    onApplyManualCategory={handleApplyManualCategory}
                />
            )}
        </div>
    );
}
</file>

<file path="packages/web/app/components/budget-page/month-total-overview.tsx">
"use client";
import {
  MonthTotal, Category, formatAmount,
  totalPercentageSpent, MonthlyForcast
} from "common-ts";
import Link from "next/link";
import { CategoryPieChart } from "../charts/category-pie-chart";
import { PredictionChart } from "@/components/charts/prediction-chart";
import { percentageToStatusClass } from "../../utils";
import { useState } from "react";
import type { PredictionData } from '@/app/budgets/[budgetUuid]/predictions/prediction-data.server';

type Props = {
  budgetUuid: string;
  month: string;
  monthTotal: MonthTotal;
  monthPercentage: number;
  forecast: MonthlyForcast;
  categories: Category[];
  predictionData?: PredictionData; // TODO: Add proper type
};

type TabType = "categories" | "prediction";

const MonthTotalOverview = ({
  budgetUuid,
  month,
  monthTotal,
  monthPercentage,
  forecast,
  categories,
  predictionData,
}: Props) => {
  const [selectedTab, setSelectedTab] = useState<TabType>("categories");
  const percentage = totalPercentageSpent(monthTotal);

  const statusClass = percentageToStatusClass(percentage);
  return (
    <div className="card bg-base-100 shadow-xl mb-5">
      <div className="card-body p-0.5 sm:p-5">
        <div className="flex flex-wrap w-full">
          <div className="w-full md:w-1/2 lg:w-1/2 mb-5 md:mb-0">
            <TotalTable
              monthTotal={monthTotal}
              forecast={forecast}
              percentage={percentage}
              monthPercentage={monthPercentage}
            />
          </div>
          <div className="w-full md:w-1/2 lg:w-1/2">
            <div className="flex justify-between items-center mb-4">
              <div className="tabs tabs-box justify-center">
                <button
                  className={`tab ${selectedTab === "categories" ? "tab-active" : ""}`}
                  onClick={() => setSelectedTab("categories")}
                >
                  Categories
                </button>
                <button
                  className={`tab ${selectedTab === "prediction" ? "tab-active" : ""}`}
                  onClick={() => setSelectedTab("prediction")}
                >
                  Prediction
                </button>
              </div>
              {selectedTab === "prediction" && (
                <Link
                  href={`/budgets/${budgetUuid}/predictions`}
                  className="btn btn-primary btn-sm gap-2"
                  title="View detailed predictions"
                >
                  <span>Details</span>
                  <span className="text-lg"></span>
                </Link>
              )}
            </div>

            {selectedTab === "categories" && (
              <CategoryPieChart
                month={month}
                categories={categories}
                budgetUuid={budgetUuid}
              />
            )}
            {selectedTab === "prediction" && predictionData && (
              <div className="group relative">
                <PredictionChart
                  predictionData={predictionData}
                  categories={categories}
                  variant="overview"
                />
                <div className="absolute top-0 right-0 opacity-0 group-hover:opacity-100 transition-opacity">
                  <Link
                    href={`/budgets/${budgetUuid}/predictions`}
                    className="btn btn-circle btn-ghost btn-sm"
                    title="View detailed predictions"
                  >
                    <span className="text-lg"></span>
                  </Link>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

const TotalTable = ({
  monthTotal,
  forecast,
  monthPercentage,
  percentage,
}: {
  monthTotal: MonthTotal;
  forecast: MonthlyForcast;
  monthPercentage: number;
  percentage: number;
}) => {
  return (
    <table className="table">
      <thead>
        <tr>
          <th>Total spent</th>
          <th>Total available</th>
          <th>Total budgeted</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>{formatAmount(monthTotal.totalSpent, true)}</td>
          <td>{formatAmount(monthTotal.totalBalance)}</td>
          <td>{formatAmount(monthTotal.totalBudgeted)}</td>
        </tr>
        <tr>
          <td>Month Progress</td>
          <td colSpan={2}>
            <progress
              className={`progress progress-${percentageToStatusClass(
                monthPercentage
              )}`}
              value={monthPercentage}
              max="100"
            ></progress>
          </td>
        </tr>
        <tr>
          <td>Budget Progress</td>
          <td colSpan={2}>
            <progress
              className={`progress progress-${percentageToStatusClass(
                percentage
              )}`}
              value={percentage}
              max="100"
            ></progress>
          </td>
        </tr>
        <tr>
          <td>Forecasted Remaining amount</td>
          <td colSpan={2}>
            {formatAmount(forecast.predictedRemainingAmount)}
          </td>
        </tr>
        <tr>
          <td>Forecasted Daily amount</td>
          <td colSpan={2}>
            {formatAmount(forecast.predictedRemainingPerDay)}
          </td>
        </tr>
        <tr>
          <td>Actual Remaing per day amount</td>
          <td colSpan={2}>
            {formatAmount(forecast.actualRemainingPerDay)}
          </td>
        </tr>
        <tr>
          <td>Extra suggested</td>
          <td colSpan={2}>{formatAmount(forecast.extraAmountNeeded)}</td>
        </tr>
      </tbody>
    </table>
  );
};

export default MonthTotalOverview;
</file>

<file path=".github/workflows/dev-workflow.yml">
name: Deploy to Digital Ocean Kubernetes

on:
  push:
    branches-ignore:
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: ${{ github.sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Python dependencies and run tests
        run: |
          cd packages/mathapi
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # Run only unit tests in CI - integration tests require real DB/API connections
          python -m pytest app/tests/unit/ -v

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: github.actor != 'dependabot[bot]'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build Docker web image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./packages/web/Dockerfile
          push: ${{ github.actor != 'dependabot[bot]' }}
          tags: filipvdb321/budget-web:${{ github.sha }}
          cache-from: type=registry,ref=filipvdb321/budget-web:buildcache
          cache-to: type=registry,ref=filipvdb321/budget-web:buildcache,mode=max

      - name: Build Docker api image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./packages/api/Dockerfile
          push: ${{ github.actor != 'dependabot[bot]' }}
          secrets: |
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
          tags: filipvdb321/budget-api:${{ github.sha }}
          cache-from: type=registry,ref=filipvdb321/budget-api:buildcache
          cache-to: type=registry,ref=filipvdb321/budget-api:buildcache,mode=max

      - name: Build Docker mathapi image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./packages/mathapi/Dockerfile
          push: ${{ github.actor != 'dependabot[bot]' }}
          tags: filipvdb321/budget-mathapi:${{ github.sha }}
          cache-from: type=registry,ref=filipvdb321/budget-mathapi:buildcache
          cache-to: type=registry,ref=filipvdb321/budget-mathapi:buildcache,mode=max

      - name: Install doctl
        if: github.actor != 'dependabot[bot]'
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Replace image tag in web Kubernetes deployment file
        if: github.actor != 'dependabot[bot]'
        run: |
          envsubst '$IMAGE_TAG' < ./kube/dev/web-deployment.yml.template > ./kube/dev/web-deployment.yml

      - name: Replace image tag in api Kubernetes deployment file
        if: github.actor != 'dependabot[bot]'
        run: |
          envsubst '$IMAGE_TAG' < ./kube/dev/api-deployment.yml.template > ./kube/dev/api-deployment.yml

      - name: Replace image tag in mathapi Kubernetes deployment file
        if: github.actor != 'dependabot[bot]'
        run: |
          envsubst '$IMAGE_TAG' < ./kube/dev/mathapi-deployment.yml.template > ./kube/dev/mathapi-deployment.yml

      - name: Save Digital Ocean kubeconfig
        if: github.actor != 'dependabot[bot]'
        run: doctl kubernetes cluster kubeconfig save k8s-1-vandenit-ams3-dev

      - name: Deploy all config to Kubernetes
        if: github.actor != 'dependabot[bot]'
        run: |
          kubectl apply -f ./kube/config/dev

      - name: Deploy web config to Kubernetes
        if: github.actor != 'dependabot[bot]'
        run: |
          kubectl apply -f ./kube/dev/web-deployment.yml

      - name: Deploy api config to Kubernetes
        if: github.actor != 'dependabot[bot]'
        run: |
          kubectl apply -f ./kube/dev/api-deployment.yml

      - name: Deploy mathapi config to Kubernetes
        if: github.actor != 'dependabot[bot]'
        run: |
          kubectl apply -f ./kube/dev/mathapi-deployment.yml

      - name: Deploy web service to Kubernetes
        if: github.actor != 'dependabot[bot]'
        run: |
          kubectl apply -f ./kube/dev/web-service.yml
      - name: Deploy api service to Kubernetes
        if: github.actor != 'dependabot[bot]'
        run: |
          kubectl apply -f ./kube/dev/api-service.yml
      - name: Deploy mathapi service to Kubernetes
        if: github.actor != 'dependabot[bot]'
        run: |
          kubectl apply -f ./kube/dev/mathapi-service.yml

      - name: Verify web deployment
        if: github.actor != 'dependabot[bot]'
        run: kubectl rollout status deployment/budget-web-app -n dev

      - name: Verify api deployment
        if: github.actor != 'dependabot[bot]'
        run: kubectl rollout status deployment/budget-api-app -n dev

      - name: Verify mathapi deployment
        if: github.actor != 'dependabot[bot]'
        run: kubectl rollout status deployment/budget-mathapi-app -n dev
</file>

<file path="packages/api/src/data/ynab/ynab-api.ts">
import * as ynab from "ynab";
import { connectUserWithYnab, UserType } from "../user/user.server";

const YNAB_OAUTH_BASE_URL = "https://app.ynab.com/oauth";
const YNAB_API_BASE_URL = "https://api.ynab.com/v1";

const refreshAccessToken = async (refreshToken: string) => {
  // refresh using native fetch
  const clientId = process.env.YNAB_CLIENT_ID;
  const clientSecret = process.env.YNAB_CLIENT_SECRET;
  try {
    const response = await fetch(
      `${YNAB_OAUTH_BASE_URL}/token?client_id=${clientId}&client_secret=${clientSecret}&grant_type=refresh_token&refresh_token=${refreshToken}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
    return response.json();
  } catch (exception) {
    console.error("error during refresh access token: " + exception);
    throw new Error("Failed to refresh token");
  }
};

// todo move to client (stop using user client for connectUserWithYnab)
export const refreshUserToken = async (user: UserType) => {
  const refreshToken = user.ynab?.connection?.refreshToken;
  if (!refreshToken) {
    throw new Error("No token found");
  }
  try {
    const refreshedToken = await refreshAccessToken(refreshToken);
    await connectUserWithYnab(
      {
        accessToken: refreshedToken.access_token,
        refreshToken: refreshedToken.refresh_token,
      },
      user
    );
  } catch (exception) {
    throw new Error("Failed to refresh token:");
  }
};

export const isYnabTokenExpired = async (user: UserType) => {
  try {
    await refreshUserToken(user);
    return false;
  } catch (exception) {
    return true;
  }
};

const getApi = async (user: UserType) => {
  const token = user?.ynab?.connection.accessToken;
  if (!token) {
    throw new Error("No token found");
  }
  return new ynab.api(token);
};

export const getBudget = async (
  id: string,
  user: UserType
): Promise<ynab.BudgetDetail> => {
  const emptyBudget = { id: "", name: "" };
  try {
    const api = await getApi(user);
    const { data } = await api.budgets.getBudgetById(id);
    return data?.budget || emptyBudget;
  } catch (exception) {
    console.warn(exception);
    return emptyBudget;
  }
};

export const getBudgets = async (
  user: UserType
): Promise<ynab.BudgetDetail[]> => {
  try {
    const api = await getApi(user);
    const budgets = await api.budgets.getBudgets();
    return budgets.data.budgets;
  } catch (exception) {
    console.warn(exception);
    return [];
  }
};

const sortMostRecentFirst = (
  data: ynab.TransactionsResponseData
): ynab.TransactionsResponseData => {
  return {
    ...data,
    transactions: data.transactions.sort((a, b) => {
      return a.date > b.date ? -1 : 1;
    }),
  };
};

type GetTransactionsInput = {
  budgetId: string;
  sinceDate?: string;
  type?: ynab.GetTransactionsTypeEnum;
  lastKnowledgeOfServer?: number;
  user: UserType;
};

const getTransactionsInternal = async ({
  budgetId,
  sinceDate,
  type,
  lastKnowledgeOfServer,
  user,
}: GetTransactionsInput): Promise<ynab.TransactionsResponseData> => {
  const api = await getApi(user);
  const { data } = await api.transactions.getTransactions(
    budgetId,
    sinceDate,
    type,
    lastKnowledgeOfServer
  );
  return sortMostRecentFirst(data);
};

export const getTransactions = async (
  budgetId: string,
  lastKnowledgeOfServer: number,
  user: UserType
): Promise<ynab.TransactionsResponseData> => {
  return getTransactionsInternal({ budgetId, lastKnowledgeOfServer, user });
};

export const getUncategorizedOrUnApprovedTransactions = async (
  budgetId: string,
  user: UserType
): Promise<ynab.TransactionsResponseData> => {
  return getTransactionsInternal({ budgetId, type: "uncategorized", user });
};

/**
 * Get uncategorized transactions from YNAB API
 */
export const getUncategorizedTransactions = async (
  budgetId: string,
  user: UserType
): Promise<ynab.TransactionDetail[]> => {
  const data = await getTransactionsInternal({
    budgetId,
    type: "uncategorized",
    user,
  });

  // Filter out transfers (payee_name starts with "Transfer :")
  const filtered = data.transactions.filter(
    (transaction) => !transaction.payee_name?.startsWith("Transfer :")
  );

  return filtered;
};

/**
 * Get unapproved transactions from YNAB API
 * Similar to Python implementation
 */
export const getUnapprovedTransactions = async (
  budgetId: string,
  user: UserType
): Promise<ynab.TransactionDetail[]> => {
  // Get all transactions and filter for unapproved ones
  const data = await getTransactionsInternal({ budgetId, user });

  const unapproved: ynab.TransactionDetail[] = [];
  for (const transaction of data.transactions) {
    // Handle None payee_name safely
    const payeeName = transaction.payee_name || "";

    if (payeeName.startsWith("Transfer :")) {
      continue; // Skip transfers
    }

    // Check if transaction needs approval
    const isApproved = transaction.approved ?? true; // Default to true if not specified

    if (!isApproved) {
      unapproved.push(transaction);
    }
  }

  return unapproved;
};

type CategoriesWithKnowledge = {
  knowledge: number;
  categories: Array<ynab.Category>;
};

type AccountsWithKnowledge = {
  knowledge: number;
  accounts: Array<ynab.Account>;
};
export async function getCategories(
  budgetId: string,
  knowledge: number,
  user: UserType
): Promise<CategoriesWithKnowledge> {
  const api = await getApi(user);
  const { data } = await api.categories.getCategories(budgetId, knowledge);
  const categories = data.category_groups.reduce(
    (acc: Array<ynab.Category>, group: ynab.CategoryGroupWithCategories) => {
      return acc.concat(group.categories);
    },
    []
  );
  return {
    knowledge: data.server_knowledge,
    categories,
  };
}

export const getAccounts = async (
  budgetId: string,
  serverKnowledge: number,
  user: UserType
): Promise<AccountsWithKnowledge> => {
  const api = await getApi(user);
  console.log(
    "getting accounts for budgetId: " +
      budgetId +
      " and knowledge: " +
      serverKnowledge
  );
  const { data } = await api.accounts.getAccounts(budgetId, serverKnowledge);
  return {
    knowledge: data.server_knowledge,
    accounts: data.accounts,
  };
};

export const updateScheduledTransaction = async (
  budgetId: string,
  transactionId: string,
  data: {
    scheduled_transaction: {
      amount?: number;
      category_id?: string;
      date?: string;
      payee_name?: string;
      memo?: string;
      account_id?: string;
    };
  },
  user: UserType
) => {
  const token = user?.ynab?.connection.accessToken;
  if (!token) {
    throw new Error("No token found");
  }

  // Custom REST call to update a scheduled transaction
  const url = `${YNAB_API_BASE_URL}/budgets/${budgetId}/scheduled_transactions/${transactionId}`;

  try {
    const response = await fetch(url, {
      method: "PUT",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`YNAB API error: ${JSON.stringify(errorData)}`);
    }

    return await response.json();
  } catch (error) {
    console.error("Error updating scheduled transaction:", error);
    throw error;
  }
};

/**
 * Get scheduled transactions for a budget from YNAB API
 */
export const getScheduledTransactions = async (
  budgetId: string,
  user: UserType
): Promise<ynab.ScheduledTransactionDetail[]> => {
  const api = await getApi(user);
  const { data } = await api.scheduledTransactions.getScheduledTransactions(
    budgetId
  );
  return data.scheduled_transactions;
};

/**
 * Create a scheduled transaction in YNAB API
 */
export const createScheduledTransaction = async (
  budgetId: string,
  data: {
    scheduled_transaction: {
      account_id: string;
      category_id: string;
      payee_name?: string;
      memo?: string;
      amount: number;
      date: string;
      frequency?: string;
    };
  },
  user: UserType
) => {
  const token = user?.ynab?.connection.accessToken;
  if (!token) {
    throw new Error("No token found");
  }

  // Custom REST call to create a scheduled transaction
  const url = `${YNAB_API_BASE_URL}/budgets/${budgetId}/scheduled_transactions`;

  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`YNAB API error: ${JSON.stringify(errorData)}`);
    }

    return await response.json();
  } catch (error) {
    console.error("Error creating scheduled transaction:", error);
    throw error;
  }
};

/**
 * Update a single transaction in YNAB
 */
export const updateTransaction = async (
  budgetId: string,
  transactionId: string,
  transactionData: {
    category_id?: string;
    payee_name?: string;
    memo?: string;
    approved?: boolean;
  },
  user: UserType
): Promise<ynab.TransactionDetail> => {
  const api = await getApi(user);
  const { data } = await api.transactions.updateTransaction(
    budgetId,
    transactionId,
    {
      transaction: transactionData,
    }
  );
  return data.transaction;
};

/**
 * Update multiple transactions in YNAB
 */
export const updateTransactions = async (
  budgetId: string,
  transactions: Array<{
    id: string;
    category_id?: string;
    payee_name?: string;
    memo?: string;
    approved?: boolean;
  }>,
  user: UserType
): Promise<ynab.TransactionDetail[]> => {
  const api = await getApi(user);
  const { data } = await api.transactions.updateTransactions(budgetId, {
    transactions: transactions,
  });
  return data.transactions || [];
};

export const deleteScheduledTransaction = async (
  budgetId: string,
  transactionId: string,
  user: UserType
) => {
  const token = user?.ynab?.connection.accessToken;
  if (!token) {
    throw new Error("No token found");
  }

  // Custom REST call to delete a scheduled transaction
  const url = `${YNAB_API_BASE_URL}/budgets/${budgetId}/scheduled_transactions/${transactionId}`;

  try {
    const response = await fetch(url, {
      method: "DELETE",
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/json",
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`YNAB API error: ${JSON.stringify(errorData)}`);
    }

    return await response.json();
  } catch (error) {
    console.error("Error deleting scheduled transaction:", error);
    throw error;
  }
};
</file>

<file path="packages/api/src/data/ynab/ynab.server.ts">
import { T, update } from "ramda";
import * as ynab from "ynab";
import {
  findBudgets,
  getBudgetWithoutUserCheck,
  saveNewBudget,
  updateBudget,
} from "../budget/budget.server";
import { UserType, clearYnabConnection } from "../user/user.server";
import * as ynabApi from "./ynab-api"; // Import the missing ynapApi module
import {
  deleteCategory,
  findCategories,
  getCategory,
  saveNewCategory,
  updateCategory,
} from "../category/category.server";
import { Budget, Category, CategoryTarget } from "common-ts";
import YnabBudget from "./ynab.schema";
import { updateTransactionsSpendingPattern } from "../forecasting/es-forcasting.server";
import { extractYearsFromTransactions } from "./transaction.util";
import { NewOrUpdatedTransaction } from "../transaction/transaction.server";
import * as transactionServer from "../transaction/transaction.server";
import {
  deleteAccount,
  getAccount,
  saveNewAccount,
  updateAccount,
} from "../accounts/account.server";
import { LocalAccountType } from "../accounts/account.schema";

type ServerKnowledge = {
  transactions: number;
  categories: number;
  accounts: number;
};

export const emptyServerKnowledge: ServerKnowledge = {
  transactions: 0,
  categories: 0,
  accounts: 0,
};

type YnabBudgetType = {
  serverKnowledge: ServerKnowledge;
};

const insertOrUpdateMissingTransaction = async (
  ynabTransaction: ynab.TransactionDetail,
  categories: Category[],
  budgetId: string
) => {
  // Log available fields for research
  console.log("YNAB Transaction fields:", Object.keys(ynabTransaction));
  console.log("Sample transaction:", JSON.stringify(ynabTransaction, null, 2));

  const categoryId = categories.find(
    (category) => category.uuid === ynabTransaction.category_id
  )?._id;
  const newData: NewOrUpdatedTransaction = {
    accountName: ynabTransaction.account_name,
    amount: ynabTransaction.amount,
    date: ynabTransaction.date,
    categoryId,
    payeeName: ynabTransaction.payee_name,
    memo: ynabTransaction.memo,
    import_payee_name_original: ynabTransaction.import_payee_name_original,
  };
  await transactionServer.insertOrUpdateMissingTransaction(
    ynabTransaction.id,
    ynabTransaction.deleted,
    budgetId,
    newData
  );
};

const transactionToInsertOrUpdatePromise =
  (budgetId: string, categories: Category[]) =>
  (transaction: ynab.TransactionDetail) =>
    insertOrUpdateMissingTransaction(transaction, categories, budgetId);

const insertOrUpdateMissingTransactions = async (
  budgetId: string,
  transactions: ynab.TransactionDetail[]
) => {
  try {
    console.log(
      `insert or update ${transactions.length} number of transactions`
    );
    const categories = await findCategories(budgetId);
    const promiseMapper = transactionToInsertOrUpdatePromise(
      budgetId,
      categories
    );
    await Promise.all(transactions.map(promiseMapper));
    if (transactions.length > 0) {
      const years = extractYearsFromTransactions(transactions);
      await Promise.all(
        years.map((year) => updateTransactionsSpendingPattern(budgetId, year))
      );
    }
  } catch (exception) {
    console.error(
      `Error while inserting or updating transactions: ${exception}`
    );
    throw new Error("Error while inserting or updating transactions");
  }
};

const updateUserServerKnowledge = async ({
  user,
  budget,
  type,
  knowledge,
}: {
  user: UserType;
  budget: Budget;
  type: "transactions" | "categories" | "accounts";
  knowledge: number;
}) => {
  console.log("updateUserServerKnowledge:", budget.name, type, knowledge);
  const ynabBudget = await YnabBudget.findOne({
    budgetId: budget._id,
    userId: user._id,
  });
  if (!ynabBudget) {
    const newYnabBudget = new YnabBudget({
      userId: user._id,
      budgetId: budget._id,
      serverKnowledge: {
        [type]: knowledge,
      },
    });
    await newYnabBudget.save();
    return;
  }
  const newServerKnowledge = {
    ...ynabBudget.serverKnowledge,
    [type]: knowledge,
  };
  await YnabBudget.updateOne(
    { _id: ynabBudget._id },
    { serverKnowledge: newServerKnowledge }
  ).exec();
};

const findYnabBudget = async (
  user: UserType,
  budget: Budget
): Promise<YnabBudgetType> => {
  const budgetData = await YnabBudget.findOne({
    budgetId: budget._id,
    userId: user._id,
  });
  return !budgetData
    ? { serverKnowledge: emptyServerKnowledge }
    : {
        serverKnowledge: {
          transactions: budgetData.serverKnowledge.transactions || 0,
          categories: budgetData.serverKnowledge.categories || 0,
          accounts: budgetData.serverKnowledge.accounts || 0,
        },
      };
};

const syncTransactions = async (user: UserType, budget: Budget) => {
  const ynabBudget = await findYnabBudget(user, budget);
  const ynabTransactions = await ynabApi.getTransactions(
    budget.uuid,
    ynabBudget.serverKnowledge.transactions,
    user
  );
  await insertOrUpdateMissingTransactions(
    budget._id || "",
    ynabTransactions.transactions
  );
  await updateUserServerKnowledge({
    user,
    budget,
    type: "transactions",
    knowledge: ynabTransactions.server_knowledge,
  });
};

const syncYnabBudget = async (
  user: UserType,
  ynabBudget: ynab.BudgetDetail
) => {
  console.log(
    `syncing budget with id: ${ynabBudget.id} and name: ${ynabBudget.name}`
  );
  const localBudget = await getBudgetWithoutUserCheck(ynabBudget.id);
  if (!localBudget) {
    await saveNewBudget(
      {
        uuid: ynabBudget.id,
        name: ynabBudget.name,
      },
      user
    );
  } else {
    await updateBudget(ynabBudget.id, ynabBudget.name, user);
  }
};

const syncBudgets = async (user: UserType) => {
  const ynabBudgets = await ynabApi.getBudgets(user);
  const promises = ynabBudgets.map((ynabBudget) =>
    syncYnabBudget(user, ynabBudget)
  );
  await Promise.all(promises);
};

const syncYnabCategory = async (
  ynabCategory: ynab.Category,
  budget: Budget
) => {
  if (ynabCategory.deleted) {
    await deleteCategory(ynabCategory.id);
    return;
  }
  const localCategory = await getCategory(ynabCategory.id);
  if (!localCategory) {
    await saveNewCategory(mapCategory(ynabCategory, budget));
  } else {
    await updateCategory(mapCategory(ynabCategory, budget, localCategory._id));
  }
};
const syncYnabCategories = async (user: UserType, budget: Budget) => {
  const ynabBudget = await findYnabBudget(user, budget);
  const ynabCategoriesData = await ynabApi.getCategories(
    budget.uuid,
    ynabBudget.serverKnowledge.categories,
    user
  );
  const promises = ynabCategoriesData.categories.map((ynabCategory) =>
    syncYnabCategory(ynabCategory, budget)
  );
  await Promise.all(promises);
  // for now set knowledge to 0 to have the latest categories all the time (keeps
  // we noticed otherwise that properties as activity, balance are not updated correctly)
  await updateUserServerKnowledge({
    user,
    budget,
    type: "categories",
    knowledge: 0,
  });
};

const mapAccount = (
  ynabAccount: ynab.Account,
  budget: Budget,
  _id?: string
): LocalAccountType => ({
  uuid: ynabAccount.id,
  name: ynabAccount.name,
  balance: ynabAccount.balance,
  cleared_balance: ynabAccount.cleared_balance,
  uncleared_balance: ynabAccount.uncleared_balance,
  budgetId: budget._id || "",
  _id,
});

const syncYnabAccount = async (ynabAccount: ynab.Account, budget: Budget) => {
  if (ynabAccount.deleted) {
    await deleteAccount(ynabAccount.id);
    return;
  }
  const localAccount = await getAccount(ynabAccount.id);
  if (!localAccount) {
    await saveNewAccount(mapAccount(ynabAccount, budget));
  } else {
    await updateAccount(mapAccount(ynabAccount, budget, localAccount._id));
  }
};

const syncYnabAccounts = async (user: UserType, budget: Budget) => {
  const ynabBudget = await findYnabBudget(user, budget);
  const ynabAccountsData = await ynabApi.getAccounts(
    budget.uuid,
    ynabBudget.serverKnowledge.accounts,
    user
  );
  console.log(`syncing ${ynabAccountsData?.accounts?.length} accounts`);
  const promises = ynabAccountsData.accounts.map((ynabAccount) =>
    syncYnabAccount(ynabAccount, budget)
  );
  await Promise.all(promises);
  // for now set knowledge to 0 to have the latest categories all the time (keeps
  // we noticed otherwise that properties as activity, balance are not updated correctly)
  await updateUserServerKnowledge({
    user,
    budget,
    type: "accounts",
    knowledge: ynabAccountsData.knowledge,
  });
};
const syncCategories = async (user: UserType) => {
  const budgets = await findBudgets(user);
  console.log(`syncing categories for ${budgets.length} budgets`);
  const promises = budgets.map((budget) => syncYnabCategories(user, budget));
  await Promise.all(promises);
};

const mapCategory = (
  ynabCategory: ynab.Category,
  budget: Budget,
  _id?: string
): Category => ({
  uuid: ynabCategory.id,
  name: ynabCategory.name,
  budgetId: budget._id || "",
  balance: ynabCategory.balance,
  targetAmount: ynabCategory.goal_target || 0,
  budgeted: ynabCategory.budgeted,
  activity: ynabCategory.activity,
  historicalAverage: 0,
  typicalSpendingPattern: 0,
  _id,
  target: mapTarget(ynabCategory),
});

const mapTarget = (ynabCategory: ynab.Category): CategoryTarget | null => {
  if (!ynabCategory.goal_type) return null; // Only map if goal_type is set

  return {
    goal_type: ynabCategory.goal_type,
    goal_day: ynabCategory.goal_day ?? null,
    goal_cadence: ynabCategory.goal_cadence ?? null,
    goal_cadence_frequency: ynabCategory.goal_cadence_frequency ?? null,
    goal_creation_month: ynabCategory.goal_creation_month ?? null,
    goal_target: ynabCategory.goal_target ?? null,
    goal_target_month: ynabCategory.goal_target_month ?? null,
    goal_percentage_complete: ynabCategory.goal_percentage_complete ?? null,
    goal_months_to_budget: ynabCategory.goal_months_to_budget ?? null,
    goal_under_funded: ynabCategory.goal_under_funded ?? null,
    goal_overall_funded: ynabCategory.goal_overall_funded ?? null,
    goal_overall_left: ynabCategory.goal_overall_left ?? null,
  };
};
const toTransactionsSyncPromise = (user: UserType) => (budget: Budget) =>
  syncTransactions(user, budget);

const syncAllTransactions = async (user: UserType) => {
  console.log("syncing all transactions for user:" + user.authId);
  const localBudgets = await findBudgets(user);
  const promises = localBudgets.map(toTransactionsSyncPromise(user));
  await Promise.all(promises);
};

const syncAccounts = async (user: UserType) => {
  console.log("syncing accounts for user:" + user.authId);
  const localBudgets = await findBudgets(user);
  const promises = localBudgets.map((budget) => syncYnabAccounts(user, budget));
  await Promise.all(promises);
};

export const syncYnabUser = async (user: UserType) => {
  console.log(`syncing Ynab data for user with id: ${user.authId}`);
  try {
    await ynabApi.refreshUserToken(user);
  } catch (e) {
    await clearYnabConnection(user);
  }
  await syncBudgets(user);
  await syncCategories(user);
  await syncAllTransactions(user);
  await syncAccounts(user);
};

export const updateScheduledTransaction = async (
  user: UserType,
  budgetId: string,
  transactionId: string,
  updates: {
    amount?: number;
    categoryId?: string;
    date?: string;
    payeeName?: string;
    memo?: string;
    accountId?: string;
  }
) => {
  try {
    const response = await ynabApi.updateScheduledTransaction(
      budgetId,
      transactionId,
      {
        scheduled_transaction: {
          amount: updates.amount ? updates.amount * 1000 : undefined, // Convert to milliunits
          category_id: updates.categoryId,
          date: updates.date,
          payee_name: updates.payeeName,
          memo: updates.memo,
          account_id: updates.accountId,
        },
      },
      user
    );
    return response.data.scheduled_transaction;
  } catch (error) {
    console.error("Failed to update scheduled transaction:", error);
    throw error;
  }
};

export const getScheduledTransactions = async (
  user: UserType,
  budgetId: string
) => {
  try {
    return await ynabApi.getScheduledTransactions(budgetId, user);
  } catch (error) {
    console.error("Failed to get scheduled transactions:", error);
    throw error;
  }
};

export const createScheduledTransaction = async (
  user: UserType,
  budgetId: string,
  transactionData: {
    amount: number;
    categoryId: string;
    date: string;
    payeeName?: string;
    memo?: string;
    accountId: string;
  }
) => {
  try {
    const response = await ynabApi.createScheduledTransaction(
      budgetId,
      {
        scheduled_transaction: {
          account_id: transactionData.accountId,
          category_id: transactionData.categoryId,
          payee_name: transactionData.payeeName,
          memo: transactionData.memo,
          amount: transactionData.amount * 1000, // Convert to milliunits
          date: transactionData.date,
          frequency: 'never', // One-time transaction (not recurring)
        },
      },
      user
    );
    return response.data.scheduled_transaction;
  } catch (error) {
    console.error("Failed to create scheduled transaction:", error);
    throw error;
  }
};



export const deleteScheduledTransaction = async (
  user: UserType,
  budgetId: string,
  transactionId: string
) => {
  try {
    await ynabApi.deleteScheduledTransaction(budgetId, transactionId, user);
  } catch (error) {
    console.error("Failed to delete scheduled transaction:", error);
    throw error;
  }
};
</file>

<file path="packages/api/src/routes/simulation.routes.ts">
import { Router } from 'express';
import { SimulationController } from '../controllers/simulation.controller';
import { handleRequest } from '../controllers/utils';

const router = Router();
const controller = new SimulationController();

router.get('/budget/:budgetUuid', handleRequest(controller.getSimulations.bind(controller)));
router.post('/budget/:budgetUuid', handleRequest(controller.createSimulation.bind(controller)));
router.put('/:id/active', handleRequest(controller.toggleSimulation.bind(controller)));
router.put('/:id', handleRequest(controller.updateSimulation.bind(controller)));
router.delete('/:id', handleRequest(controller.deleteSimulation.bind(controller)));

export default router;
</file>

<file path="packages/mathapi/app/app.py">
import os
import itertools
from flask import Flask, jsonify, request, render_template
from .ynab_api import get_scheduled_transactions
from .categories_api import get_categories_for_budget
from .budget_api import get_objectid_for_budget
from .accounts_api import get_accounts_for_budget
from .prediction_api import project_daily_balances_with_reasons
import logging
import json
from flask_cors import CORS
from dotenv import load_dotenv
from app.auth import requires_auth
from app.models import get_user_from_request, get_budget

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# Setup CORS
CORS_ORIGINS = os.getenv('CORS_ORIGINS', 'http://localhost:3000').split(',')
CORS(app, resources={
    r"/*": {
        "origins": CORS_ORIGINS,
        "methods": ["GET", "POST", "PUT", "OPTIONS"],
        "allow_headers": ["Authorization", "Content-Type"],
        "supports_credentials": True
    }
})

def load_simulations_folder(folder_name="simulations"):
    """Load all simulations from a folder containing JSON files."""
    base_dir = os.path.dirname(os.path.abspath(__file__))
    folder_path = os.path.join(base_dir, folder_name)

    simulations = {"Actual Balance": None}  # Treat the baseline as a default simulation
    if not os.path.exists(folder_path):
        logging.warning(f"Simulation folder not found: {folder_path}")
        return simulations

    for file_name in os.listdir(folder_path):
        if file_name.endswith('.json'):
            file_path = os.path.join(folder_path, file_name)
            try:
                with open(file_path, "r") as file:
                    simulations[file_name] = json.load(file)
            except Exception as e:
                logging.warning(f"Failed to load simulation file {file_name}: {str(e)}")
    return simulations

def generate_unique_colors():
    """Generate unique colors for the plots."""
    colors = itertools.cycle(["red", "green", "blue", "purple", "orange", "cyan", "magenta"])
    yield "black"  # First color for the baseline
    for color in colors:
        yield color

@app.route('/balance-prediction/interactive', methods=['GET'])
def balance_prediction_interactive():
    # Step 1: Get `budget_id` from query parameters
    budget_uuid = request.args.get('budget_id')
    if not budget_uuid:
        return "budget_id query parameter is required", 400

    # Step 2: Load simulations from folder
    simulations = load_simulations_folder()
    # Handle optional days_ahead parameter
    days_ahead_param = request.args.get('days_ahead')
    try:
        days_ahead = int(days_ahead_param) if days_ahead_param is not None else 300
    except ValueError:
        return "Invalid days_ahead query parameter, it must be an integer.", 400

    # Step 3: Fetch required data
    try:
        budget_id = get_objectid_for_budget(budget_uuid)
        future_transactions = get_scheduled_transactions(budget_uuid)
        categories = get_categories_for_budget(budget_id)
        accounts = get_accounts_for_budget(budget_id)
    except Exception as e:
        return f"Error fetching data: {str(e)}", 500

    # Step 4: Generate plot data for the baseline and all simulations
    plot_data = []
    color_generator = generate_unique_colors()
    for simulation_name, simulation_data in simulations.items():
        try:
            # Get projected balances with raw numeric data
            projected_balances = project_daily_balances_with_reasons(
                accounts, categories, future_transactions, days_ahead, simulation_data
            )
        except Exception as e:
            logging.warning(f"Error processing simulation '{simulation_name}': {str(e)}")
            continue

        # Prepare data for the plot
        dates = list(projected_balances.keys())
        balances = [projected_balances[date]["balance"] for date in dates]  # Raw numbers
        hover_texts = []

        # Calculate hover text for each date
        for i, date in enumerate(dates):
            day_data = projected_balances[date]
            balance = day_data["balance"]  # Raw balance
            balance_diff = day_data.get("balance_diff", 0)  # Raw difference
            changes = day_data["changes"]

            # Format numbers for presentation
            hover_text = f"Date: {date}<br>Balance: {balance:.2f}<br>Balance Difference: {balance_diff:.2f}"
            if changes:
                hover_text += "<br>Changes:"
                for change in changes:
                    amount = change["amount"]  # Raw amount
                    if amount == 0:  # Skip zero-value changes
                        continue
                    simulation_flag = "(Simulation)" if change.get("is_simulation", False) else ""
                    hover_text += f"<br>{amount:.2f} ({change['category']} - {change['reason']}) {simulation_flag}"
            hover_texts.append(hover_text)

        # Add the line to the plot
        plot_data.append({
            "x": dates,
            "y": balances,
            "type": "scatter",
            "mode": "lines+markers",
            "name": simulation_name,
            "text": hover_texts,
            "hoverinfo": "text",
            "marker": {"color": next(color_generator)}
        })

    # Convert plot data to JSON for the template
    sanitized_plot_data = json.dumps(plot_data)

    # Render HTML template with plot data
    return render_template('balance_projection.html', plot_data=sanitized_plot_data)

@app.route('/balance-prediction/data')
@requires_auth
def get_prediction():
    """Get balance prediction for a budget."""
    try:
        user = get_user_from_request(request)
        if not user:
            return jsonify({"message": "User not found"}), 401

        budget_uuid = request.args.get('budget_id')
        if not budget_uuid:
            return jsonify({"message": "No budget_id provided"}), 400

        days_ahead = int(request.args.get('days_ahead', 300))

        # First get the MongoDB ObjectId for the budget
        budget_id = get_objectid_for_budget(budget_uuid)
        if not budget_id:
            return jsonify({"message": "Budget not found"}), 404

        # Then get the full budget document and verify ownership
        budget = get_budget(budget_uuid, user)
        if not budget:
            return jsonify({"message": "Budget not found or access denied"}), 404

        # Get YNAB connection details
        ynab_connection = user.get('ynab', {}).get('connection', {})
        if not ynab_connection:
            return jsonify({"message": "No YNAB connection"}), 400

        # Load simulations
        simulations = load_simulations_folder()

        # Fetch required data
        future_transactions = get_scheduled_transactions(budget_uuid)
        categories = get_categories_for_budget(budget_id)
        accounts = get_accounts_for_budget(budget_id)

        # Process each simulation and collect results
        results = {}
        for simulation_name, simulation_data in simulations.items():
            try:
                projected_balances = project_daily_balances_with_reasons(
                    accounts, categories, future_transactions, days_ahead, simulation_data
                )
                results[simulation_name] = projected_balances
            except Exception as e:
                logger.warning(f"Error processing simulation '{simulation_name}': {str(e)}")
                continue

        return jsonify(results)

    except ValueError as e:
        logger.warning(f"Invalid input: {str(e)}")
        return jsonify({"message": str(e)}), 400
    except Exception as e:
        logger.error(f"Error generating prediction: {str(e)}")
        return jsonify({"message": "Internal server error"}), 500

@app.route('/health')
def health_check():
    """Health check endpoint."""
    return jsonify({"status": "healthy"})

# Scheduled transactions endpoint migrated to Node.js API

# Uncategorized and unapproved transactions endpoints migrated to Node.js API

# Suggest categories endpoint migrated to Node.js API

# Apply categories endpoints migrated to Node.js API

# Batch and smart endpoints removed - not used by frontend

# Payee mappings are now internal-only (used by AI service, no public endpoints)

# Country configuration is now internal-only (used by payee mappings, no public endpoints)

# AI suggestions, apply, and approval endpoints migrated to Node.js API

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=True)
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/actions.ts">
'use server';

import { revalidatePath } from "next/cache";
import { apiGet, apiPost, apiPut, apiDelete } from "@/app/api/client";

export interface CategoryChange {
    categoryUuid: string;
    startDate?: string;
    endDate?: string;
    targetAmount: number;
}

export interface Simulation {
    _id: string;
    budgetUuid: string;
    name: string;
    isActive: boolean;
    categoryChanges: CategoryChange[];
}

export async function getSimulations(budgetUuid: string): Promise<Simulation[]> {
    return apiGet(`/simulations/budget/${budgetUuid}`);
}

export async function createSimulation(data: {
    budgetUuid: string;
    name: string;
    categoryChanges: CategoryChange[];
}): Promise<Simulation> {
    const simulation = await apiPost(`/simulations/budget/${data.budgetUuid}`, {
        name: data.name,
        categoryChanges: data.categoryChanges
    });
    
    // Invalidate the cache for the predictions page
    revalidatePath('/budgets/[budgetUuid]/predictions');

    return simulation;
}

export async function toggleSimulation(id: string): Promise<Simulation> {
    const simulation = await apiPut(`/simulations/${id}/active`, {});
    
    // Invalidate the cache for the predictions page
    revalidatePath(`/budgets/${simulation.budgetUuid}/predictions`);

    return simulation;
}

export async function updateSimulation(id: string, data: {
    budgetUuid: string;
    name: string;
    categoryChanges: CategoryChange[];
}): Promise<Simulation> {
    const simulation = await apiPut(`/simulations/${id}`, {
        name: data.name,
        categoryChanges: data.categoryChanges
    });

    // Invalidate the cache for the predictions page
    revalidatePath(`/budgets/${data.budgetUuid}/predictions`);

    return simulation;
}

export async function deleteSimulation(id: string): Promise<void> {
    await apiDelete(`/simulations/${id}`);
    
    // Invalidate the cache for the predictions page
    revalidatePath('/budgets/[budgetUuid]/predictions');
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/InteractiveSimulations.tsx">
'use client';

import { useState } from 'react';
import { useParams } from 'next/navigation';
import { Button } from '@/components/ui/button';
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
} from '@/components/ui/dialog';
import { toast } from 'sonner';
import { SimulationForm } from './SimulationForm';
import { CategoryChangesForm } from './CategoryChangesForm';
import { SimulationList } from './SimulationList';
import { createSimulation, updateSimulation, type CategoryChange, type Simulation } from './actions';

interface InteractiveSimulationsProps {
    categoryOptions: { uuid: string; name: string; }[];
    initialSimulations: Simulation[];
}

export default function InteractiveSimulations({
    categoryOptions,
    initialSimulations
}: InteractiveSimulationsProps) {
    const [isCreateModalOpen, setCreateModalOpen] = useState(false);
    const [isEditModalOpen, setEditModalOpen] = useState(false);
    const [selectedSimulation, setSelectedSimulation] = useState<Simulation | null>(null);
    const [simulations, setSimulations] = useState<Simulation[]>(initialSimulations);
    const params = useParams();
    const budgetUuid = params.budgetUuid as string;

    const handleCreateSimulation = async (formData: { name: string }) => {
        try {
            const newSimulation = await createSimulation({
                budgetUuid,
                name: formData.name,
                categoryChanges: []
            });

            setSimulations([...simulations, newSimulation]);
            setCreateModalOpen(false);
            setSelectedSimulation(newSimulation);
            setEditModalOpen(true);
            toast.success("Simulation created successfully");
        } catch (error) {
            console.error('Error creating simulation:', error);
            toast.error("Failed to create simulation");
        }
    };

    const handleUpdateCategoryChanges = async (changes: CategoryChange[]) => {
        if (!selectedSimulation) {
            console.log('No selected simulation to update.');
            return;
        }

        console.log('Updating category changes for simulation:', selectedSimulation);

        try {
            const updatedSimulation = await updateSimulation(selectedSimulation._id, {
                budgetUuid,
                name: selectedSimulation.name,
                categoryChanges: changes
            });

            setSimulations(simulations.map(sim =>
                sim._id === selectedSimulation._id ? updatedSimulation : sim
            ));
            setEditModalOpen(false);
            toast.success("Category changes updated successfully");
        } catch (error) {
            console.error('Error updating category changes:', error);
            toast.error("Failed to update category changes");
        }
    };

    const handleEditSimulation = (simulation: Simulation) => {
        console.log('Editing simulation:', simulation);
        setSelectedSimulation(simulation);
        setEditModalOpen(true);
    };

    return (
        <div className="flex flex-col">
            <h2 className="text-lg font-semibold mb-4">Simulations</h2>
            <Button
                onClick={() => setCreateModalOpen(true)}
                className="w-full mb-4"
                variant="outline"
            >
                New Simulation
            </Button>

            <div className="flex-grow">
                <SimulationList
                    onNewClick={() => setCreateModalOpen(true)}
                    initialSimulations={simulations}
                    onEditSimulation={handleEditSimulation}
                />
            </div>

            <Dialog open={isCreateModalOpen} onOpenChange={setCreateModalOpen}>
                <DialogContent>
                    <DialogHeader>
                        <DialogTitle>Create New Simulation</DialogTitle>
                    </DialogHeader>
                    <SimulationForm
                        onSubmit={handleCreateSimulation}
                        onCancel={() => setCreateModalOpen(false)}
                    />
                </DialogContent>
            </Dialog>

            <Dialog open={isEditModalOpen} onOpenChange={setEditModalOpen}>
                <DialogContent className="max-h-[90vh] overflow-y-auto">
                    <DialogHeader>
                        <DialogTitle>Edit Category Changes</DialogTitle>
                    </DialogHeader>
                    {selectedSimulation && (
                        <CategoryChangesForm
                            categories={categoryOptions}
                            initialChanges={selectedSimulation.categoryChanges}
                            onSubmit={handleUpdateCategoryChanges}
                            onCancel={() => setEditModalOpen(false)}
                        />
                    )}
                </DialogContent>
            </Dialog>
        </div>
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/SimulationForm.tsx">
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { ChangeEvent } from 'react';

interface SimulationFormProps {
    onSubmit: (data: { name: string }) => void;
    onCancel: () => void;
}

export function SimulationForm({ onSubmit, onCancel }: SimulationFormProps) {
    const [name, setName] = useState('');

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        if (!name) {
            // TODO: Show error message
            return;
        }

        onSubmit({ name });
    };

    return (
        <form onSubmit={handleSubmit} className="space-y-4">
            <div>
                <Label htmlFor="name">Simulation Name</Label>
                <Input
                    id="name"
                    value={name}
                    onChange={(e: ChangeEvent<HTMLInputElement>) => setName(e.target.value)}
                    placeholder="e.g., Less Restaurants"
                    required
                />
            </div>

            <div className="flex justify-end space-x-2">
                <Button type="button" variant="outline" onClick={onCancel}>
                    Cancel
                </Button>
                <Button type="submit">
                    Create Simulation
                </Button>
            </div>
        </form>
    );
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/SimulationList.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Switch } from '@/components/ui/switch';
import { Button } from '@/components/ui/button';
import { Pencil, Trash2 } from 'lucide-react';
import { toggleSimulation, deleteSimulation, type Simulation } from './actions';
import { toast } from 'sonner';

interface SimulationListProps {
    onNewClick: () => void;
    initialSimulations: Simulation[];
    onEditSimulation: (simulation: Simulation) => void;
}

export function SimulationList({ onNewClick, initialSimulations, onEditSimulation }: SimulationListProps) {
    const [simulations, setSimulations] = useState<Simulation[]>(initialSimulations);

    useEffect(() => {
        setSimulations(initialSimulations);
    }, [initialSimulations]);

    useEffect(() => {
        console.log('Initial simulations:', initialSimulations);
    }, [initialSimulations]);

    const handleToggleSimulation = async (simulation: Simulation) => {
        console.log('Toggling simulation:', simulation);
        console.log('Simulation _id:', simulation._id);

        if (!simulation._id) {
            console.error('No simulation id found');
            toast.error("Failed to toggle simulation: No simulation id found");
            return;
        }

        try {
            console.log('Calling toggleSimulation with id:', simulation._id);
            const updatedSimulation = await toggleSimulation(simulation._id);
            console.log('Received updated simulation:', updatedSimulation);

            setSimulations(simulations.map(sim =>
                sim._id === simulation._id ? updatedSimulation : sim
            ));
            toast.success("Simulation toggled successfully");
        } catch (error) {
            console.error('Error toggling simulation:', error);
            toast.error("Failed to toggle simulation");
        }
    };

    const handleDeleteSimulation = async (simulation: Simulation) => {
        if (!simulation._id) {
            console.error('No simulation id found');
            toast.error("Failed to delete simulation: No simulation id found");
            return;
        }

        try {
            await deleteSimulation(simulation._id);
            setSimulations(simulations.filter(sim => sim._id !== simulation._id));
            toast.success("Simulation deleted successfully");
        } catch (error) {
            console.error('Error deleting simulation:', error);
            toast.error("Failed to delete simulation");
        }
    };

    return (
        <div className="space-y-4">
            <div className="space-y-2">
                {simulations.length === 0 ? (
                    <p className="text-gray-500">No simulations yet. Create one to get started!</p>
                ) : (
                    simulations.map((simulation) => (
                        <div
                            key={simulation._id}
                            className="flex items-center justify-between p-3 border rounded-lg"
                        >
                            <div className="flex-grow">
                                <div className="flex items-center justify-between">
                                    <h3 className="font-medium">{simulation.name}</h3>
                                    <div className="flex items-center space-x-2">
                                        <Button
                                            variant="ghost"
                                            size="icon"
                                            onClick={() => onEditSimulation(simulation)}
                                        >
                                            <Pencil className="h-4 w-4" />
                                        </Button>
                                        <Button
                                            variant="ghost"
                                            size="icon"
                                            onClick={() => handleDeleteSimulation(simulation)}
                                        >
                                            <Trash2 className="h-4 w-4" />
                                        </Button>
                                    </div>
                                </div>
                                <p className="text-sm text-gray-500">
                                    {simulation.categoryChanges.length} category changes
                                </p>
                            </div>
                            <Switch
                                checked={simulation.isActive}
                                onCheckedChange={() => handleToggleSimulation(simulation)}
                            />
                        </div>
                    ))
                )}
            </div>
        </div>
    );
}
</file>

<file path="packages/api/src/controllers/simulation.controller.ts">
import { Request, Response } from 'express';
import { getUserFromReq } from './utils';
import { findSimulationsForBudget, createSimulation, toggleSimulation, updateSimulation as updateSimulationInDb, deleteSimulation as deleteSimulationInDb } from '../data/simulation/simulation.server';
import { getBudget } from '../data/budget/budget.server';
import { getCategory } from '../data/category/category.server';

export class SimulationController {
  async getSimulations(req: Request, res: Response) {
    const { budgetUuid } = req.params;
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const budget = await getBudget(budgetUuid, user);
    if (!budget) {
      return res.status(404).json({ error: 'Budget not found' });
    }

    const simulations = await findSimulationsForBudget(budget._id);
    res.json(simulations);
  }

  async createSimulation(req: Request, res: Response) {
    const { budgetUuid } = req.params;
    const { name, categoryChanges } = req.body;
    console.log('Creating simulation:', { budgetUuid, body: req.body });
    const user = await getUserFromReq(req);
    if (!user) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    if (!name || !categoryChanges || !Array.isArray(categoryChanges)) {
      console.log('Validation error: missing name or categoryChanges', { name, categoryChanges });
      return res.status(400).json({ error: 'Name and categoryChanges array are required' });
    }

    // Validate each category change and get category IDs
    const validatedChanges = await Promise.all(categoryChanges.map(async (change) => {
      if (!change.categoryUuid) {
        console.log('Validation error: missing categoryUuid', { change });
        throw new Error('categoryUuid is required for each change');
      }
      if (!change.targetAmount) {
        console.log('Validation error: missing targetAmount', { change });
        throw new Error('targetAmount is required for each change');
      }

      const category = await getCategory(change.categoryUuid);
      if (!category) {
        console.log('Validation error: category not found', { categoryUuid: change.categoryUuid });
        throw new Error(`Category not found for uuid: ${change.categoryUuid}`);
      }

      return {
        categoryUuid: change.categoryUuid,
        targetAmount: change.targetAmount,
        startDate: change.startDate ? new Date(change.startDate) : undefined,
        endDate: change.endDate ? new Date(change.endDate) : undefined
      };
    }));

    const simulation = await createSimulation(budgetUuid, user, {
      name,
      categoryChanges: validatedChanges
    });

    res.status(201).json(simulation);
  }

  async toggleSimulation(req: Request, res: Response) {
    const { id } = req.params;
    const simulation = await toggleSimulation(id);
    res.json(simulation);
  }

  async updateSimulation(req: Request, res: Response) {
    const { id } = req.params;
    const { name, categoryChanges } = req.body;
    console.log('Updating simulation:', { id, body: req.body });

    if (!name || !categoryChanges || !Array.isArray(categoryChanges)) {
      console.log('Validation error: missing name or categoryChanges', { name, categoryChanges });
      return res.status(400).json({ error: 'Name and categoryChanges array are required' });
    }

    // Validate each category change and get category IDs
    const validatedChanges = await Promise.all(categoryChanges.map(async (change) => {
      if (!change.categoryUuid) {
        console.log('Validation error: missing categoryUuid', { change });
        throw new Error('categoryUuid is required for each change');
      }
      if (!change.targetAmount) {
        console.log('Validation error: missing targetAmount', { change });
        throw new Error('targetAmount is required for each change');
      }

      const category = await getCategory(change.categoryUuid);
      if (!category) {
        console.log('Validation error: category not found', { categoryUuid: change.categoryUuid });
        throw new Error(`Category not found for uuid: ${change.categoryUuid}`);
      }

      return {
        categoryUuid: change.categoryUuid,
        targetAmount: change.targetAmount,
        startDate: change.startDate ? new Date(change.startDate) : undefined,
        endDate: change.endDate ? new Date(change.endDate) : undefined
      };
    }));

    const simulation = await updateSimulationInDb(id, {
      name,
      categoryChanges: validatedChanges
    });

    res.json(simulation);
  }

  async deleteSimulation(req: Request, res: Response) {
    const { id } = req.params;
    console.log('Deleting simulation:', id);
    const simulation = await deleteSimulationInDb(id);
    res.json(simulation);
  }
}
</file>

<file path="packages/mathapi/readme.md">
# Math API

This API provides mathematical calculations and predictions for budgeting purposes.

## Installation

1. Create and activate virtual environment:
```bash
python -m venv venv
source venv/bin/activate
```

2. Install dependencies:
```bash
pip install -r requirements.txt
```

## Running the API

1. Set environment variables:
```bash
export FLASK_APP=app/app.py
export FLASK_ENV=development
```

2. Start the server:
```bash
flask run
```

## API Endpoints

### Balance Predictions

### Interactive

http://127.0.0.1:5000/balance-prediction/interactive?budget_id=1b443ebf-ea07-4ab7-8fd5-9330bf80608c&days_ahead=120

### non interactive json

http://127.0.0.1:5000/balance-prediction/data?budget_id=1b443ebf-ea07-4ab7-8fd5-9330bf80608c&days_ahead=120

## sheduled transactions

http://127.0.0.1:5000/sheduled-transactions?budget_id=1b443ebf-ea07-4ab7-8fd5-9330bf80608c

# category suggestions

http://127.0.0.1:5000/uncategorised-transactions/suggest-categories?budget_id=1b443ebf-ea07-4ab7-8fd5-9330bf80608c

# apply suggestions

POST http://127.0.0.1:5000/uncategorised-transactions/apply-categories?budget_id=1b443ebf-ea07-4ab7-8fd5-9330bf80608c

# Math API

This API provides mathematical calculations and predictions for budgeting purposes.

## Installation

```bash
pip install -r requirements.txt
```

## Running Tests

To run all tests:
```bash
PYTHONPATH=. python -m pytest
```

### Test Fixtures

The tests use fixtures stored in `app/tests/fixtures/`:
- `input_data.json`: Contains test data (categories, accounts, scheduled transactions)
- `expected_output.json`: Contains expected prediction results

To update the test fixtures with real data:
```bash
# Make sure you're in the mathapi directory
cd packages/mathapi

# Record new fixtures (this will use real API data)
PYTHONPATH=. RECORD_FIXTURES=1 python -m pytest app/tests/test_prediction_api.py::TestPredictionApi::test_record_new_fixtures -v

# Verify the tests pass with new fixtures
PYTHONPATH=. python -m pytest app/tests/test_prediction_api.py -v
```

Note: Recording new fixtures will use real data from your YNAB budget and MongoDB database. Make sure your `.env` file is properly configured.

## Testing

### Running Tests
To run the tests:
```bash
python -m pytest tests/
```

To run tests with verbose output:
```bash
python -m pytest tests/ -v
```

### Code Coverage
You can check the code coverage in different ways:

1. Terminal output with missing lines:
```bash
python -m pytest tests/ --cov=app --cov-report=term-missing -v
```

2. Generate an HTML report (recommended for detailed analysis):
```bash
python -m pytest tests/ --cov=app --cov-report=html
```
The report will be generated in the `htmlcov` directory. Open `htmlcov/index.html` in your browser to view it.

3. Generate an XML report (useful for CI/CD):
```bash
python -m pytest tests/ --cov=app --cov-report=xml
```

You can also run tests for specific functions:
```bash
python -m pytest tests/ -k "test_function_name"
```

Or show only missing coverage:
```bash
python -m pytest tests/ --cov=app --cov-report=term-missing:skip-covered
```
</file>

<file path="packages/mathapi/requirements.txt">
Flask>=2.2.2
Werkzeug>=2.2.2
requests
python-dotenv==0.19.0
pymongo==4.6.3
dnspython  # Required if you're using MongoDB Atlas or a connection string with DNS
openai>=1.58.1
flask-cors>=4.0.0
PyJWT>=2.8.0
pytest==6.2.5
pytest-cov>=3.0.0
cryptography==44.0.1
playwright>=1.42.0
fuzzywuzzy>=0.18.0
python-Levenshtein>=0.12.0  # Optional but recommended for better performance with fuzzywuzzy
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/FutureChangesTable.tsx">
"use client";

import { useState } from 'react';
import { FiEdit2, FiTrash2, FiPlus } from 'react-icons/fi';
import { updateScheduledTransaction, deleteScheduledTransaction, createScheduledTransaction, ScheduledTransactionUpdate, ScheduledTransactionCreate } from '../../../api/scheduledTransactions.client';
import { Category } from 'common-ts';
import { Account } from '../../../api/accounts.server';
import { EditTransactionDialog } from './EditTransactionDialog';

type Change = {
    amount: number;
    category: string;
    reason: string;
    is_simulation?: boolean;
    memo?: string;
    id?: string;
    account?: string;
    payee?: string;
};

type DayData = {
    balance: number;
    balance_diff: number;
    changes: Change[];
};

type SimulationData = {
    [date: string]: DayData;
};

type PredictionData = {
    [simulationName: string]: SimulationData;
};

type DayChanges = {
    date: string;
    balance: number;
    balance_diff: number;
    changes: Change[];
};

type Props = {
    predictionData: PredictionData;
    budgetUuid: string;
    categories: Category[];
    accounts: Account[];
};

export const FutureChangesTable = ({ predictionData, budgetUuid, categories, accounts }: Props) => {
    const [editingTransaction, setEditingTransaction] = useState<string | null>(null);
    const [selectedTransaction, setSelectedTransaction] = useState<{
        amount: number;
        categoryId: string;
        date: string;
        payeeName?: string;
        memo?: string;
        accountId?: string;
    } | undefined>(undefined);
    const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);

    const handleEdit = async (transactionId: string, updates: ScheduledTransactionUpdate) => {
        if (!transactionId) return;
        try {
            await updateScheduledTransaction(budgetUuid, transactionId, updates);
            // TODO: Add toast notification
            setEditingTransaction(null);
            setSelectedTransaction(undefined);
        } catch (error) {
            console.error('Failed to update transaction:', error);
            // TODO: Add error toast
        }
    };

    const handleDelete = async (transactionId: string) => {
        if (!transactionId) return;
        try {
            await deleteScheduledTransaction(budgetUuid, transactionId);
            // TODO: Add toast notification
            setEditingTransaction(null);
            setSelectedTransaction(undefined);
        } catch (error) {
            console.error('Failed to delete transaction:', error);
            // TODO: Add error toast
        }
    };

    const handleCreate = async (data: ScheduledTransactionCreate) => {
        try {
            await createScheduledTransaction(budgetUuid, data);
            // TODO: Add toast notification
            setIsCreateDialogOpen(false);
            // Refresh the data by calling the parent's onUpdate if available
            // For now, we'll just close the dialog
        } catch (error) {
            console.error('Failed to create transaction:', error);
            // TODO: Add error toast
            throw error; // Re-throw to let the dialog handle the error
        }
    };

    // Process the data
    const simulations = Object.keys(predictionData);
    const selectedSimulation = "Actual Balance"; // We can make this configurable later if needed
    const selectedData = predictionData[selectedSimulation];
    const changes: DayChanges[] = [];

    if (selectedData) {
        Object.entries(selectedData).forEach(([date, dayData]) => {
            if (dayData.changes && dayData.changes.length > 0) {
                changes.push({
                    date,
                    balance: dayData.balance,
                    balance_diff: dayData.balance_diff,
                    changes: dayData.changes
                });
            }
        });
    }

    // Sort by date
    changes.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    const formatSimulationName = (name: string) => {
        if (name === "Actual Balance") return name;
        return name.replace(".json", "").split("_").map(word =>
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(" ");
    };

    const handleDialogSave = async (updates: ScheduledTransactionUpdate) => {
        if (!editingTransaction) return;
        await handleEdit(editingTransaction, updates);
    };

    const handleEditClick = (change: Change, date: string) => {
        console.log('Edit clicked:', { change, date });
        if (!change.id) {
            console.log('No transaction ID found');
            return;
        }

        // Find the category ID based on the category name
        const categoryId = categories.find(cat => cat.name === change.category)?.uuid;

        setEditingTransaction(change.id);
        // Find account based on change.account if available
        const accountId = change.account ? accounts.find(acc => acc.name === change.account)?.uuid : undefined;

        setSelectedTransaction({
            amount: change.amount,
            categoryId: categoryId || '',
            date: date,
            payeeName: change.payee || '',
            memo: change.memo || '',
            accountId: accountId || ''
        });
    };

    return (
        <div className="space-y-4">
            <div className="flex justify-between items-center">
                <div className="tabs tabs-boxed justify-start">
                    {simulations.map((simulation) => (
                        <button
                            key={simulation}
                            className={`tab ${selectedSimulation === simulation ? 'tab-active' : ''}`}
                            disabled={simulation !== selectedSimulation}
                        >
                            {formatSimulationName(simulation)}
                        </button>
                    ))}
                </div>

                <button
                    onClick={() => setIsCreateDialogOpen(true)}
                    className="btn btn-primary btn-sm"
                >
                    <FiPlus className="h-4 w-4" />
                    Add Transaction
                </button>
            </div>

            {/* Mobile Card View */}
            <div className="block lg:hidden space-y-4">
                {changes.map((dayChange, dayIndex) => (
                    <div key={dayIndex} className="bg-white dark:bg-slate-900 rounded-xl shadow-sm border border-slate-200 dark:border-slate-700 overflow-hidden">
                        {/* Date Header */}
                        <div className="bg-gradient-to-r from-slate-50 to-gray-50 dark:from-slate-800 dark:to-gray-800 p-4 border-b border-slate-200 dark:border-slate-700">
                            <div className="flex justify-between items-center">
                                <h3 className="font-semibold text-lg">
                                    {new Date(dayChange.date).toLocaleDateString('en-US', {
                                        day: '2-digit',
                                        month: 'long',
                                        year: 'numeric'
                                    })}
                                </h3>
                                <div className="text-right">
                                    <div className="font-semibold">{dayChange.balance.toFixed(2)}</div>
                                    <div className={`text-sm ${dayChange.balance_diff >= 0 ? 'text-success' : 'text-error'}`}>
                                        {dayChange.balance_diff >= 0 ? '+' : ''}{dayChange.balance_diff.toFixed(2)}
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Changes */}
                        <div className="divide-y divide-slate-200 dark:divide-slate-700">
                            {dayChange.changes.map((change, changeIndex) => (
                                <div key={changeIndex} className="p-4">
                                    <div className="flex justify-between items-start gap-3">
                                        <div className="flex-1 min-w-0">
                                            <div className="flex items-center gap-2 mb-2">
                                                {change.is_simulation && (
                                                    <span className="badge badge-sm">Simulation</span>
                                                )}
                                                <span className="font-medium">{change.reason}</span>
                                            </div>

                                            {change.payee && (
                                                <div className="text-sm text-base-content/70 mb-1">{change.payee}</div>
                                            )}

                                            {change.memo && (
                                                <div className="text-sm text-base-content/70 mb-2">{change.memo}</div>
                                            )}

                                            <div className="text-sm text-base-content/80">{change.category}</div>
                                        </div>

                                        <div className="flex items-center gap-2">
                                            {change.reason === "Scheduled Transaction" && (
                                                <div className="flex items-center gap-1">
                                                    <button
                                                        onClick={() => {
                                                            console.log('Edit button clicked for:', change);
                                                            handleEditClick(change, dayChange.date);
                                                        }}
                                                        className="btn btn-ghost btn-xs"
                                                    >
                                                        <FiEdit2 className="h-4 w-4" />
                                                    </button>
                                                    <button
                                                        onClick={() => change.id && handleDelete(change.id)}
                                                        className="btn btn-ghost btn-xs text-error"
                                                    >
                                                        <FiTrash2 className="h-4 w-4" />
                                                    </button>
                                                </div>
                                            )}
                                            <div className={`text-right font-semibold ${change.amount >= 0 ? 'text-success' : 'text-error'}`}>
                                                {change.amount >= 0 ? '+' : ''}{change.amount.toFixed(2)}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                ))}
            </div>

            {/* Desktop Table View */}
            <div className="hidden lg:block overflow-x-auto">
                <table className="table table-zebra w-full">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Description</th>
                            <th>Category</th>
                            <th className="text-right">Amount</th>
                            <th className="text-right">Balance</th>
                        </tr>
                    </thead>
                    <tbody>
                        {changes.map((dayChange, dayIndex) => (
                            dayChange.changes.map((change, changeIndex) => (
                                <tr key={`${dayIndex}-${changeIndex}`}>
                                    {changeIndex === 0 && (
                                        <td rowSpan={dayChange.changes.length} className="font-medium">
                                            {new Date(dayChange.date).toLocaleDateString('en-US', {
                                                day: '2-digit',
                                                month: 'long',
                                                year: 'numeric'
                                            })}
                                        </td>
                                    )}
                                    <td>
                                        <div className="flex items-center gap-2">
                                            {change.is_simulation && (
                                                <span className="badge badge-sm">Simulation</span>
                                            )}
                                            {change.reason === "Scheduled Transaction" && (
                                                <div className="flex items-center gap-1">
                                                    <button
                                                        onClick={() => {
                                                            console.log('Edit button clicked for:', change);
                                                            handleEditClick(change, dayChange.date);
                                                        }}
                                                        className="btn btn-ghost btn-xs"
                                                    >
                                                        <FiEdit2 className="h-4 w-4" />
                                                    </button>
                                                    <button
                                                        onClick={() => change.id && handleDelete(change.id)}
                                                        className="btn btn-ghost btn-xs text-error"
                                                    >
                                                        <FiTrash2 className="h-4 w-4" />
                                                    </button>
                                                </div>
                                            )}
                                            <div>
                                                <span>{change.reason}</span>
                                                {change.payee && (
                                                    <span className="text-sm text-base-content/70 block">{change.payee}</span>
                                                )}
                                            </div>
                                        </div>
                                        {change.memo && (
                                            <span className="text-sm text-base-content/70 block">{change.memo}</span>
                                        )}
                                    </td>
                                    <td>{change.category}</td>
                                    <td className={`text-right ${change.amount >= 0 ? 'text-success' : 'text-error'}`}>
                                        {change.amount >= 0 ? '+' : ''}{change.amount.toFixed(2)}
                                    </td>
                                    {changeIndex === 0 && (
                                        <td rowSpan={dayChange.changes.length} className="text-right">
                                            {dayChange.balance.toFixed(2)}
                                            <div className={`text-sm ${dayChange.balance_diff >= 0 ? 'text-success' : 'text-error'}`}>
                                                {dayChange.balance_diff >= 0 ? '+' : ''}{dayChange.balance_diff.toFixed(2)}
                                            </div>
                                        </td>
                                    )}
                                </tr>
                            ))
                        ))}
                    </tbody>
                </table>
            </div>

            <EditTransactionDialog
                key={`edit-${editingTransaction}`}
                isOpen={!!editingTransaction}
                onClose={() => {
                    console.log('Dialog closing');
                    setEditingTransaction(null);
                    setSelectedTransaction(undefined);
                }}
                onSave={handleDialogSave}
                categories={categories}
                accounts={accounts}
                budgetUuid={budgetUuid}
                transaction={selectedTransaction}
                mode="edit"
            />

            <EditTransactionDialog
                key="create"
                isOpen={isCreateDialogOpen}
                onClose={() => setIsCreateDialogOpen(false)}
                onCreate={handleCreate}
                categories={categories}
                accounts={accounts}
                budgetUuid={budgetUuid}
                mode="create"
            />
        </div>
    );
};
</file>

<file path="packages/web/app/api/client.ts">
"use server";
import { getSession } from "@auth0/nextjs-auth0";
import { handleServerApiResponse } from './utils.server';
import { headers } from 'next/headers';
import { redirect } from "next/navigation";

export const getToken = async (accesToken?: string) => {
  if (accesToken) {
    return accesToken;
  }
  const session = await getSession();
  if (!session || !session.accessToken) {
    console.log("no session found, redirecting to login");
    if (!session?.user) {
      redirect("/login");
      return null;
    }
  }
  // todo remove this log!
  //console.log("token", session.accessToken);
  return session.accessToken;
};

export const apiFetch = async (
  path: string,
  options: RequestInit = {},
  accesToken?: string
) => {
  const token = await getToken(accesToken);
  if (!token) {
    return null;
  }
  const apiBaseUrl = process.env.API_URL || "http://localhost:4000";
  const apiUrl = new URL(path, apiBaseUrl).toString();
  console.log(`fetching ${apiUrl}, options: ${JSON.stringify(options)}`);
  try {
    // Get current pathname from headers if available (server-side)
    let currentPath = '/';
    try {
      const headersList = headers();
      currentPath = headersList.get('x-pathname') || '/';
    } catch (e) {
      // Headers not available (client-side)
      if (typeof window !== 'undefined') {
        currentPath = window.location.pathname;
      }
    }

    const response = await fetch(apiUrl, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${token}`,
        'x-pathname': currentPath,
      },
    });
    return handleServerApiResponse(apiUrl, response);
  } catch (error) {
    console.error(`Error fetching ${apiUrl}:`, error);
    throw error;
  }
};

export const apiGet = async <T>(path: string): Promise<T> => {
  return apiFetch(path);
};

export const apiPut = async (path: string, data: any, accessToken?: string) => {
  return apiFetch(
    path,
    {
      method: "PUT",
      body: JSON.stringify(data),
      headers: {
        "Content-Type": "application/json",
      },
    },
    accessToken
  );
};

export const apiPost = async (path: string, data: any) => {
  return apiFetch(path, {
    method: "POST",
    body: JSON.stringify(data),
    headers: {
      "Content-Type": "application/json",
    },
  });
};

export const apiDelete = async (path: string) => {
    return apiFetch(path, {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
        },
    });
};
</file>

<file path="packages/web/package.json">
{
  "name": "web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "vitest"
  },
  "dependencies": {
    "@auth0/nextjs-auth0": "^3.5.0",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.3",
    "@sentry/nextjs": "^8.37.1",
    "@tailwindcss/postcss": "^4.1.11",
    "chart.js": "^4.4.0",
    "chartjs-adapter-date-fns": "^3.0.0",
    "chartjs-plugin-datalabels": "^2.2.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cross-spawn": "^7.0.5",
    "date-fns": "^2.30.0",
    "lucide-react": "^0.477.0",
    "moment": "^2.29.4",
    "next": "^14.2.30",
    "next-auth": "^4.24.7",
    "next-themes": "^0.4.4",
    "prom-client": "^15.1.2",
    "ramda": "^0.29.1",
    "react": "latest",
    "react-chartjs-2": "^5.0.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "latest",
    "react-icons": "^5.2.0",
    "sonner": "^2.0.1",
    "tailwind-merge": "^3.0.2",
    "tailwindcss-animate": "^1.0.7",
    "vite": "^6.1.6"
  },
  "devDependencies": {
    "@shadcn/ui": "^0.0.4",
    "@testing-library/jest-dom": "6.1.2",
    "@testing-library/react": "14.0.0",
    "@testing-library/user-event": "14.4.3",
    "@types/node": "latest",
    "@types/ramda": "^0.29.9",
    "@types/react": "latest",
    "@types/react-dom": "latest",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "latest",
    "daisyui": "^5.0.50",
    "encoding": "^0.1.13",
    "eslint": "latest",
    "eslint-config-next": "latest",
    "jsdom": "^22.1.0",
    "postcss": "latest",
    "shadcn-ui": "^0.9.5",
    "tailwindcss": "latest",
    "typescript": "latest",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="packages/web/app/budgets/[budgetUuid]/predictions/page.tsx">
import { Suspense } from 'react';
import Link from 'next/link';
import { TimeRange, TIME_RANGES, DEFAULT_TIME_RANGE } from './constants';
import BudgetSubNavigation from '../../../components/budget-sub-navigation';
import Loading from '../../../components/Loading';
import PredictionChartSection from './PredictionChartSection';
import FutureChangesSection from './FutureChangesSection';
import InteractiveSimulationsSection from './InteractiveSimulationsSection';

interface PageProps {
    params: {
        budgetUuid: string;
    };
    searchParams: {
        timeRange?: TimeRange;
    };
}

export default async function PredictionsPage({ params, searchParams }: PageProps) {
    const timeRange = searchParams.timeRange || DEFAULT_TIME_RANGE;

    return (
        <>
            <BudgetSubNavigation budgetUuid={params.budgetUuid} />
            <div className="container mx-auto p-2 sm:p-4">
                <h1 className="text-xl sm:text-2xl font-bold mb-4 sm:mb-8">Predictions</h1>

                {/* Mobile-first layout: stack vertically on mobile, side-by-side on desktop */}
                <div className="flex flex-col lg:flex-row gap-4 lg:gap-8">
                    {/* Main content area - shows first on mobile */}
                    <div className="w-full lg:w-3/4 space-y-4 lg:space-y-8 order-1 lg:order-2">
                        <div className="card bg-base-100 shadow-xl">
                            <div className="card-body p-3 sm:p-6">
                                <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-4 gap-3">
                                    <h2 className="card-title text-lg sm:text-xl">Chart</h2>
                                    {/* Mobile-friendly time range selector */}
                                    <div className="flex flex-wrap gap-1 sm:join">
                                        {Object.entries(TIME_RANGES).map(([range, { label }]) => (
                                            <Link
                                                key={range}
                                                href={`/budgets/${params.budgetUuid}/predictions?timeRange=${range}`}
                                                className={`btn btn-xs sm:btn-sm flex-1 sm:flex-none sm:join-item ${timeRange === range ? 'btn-primary' : 'btn-ghost'
                                                    }`}
                                            >
                                                {label}
                                            </Link>
                                        ))}
                                    </div>
                                </div>
                                <div className="w-full overflow-hidden">
                                    <Suspense fallback={<div className="loading loading-spinner loading-lg" />}>
                                        <PredictionChartSection
                                            budgetUuid={params.budgetUuid}
                                            timeRange={timeRange}
                                        />
                                    </Suspense>
                                </div>
                            </div>
                        </div>

                        <div className="card bg-base-100 shadow-xl">
                            <div className="card-body p-3 sm:p-6">
                                <h2 className="card-title text-lg sm:text-xl mb-4">Future Changes</h2>
                                <Suspense fallback={<Loading />}>
                                    <FutureChangesSection
                                        budgetUuid={params.budgetUuid}
                                        timeRange={timeRange}
                                    />
                                </Suspense>
                            </div>
                        </div>
                    </div>

                    {/* Sidebar - shows after main content on mobile */}
                    <div className="w-full lg:w-1/4 order-2 lg:order-1">
                        <div className="card bg-base-100 shadow-xl lg:sticky lg:top-4">
                            <div className="card-body p-3 sm:p-6">
                                <h2 className="card-title text-lg sm:text-xl mb-4">Simulations</h2>
                                <Suspense fallback={<Loading />}>
                                    <InteractiveSimulationsSection
                                        budgetUuid={params.budgetUuid}
                                    />
                                </Suspense>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </>
    );
}
</file>

<file path="packages/mathapi/app/prediction_api.py">
from datetime import datetime, timedelta
from app.budget_api import get_objectid_for_budget
from app.ynab_api import get_scheduled_transactions
from app.categories_api import get_categories_for_budget
from app.accounts_api import get_accounts_for_budget
from collections import OrderedDict
import calendar
import logging

CADENCE_CONFIG = {
    1: {"type": "monthly", "interval": 1},       # Monthly cadence
    3: {"type": "quarterly", "interval": 3},    # Quarterly cadence
    13: {"type": "yearly", "interval": 12},     # Special case: Yearly with an irregular identifier
    # Add other cadence configurations as needed
}


def projected_balances_for_budget(budget_uuid, days_ahead=300, simulations=None):
    """
    Calculate projected balances for a budget over a specified period.
    
    Args:
        budget_uuid: The UUID of the budget
        days_ahead: Number of days to project into the future
        simulations: Optional list of simulation scenarios to include
        
    Returns:
        Dictionary containing daily projections with changes and balances
    """
    budget_id = get_objectid_for_budget(budget_uuid)
    future_transactions = get_scheduled_transactions(budget_uuid)
    categories = get_categories_for_budget(budget_id)
    accounts = get_accounts_for_budget(budget_id)
    
    # Perform balance prediction logic here
    projected_balances = project_daily_balances_with_reasons(accounts, categories, future_transactions, days_ahead, simulations)
    return projected_balances


def project_daily_balances_with_reasons(accounts, categories, future_transactions, days_ahead=30, simulations=None):
    """
    Project daily balances with detailed reasons for changes.
    
    Args:
        accounts: List of account objects with balances
        categories: List of budget categories
        future_transactions: List of scheduled future transactions
        days_ahead: Number of days to project into the future
        simulations: Optional list of simulation scenarios
        
    Returns:
        OrderedDict containing daily projections sorted by date
    """
    initial_balance = calculate_initial_balance(accounts)
    daily_projection = initialize_daily_projection(initial_balance, days_ahead)

    scheduled_dates_by_category = add_future_transactions_to_projection(daily_projection, future_transactions)

    process_need_categories(daily_projection, categories, scheduled_dates_by_category, days_ahead)

    add_simulations_to_projection(daily_projection, simulations)

    calculate_running_balance(daily_projection, initial_balance, days_ahead)
    projected_balances = {date: data for date, data in daily_projection.items() if data["changes"]}
    sorted_projected_balances = OrderedDict(sorted(projected_balances.items(), key=lambda item: item[0]))
    
    return sorted_projected_balances        


def calculate_initial_balance(accounts):
    """Calculate the total initial balance across all accounts (in thousands)."""
    return sum(account['balance'] for account in accounts) / 1000  # Convert to thousands


def initialize_daily_projection(initial_balance, days_ahead):
    """
    Initialize the daily projection dictionary with empty entries.
    
    Args:
        initial_balance: Starting balance for the projection
        days_ahead: Number of days to project into the future
        
    Returns:
        Dictionary with initialized daily entries
    """
    daily_projection = {}
    # Start with current day (day 0) up to days_ahead
    current_date = datetime.now().date()
    daily_projection[current_date.isoformat()] = {
        "balance": 0,  # Start with 0, balance will be calculated later
        "changes": [{
            "reason": "Initial Balance",
            "amount": initial_balance,
            "category": "Starting Balance"
        }]
    }
    
    # Add the following days
    for day in range(1, days_ahead + 1):
        date = (current_date + timedelta(days=day)).isoformat()
        daily_projection[date] = {
            "balance": 0,  # Start with 0, balance will be calculated later
            "changes": []
        }
    return daily_projection


def add_future_transactions_to_projection(daily_projection, future_transactions):
    """
    Add scheduled future transactions to the daily projection.
    
    Args:
        daily_projection: Dictionary containing daily projections
        future_transactions: List of scheduled transactions
        
    Returns:
        Dictionary mapping category names to sets of scheduled dates
    """
    scheduled_dates_by_category = {}
    for txn in future_transactions:
        transaction_date = datetime.strptime(txn['date_next'], '%Y-%m-%d').date().isoformat()
        category_name = txn['category_name']
        amount = txn['amount'] / 1000  # Convert to thousands

        if transaction_date in daily_projection:
            daily_projection[transaction_date]["changes"].append({
                "reason": "Scheduled Transaction",
                "amount": amount,  # Keep raw numeric value
                "category": category_name,
                "account": txn['account_name'],
                "payee": txn['payee_name'],
                "memo": txn['memo'],
                "id": txn.get('id', '')  # Make id optional
            })

            if category_name not in scheduled_dates_by_category:
                scheduled_dates_by_category[category_name] = set()
            scheduled_dates_by_category[category_name].add(transaction_date)

    return scheduled_dates_by_category


def process_need_categories(daily_projection, categories, scheduled_dates_by_category, days_ahead):
    """Process all categories with NEED type goals."""
    for category in categories:
        target = category.get("target")

        if target and target.get("goal_type") == "NEED":
            process_need_category(
                daily_projection,
                category,
                target,
                scheduled_dates_by_category,
                days_ahead
            )


def process_need_category(daily_projection, category, target, scheduled_dates_by_category, days_ahead):
    """
    Process a single NEED category and its spending targets.
    
    Args:
        daily_projection: Dictionary containing daily projections
        category: Category object with target information
        target: Target configuration for the category
        scheduled_dates_by_category: Dictionary of already scheduled dates
        days_ahead: Number of days to project into the future
    """
    target_amount = target.get("goal_target", 0) / 1000  # Convert to thousands
    current_balance = category.get("balance", 0) / 1000  # Convert to thousands
    global_overall_left = target.get("goal_overall_left")  # This could be None
    if global_overall_left is None:  # Explicitly handle None
        global_overall_left = 0
    global_overall_left /= 1000  # Convert to thousands

    # Pass the current balance to apply_need_category_spending
    # That function will determine if the balance should be used (only for current month)
    apply_need_category_spending(
        daily_projection,
        category,
        target,
        current_balance,
        target_amount,
        days_ahead,
        global_overall_left
    )


def apply_need_category_spending(daily_projection, category, target, current_balance, target_amount, days_ahead, global_overall_left):
    """
    Apply spending patterns for a NEED category based on its target configuration.
    
    Args:
        daily_projection: Dictionary containing daily projections
        category: Category object with target information
        target: Target configuration for the category
        current_balance: Current balance in the category
        target_amount: Target amount for the category
        days_ahead: Number of days to project into the future
        global_overall_left: Remaining amount in the overall goal
    """
    today = datetime.now().date()
    applied_months = set()
    cadence_interval = None
    cadence_config = None

    # Retrieve goal information
    goal_target_month = target.get("goal_target_month")
    goal_cadence_frequency = target.get("goal_cadence_frequency")
    goal_day = target.get("goal_day")  # Retrieve goal_day if available
    goal_cadence = target.get("goal_cadence")

    if goal_cadence_frequency:
        cadence_config = CADENCE_CONFIG.get(goal_cadence, {"type": "monthly", "interval": 1})  # Default to monthly
        cadence_interval = cadence_config["interval"] * goal_cadence_frequency  # Apply multiplier to interval
    elif goal_cadence and goal_cadence != 13:  # Handle direct cadence values (like 3 for quarterly)
        cadence_config = CADENCE_CONFIG.get(goal_cadence, {"type": "monthly", "interval": goal_cadence})
        cadence_interval = cadence_config["interval"]

    # Parse goal_target_month if it exists
    if goal_target_month:
        goal_target_month = datetime.strptime(goal_target_month, '%Y-%m-%d').date()

    for month_offset in range((days_ahead // 30) + 1):
        # Determine target year and month
        target_year = today.year + ((today.month - 1 + month_offset) // 12)
        target_month = ((today.month - 1 + month_offset) % 12) + 1
        target_date = datetime(target_year, target_month, 1).date()

        # Determine spending date
        days_in_month = calendar.monthrange(target_year, target_month)[1]
        spending_day = goal_day if goal_day and 1 <= goal_day <= days_in_month else days_in_month
        spending_date = datetime(target_year, target_month, spending_day).date()
        date_str = spending_date.isoformat()

        # Skip if already applied for this cadence period
        if target_date in applied_months:
            continue

        is_current_month = today.year == target_year and today.month == target_month

        # Calculate scheduled transactions for this month
        month_start = datetime(target_year, target_month, 1).date()
        month_end = datetime(target_year, target_month, days_in_month).date()
        scheduled_amount = 0
        for day in range(days_in_month):
            check_date = (month_start + timedelta(days=day)).isoformat()
            if check_date in daily_projection:
                for change in daily_projection[check_date]["changes"]:
                    if change["reason"] == "Scheduled Transaction" and change["category"] == category["name"]:
                        scheduled_amount += abs(change["amount"])  # Use abs() since changes are negative

        # Handle yearly cadence (goal_cadence 13) separately
        if goal_cadence == 13:  # Yearly cadence
            if goal_target_month and spending_date >= goal_target_month:
                # Only apply if we're at or past the target month
                if spending_date.month == goal_target_month.month and spending_date.year >= goal_target_month.year:
                    remaining_amount = global_overall_left if global_overall_left > 0 else target_amount
                    remaining_amount = max(0, remaining_amount - scheduled_amount)
                    if remaining_amount > 0:
                        apply_transaction(daily_projection, date_str, remaining_amount, category["name"], "Yearly Payment")
                    applied_months.add(target_date)
            continue

        # Handle goal_target_month logic for non-yearly cadences FIRST
        # This ensures that categories with specific target months are handled correctly
        if goal_target_month:
            # Check if we're in the same month and year as the goal_target_month
            goal_month_year = (goal_target_month.year, goal_target_month.month)
            target_month_year = (target_year, target_month)

            if target_month_year == goal_month_year:
                # We're in the target month - use the goal_day if specified, otherwise use goal_target_month day
                if goal_day and 1 <= goal_day <= days_in_month:
                    goal_spending_day = goal_day
                else:
                    goal_spending_day = goal_target_month.day if goal_target_month.day <= days_in_month else days_in_month
                goal_spending_date = datetime(target_year, target_month, goal_spending_day).date()
                goal_date_str = goal_spending_date.isoformat()

                # Use goal_overall_funded if goal_overall_left is 0 (fully funded)
                if global_overall_left > 0:
                    remaining_amount = max(0, global_overall_left - scheduled_amount)
                else:
                    # When fully funded, use the funded amount from the category
                    goal_overall_funded = target.get("goal_overall_funded", 0) / 1000  # Convert to thousands
                    remaining_amount = max(0, goal_overall_funded - scheduled_amount)

                if remaining_amount > 0:
                    apply_transaction(daily_projection, goal_date_str, remaining_amount, category["name"], "Goal Target Payment")
                applied_months.add(target_date)
                continue
            elif target_month_year > goal_month_year and cadence_interval:
                months_since_goal = (target_year - goal_target_month.year) * 12 + (target_month - goal_target_month.month)
                if months_since_goal % cadence_interval == 0:
                    # For recurring payments, use the same day as the original goal
                    recurring_spending_day = goal_target_month.day if goal_target_month.day <= days_in_month else days_in_month
                    recurring_spending_date = datetime(target_year, target_month, recurring_spending_day).date()
                    recurring_date_str = recurring_spending_date.isoformat()

                    remaining_amount = max(0, target_amount - scheduled_amount)
                    if remaining_amount > 0:
                        # Create appropriate reason text based on cadence type
                        if goal_cadence_frequency:
                            reason = f"Recurring Spending ({cadence_config['type'].capitalize()} every {goal_cadence_frequency})"
                        else:
                            reason = f"Recurring Spending ({cadence_config['type'].capitalize()})"
                        apply_transaction(daily_projection, recurring_date_str, remaining_amount, category["name"], reason)
                    applied_months.add(target_date)
                continue

        # Handle current month targets (only if no goal_target_month is specified)
        if not goal_target_month and is_current_month:
            remaining_amount = max(0, target_amount - scheduled_amount)
            # Calculate effective balance after scheduled transactions for current month
            effective_balance = max(0, current_balance - scheduled_amount)
            if effective_balance > 0:
                apply_transaction(daily_projection, date_str, effective_balance, category["name"], "Current Month Balance")
            elif remaining_amount > 0:
                apply_transaction(daily_projection, date_str, remaining_amount, category["name"], "Current Month Target")
            continue

        # If no goal_target_month is provided, apply spending at the specific day or end of the month
        if not goal_target_month and not is_current_month:
            remaining_amount = max(0, target_amount - scheduled_amount)
            if remaining_amount > 0:
                apply_transaction(daily_projection, date_str, remaining_amount, category["name"], "Future Month Target")


def apply_transaction(daily_projection, date_str, amount, category_name, reason):
    """Helper function to add transactions to the daily projection."""
    if date_str in daily_projection:
        daily_projection[date_str]["changes"].append({
            "reason": reason,
            "amount": -amount,  # Negative for expenses
            "category": category_name
        })
        


def add_simulations_to_projection(daily_projection, simulations):
    """Add simulation scenarios to the daily projection."""
    if not simulations:
        return

    for sim in simulations:
        sim_date = sim["date"]
        sim_amount = float(sim["amount"])  # Convert string to float
        sim_reason = sim.get("reason", "Simulation")
        sim_category = sim.get("category", "Miscellaneous")

        if sim_date in daily_projection:
            daily_projection[sim_date]["changes"].append({
                "amount": sim_amount,
                "category": sim_category,
                "reason": sim_reason,
                "is_simulation": True
            })


def calculate_running_balance(daily_projection, initial_balance, days_ahead):
    """
    Calculate running balances for each day in the projection.
    
    Args:
        daily_projection: Dictionary containing daily projections
        initial_balance: Starting balance for the calculation
        days_ahead: Number of days to calculate balances for
    """
    running_balance = 0  # Start with 0 since initial_balance is already added as a change
    for day in range(days_ahead + 1):
        current_date = (datetime.now().date() + timedelta(days=day)).isoformat()
        day_entry = daily_projection[current_date]

        # Apply changes and calculate new balance
        day_entry["balance_diff"] = sum(change["amount"] for change in day_entry["changes"])
        running_balance += day_entry["balance_diff"]

        # Update balance
        day_entry["balance"] = running_balance
</file>

</files>
